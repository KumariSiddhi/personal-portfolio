"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/drei/core/PointMaterial.js":
/*!**************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/PointMaterial.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PointMaterial: () => (/* binding */ PointMaterial),\n/* harmony export */   PointMaterialImpl: () => (/* binding */ PointMaterialImpl)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _helpers_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/constants.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/constants.js\");\n\n\n\n\nconst opaque_fragment = _helpers_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 154 ? \"opaque_fragment\" : \"output_fragment\";\nclass PointMaterialImpl extends three__WEBPACK_IMPORTED_MODULE_3__.PointsMaterial {\n    constructor(props){\n        super(props);\n        this.onBeforeCompile = (shader, renderer)=>{\n            const { isWebGL2 } = renderer.capabilities;\n            shader.fragmentShader = shader.fragmentShader.replace(`#include <${opaque_fragment}>`, `\n        ${!isWebGL2 ? `#extension GL_OES_standard_derivatives : enable\\n#include <${opaque_fragment}>` : `#include <${opaque_fragment}>`}\n      vec2 cxy = 2.0 * gl_PointCoord - 1.0;\n      float r = dot(cxy, cxy);\n      float delta = fwidth(r);     \n      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\n      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );\n      #include <tonemapping_fragment>\n      #include <${_helpers_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n      `);\n        };\n    }\n}\nconst PointMaterial = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, ref)=>{\n    const [material] = react__WEBPACK_IMPORTED_MODULE_1__.useState(()=>new PointMaterialImpl(null));\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n        object: material,\n        ref: ref,\n        attach: \"material\"\n    }));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9Qb2ludE1hdGVyaWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDQTtBQUNtQjtBQUVsRCxNQUFNSSxrQkFBa0JELDBEQUFPQSxJQUFJLE1BQU0sb0JBQW9CO0FBQzdELE1BQU1FLDBCQUEwQkosaURBQW9CO0lBQ2xETSxZQUFZQyxLQUFLLENBQUU7UUFDakIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsZUFBZSxHQUFHLENBQUNDLFFBQVFDO1lBQzlCLE1BQU0sRUFDSkMsUUFBUSxFQUNULEdBQUdELFNBQVNFLFlBQVk7WUFDekJILE9BQU9JLGNBQWMsR0FBR0osT0FBT0ksY0FBYyxDQUFDQyxPQUFPLENBQUMsQ0FBQyxVQUFVLEVBQUVYLGdCQUFnQixDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3RGLEVBQUUsQ0FBQ1EsV0FBVyxDQUFDLDJEQUEyRCxFQUFFUixnQkFBZ0IsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUVBLGdCQUFnQixDQUFDLENBQUMsQ0FBQzs7Ozs7OztnQkFPekgsRUFBRUQsMERBQU9BLElBQUksTUFBTSx3QkFBd0IscUJBQXFCO01BQzFFLENBQUM7UUFDSDtJQUNGO0FBQ0Y7QUFDQSxNQUFNYSxnQkFBZ0IsYUFBYSxpQkFBRWQsNkNBQWdCLENBQUMsQ0FBQ00sT0FBT1U7SUFDNUQsTUFBTSxDQUFDQyxTQUFTLEdBQUdqQiwyQ0FBYyxDQUFDLElBQU0sSUFBSUcsa0JBQWtCO0lBQzlELE9BQU8sV0FBVyxHQUFFSCxnREFBbUIsQ0FBQyxhQUFhRiw4RUFBUUEsQ0FBQyxDQUFDLEdBQUdRLE9BQU87UUFDdkVjLFFBQVFIO1FBQ1JELEtBQUtBO1FBQ0xLLFFBQVE7SUFDVjtBQUNGO0FBRTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvUG9pbnRNYXRlcmlhbC5qcz9kYTI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi9oZWxwZXJzL2NvbnN0YW50cy5qcyc7XG5cbmNvbnN0IG9wYXF1ZV9mcmFnbWVudCA9IHZlcnNpb24gPj0gMTU0ID8gJ29wYXF1ZV9mcmFnbWVudCcgOiAnb3V0cHV0X2ZyYWdtZW50JztcbmNsYXNzIFBvaW50TWF0ZXJpYWxJbXBsIGV4dGVuZHMgVEhSRUUuUG9pbnRzTWF0ZXJpYWwge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLm9uQmVmb3JlQ29tcGlsZSA9IChzaGFkZXIsIHJlbmRlcmVyKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzV2ViR0wyXG4gICAgICB9ID0gcmVuZGVyZXIuY2FwYWJpbGl0aWVzO1xuICAgICAgc2hhZGVyLmZyYWdtZW50U2hhZGVyID0gc2hhZGVyLmZyYWdtZW50U2hhZGVyLnJlcGxhY2UoYCNpbmNsdWRlIDwke29wYXF1ZV9mcmFnbWVudH0+YCwgYFxuICAgICAgICAkeyFpc1dlYkdMMiA/IGAjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcbiNpbmNsdWRlIDwke29wYXF1ZV9mcmFnbWVudH0+YCA6IGAjaW5jbHVkZSA8JHtvcGFxdWVfZnJhZ21lbnR9PmB9XG4gICAgICB2ZWMyIGN4eSA9IDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjA7XG4gICAgICBmbG9hdCByID0gZG90KGN4eSwgY3h5KTtcbiAgICAgIGZsb2F0IGRlbHRhID0gZndpZHRoKHIpOyAgICAgXG4gICAgICBmbG9hdCBtYXNrID0gMS4wIC0gc21vb3Roc3RlcCgxLjAgLSBkZWx0YSwgMS4wICsgZGVsdGEsIHIpO1xuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChnbF9GcmFnQ29sb3IucmdiLCBtYXNrICogZ2xfRnJhZ0NvbG9yLmEgKTtcbiAgICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cbiAgICAgICNpbmNsdWRlIDwke3ZlcnNpb24gPj0gMTU0ID8gJ2NvbG9yc3BhY2VfZnJhZ21lbnQnIDogJ2VuY29kaW5nc19mcmFnbWVudCd9PlxuICAgICAgYCk7XG4gICAgfTtcbiAgfVxufVxuY29uc3QgUG9pbnRNYXRlcmlhbCA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgW21hdGVyaWFsXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBQb2ludE1hdGVyaWFsSW1wbChudWxsKSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBvYmplY3Q6IG1hdGVyaWFsLFxuICAgIHJlZjogcmVmLFxuICAgIGF0dGFjaDogXCJtYXRlcmlhbFwiXG4gIH0pKTtcbn0pO1xuXG5leHBvcnQgeyBQb2ludE1hdGVyaWFsLCBQb2ludE1hdGVyaWFsSW1wbCB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiVEhSRUUiLCJSZWFjdCIsInZlcnNpb24iLCJvcGFxdWVfZnJhZ21lbnQiLCJQb2ludE1hdGVyaWFsSW1wbCIsIlBvaW50c01hdGVyaWFsIiwiY29uc3RydWN0b3IiLCJwcm9wcyIsIm9uQmVmb3JlQ29tcGlsZSIsInNoYWRlciIsInJlbmRlcmVyIiwiaXNXZWJHTDIiLCJjYXBhYmlsaXRpZXMiLCJmcmFnbWVudFNoYWRlciIsInJlcGxhY2UiLCJQb2ludE1hdGVyaWFsIiwiZm9yd2FyZFJlZiIsInJlZiIsIm1hdGVyaWFsIiwidXNlU3RhdGUiLCJjcmVhdGVFbGVtZW50Iiwib2JqZWN0IiwiYXR0YWNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/PointMaterial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Points.js":
/*!*******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Points.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   Points: () => (/* binding */ Points),\n/* harmony export */   PointsBuffer: () => (/* binding */ PointsBuffer),\n/* harmony export */   PositionPoint: () => (/* binding */ PositionPoint)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-776716bd.esm.js\");\n\n\n\n\nconst _inverseMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\nconst _ray = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_2__.Ray();\nconst _sphere = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_2__.Sphere();\nconst _position = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nclass PositionPoint extends three__WEBPACK_IMPORTED_MODULE_2__.Group {\n    constructor(){\n        super();\n        this.size = 0;\n        this.color = new three__WEBPACK_IMPORTED_MODULE_2__.Color(\"white\");\n        this.instance = {\n            current: undefined\n        };\n        this.instanceKey = {\n            current: undefined\n        };\n    }\n    // This will allow the virtual instance have bounds\n    get geometry() {\n        var _this$instance$curren;\n        return (_this$instance$curren = this.instance.current) == null ? void 0 : _this$instance$curren.geometry;\n    }\n    raycast(raycaster, intersects) {\n        var _raycaster$params$Poi, _raycaster$params$Poi2;\n        const parent = this.instance.current;\n        if (!parent || !parent.geometry) return;\n        const instanceId = parent.userData.instances.indexOf(this.instanceKey);\n        // If the instance wasn't found or exceeds the parents draw range, bail out\n        if (instanceId === -1 || instanceId > parent.geometry.drawRange.count) return;\n        const threshold = (_raycaster$params$Poi = (_raycaster$params$Poi2 = raycaster.params.Points) == null ? void 0 : _raycaster$params$Poi2.threshold) !== null && _raycaster$params$Poi !== void 0 ? _raycaster$params$Poi : 1;\n        _sphere.set(this.getWorldPosition(_position), threshold);\n        if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n        _inverseMatrix.copy(parent.matrixWorld).invert();\n        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n        const localThresholdSq = localThreshold * localThreshold;\n        const rayPointDistanceSq = _ray.distanceSqToPoint(this.position);\n        if (rayPointDistanceSq < localThresholdSq) {\n            const intersectPoint = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n            _ray.closestPointToPoint(this.position, intersectPoint);\n            intersectPoint.applyMatrix4(this.matrixWorld);\n            const distance = raycaster.ray.origin.distanceTo(intersectPoint);\n            if (distance < raycaster.near || distance > raycaster.far) return;\n            intersects.push({\n                distance: distance,\n                distanceToRay: Math.sqrt(rayPointDistanceSq),\n                point: intersectPoint,\n                index: instanceId,\n                face: null,\n                object: this\n            });\n        }\n    }\n}\nlet i, positionRef;\nconst context = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\nconst parentMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\nconst position = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n/**\n * Instance implementation, relies on react + context to update the attributes based on the children of this component\n */ const PointsInstances = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ children, range, limit = 1000, ...props }, ref)=>{\n    const parentRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, ()=>parentRef.current, []);\n    const [refs, setRefs] = react__WEBPACK_IMPORTED_MODULE_1__.useState([]);\n    const [[positions, colors, sizes]] = react__WEBPACK_IMPORTED_MODULE_1__.useState(()=>[\n            new Float32Array(limit * 3),\n            Float32Array.from({\n                length: limit * 3\n            }, ()=>1),\n            Float32Array.from({\n                length: limit\n            }, ()=>1)\n        ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        // We might be a frame too late? 🤷‍♂️\n        parentRef.current.geometry.attributes.position.needsUpdate = true;\n    });\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.F)(()=>{\n        parentRef.current.updateMatrix();\n        parentRef.current.updateMatrixWorld();\n        parentMatrix.copy(parentRef.current.matrixWorld).invert();\n        parentRef.current.geometry.drawRange.count = Math.min(limit, range !== undefined ? range : limit, refs.length);\n        for(i = 0; i < refs.length; i++){\n            positionRef = refs[i].current;\n            positionRef.getWorldPosition(position).applyMatrix4(parentMatrix);\n            position.toArray(positions, i * 3);\n            parentRef.current.geometry.attributes.position.needsUpdate = true;\n            positionRef.matrixWorldNeedsUpdate = true;\n            positionRef.color.toArray(colors, i * 3);\n            parentRef.current.geometry.attributes.color.needsUpdate = true;\n            sizes.set([\n                positionRef.size\n            ], i);\n            parentRef.current.geometry.attributes.size.needsUpdate = true;\n        }\n    });\n    const api = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>({\n            getParent: ()=>parentRef,\n            subscribe: (ref)=>{\n                setRefs((refs)=>[\n                        ...refs,\n                        ref\n                    ]);\n                return ()=>setRefs((refs)=>refs.filter((item)=>item.current !== ref.current));\n            }\n        }), []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"points\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        userData: {\n            instances: refs\n        },\n        matrixAutoUpdate: false,\n        ref: parentRef,\n        raycast: ()=>null\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferGeometry\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-position\",\n        count: positions.length / 3,\n        array: positions,\n        itemSize: 3,\n        usage: three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-color\",\n        count: colors.length / 3,\n        array: colors,\n        itemSize: 3,\n        usage: three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-size\",\n        count: sizes.length,\n        array: sizes,\n        itemSize: 1,\n        usage: three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(context.Provider, {\n        value: api\n    }, children));\n});\nconst Point = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ children, ...props }, ref)=>{\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.e)({\n            PositionPoint\n        }), []);\n    const group = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, ()=>group.current, []);\n    const { subscribe, getParent } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(context);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>subscribe(group), []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"positionPoint\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        instance: getParent(),\n        instanceKey: group,\n        ref: group\n    }, props), children);\n});\n/**\n * Buffer implementation, relies on complete buffers of the correct number, leaves it to the user to update them\n */ const PointsBuffer = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ children, positions, colors, sizes, stride = 3, ...props }, forwardedRef)=>{\n    const pointsRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(forwardedRef, ()=>pointsRef.current, []);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.F)(()=>{\n        const attr = pointsRef.current.geometry.attributes;\n        attr.position.needsUpdate = true;\n        if (colors) attr.color.needsUpdate = true;\n        if (sizes) attr.size.needsUpdate = true;\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"points\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ref: pointsRef\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferGeometry\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-position\",\n        count: positions.length / stride,\n        array: positions,\n        itemSize: stride,\n        usage: three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage\n    }), colors && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-color\",\n        count: colors.length / stride,\n        array: colors,\n        itemSize: 3,\n        usage: three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage\n    }), sizes && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-size\",\n        count: sizes.length / stride,\n        array: sizes,\n        itemSize: 1,\n        usage: three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage\n    })), children);\n});\nconst Points = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, forwardedRef)=>{\n    if (props.positions instanceof Float32Array) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(PointsBuffer, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n            ref: forwardedRef\n        }));\n    } else return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(PointsInstances, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n        ref: forwardedRef\n    }));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9Qb2ludHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQzNCO0FBQ0E7QUFDdUI7QUFFdEQsTUFBTUssaUJBQWlCLGFBQWEsR0FBRSxJQUFJSiwwQ0FBYTtBQUN2RCxNQUFNTSxPQUFPLGFBQWEsR0FBRSxJQUFJTixzQ0FBUztBQUN6QyxNQUFNUSxVQUFVLGFBQWEsR0FBRSxJQUFJUix5Q0FBWTtBQUMvQyxNQUFNVSxZQUFZLGFBQWEsR0FBRSxJQUFJViwwQ0FBYTtBQUNsRCxNQUFNWSxzQkFBc0JaLHdDQUFXO0lBQ3JDYyxhQUFjO1FBQ1osS0FBSztRQUNMLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxLQUFLLEdBQUcsSUFBSWhCLHdDQUFXLENBQUM7UUFDN0IsSUFBSSxDQUFDa0IsUUFBUSxHQUFHO1lBQ2RDLFNBQVNDO1FBQ1g7UUFDQSxJQUFJLENBQUNDLFdBQVcsR0FBRztZQUNqQkYsU0FBU0M7UUFDWDtJQUNGO0lBRUEsbURBQW1EO0lBQ25ELElBQUlFLFdBQVc7UUFDYixJQUFJQztRQUNKLE9BQU8sQ0FBQ0Esd0JBQXdCLElBQUksQ0FBQ0wsUUFBUSxDQUFDQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlJLHNCQUFzQkQsUUFBUTtJQUMxRztJQUNBRSxRQUFRQyxTQUFTLEVBQUVDLFVBQVUsRUFBRTtRQUM3QixJQUFJQyx1QkFBdUJDO1FBQzNCLE1BQU1DLFNBQVMsSUFBSSxDQUFDWCxRQUFRLENBQUNDLE9BQU87UUFDcEMsSUFBSSxDQUFDVSxVQUFVLENBQUNBLE9BQU9QLFFBQVEsRUFBRTtRQUNqQyxNQUFNUSxhQUFhRCxPQUFPRSxRQUFRLENBQUNDLFNBQVMsQ0FBQ0MsT0FBTyxDQUFDLElBQUksQ0FBQ1osV0FBVztRQUNyRSwyRUFBMkU7UUFDM0UsSUFBSVMsZUFBZSxDQUFDLEtBQUtBLGFBQWFELE9BQU9QLFFBQVEsQ0FBQ1ks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Q1ZULE9BQU9sSCxtREFBc0I7SUFDL0IsSUFBSTBGLFVBQVUsV0FBVyxHQUFFekYsZ0RBQW1CLENBQUMsbUJBQW1CO1FBQ2hFOEcsUUFBUTtRQUNSNUUsT0FBT3VELE9BQU9JLE1BQU0sR0FBRzZCO1FBQ3ZCWCxPQUFPdEI7UUFDUHVCLFVBQVU7UUFDVkMsT0FBT2xILG1EQUFzQjtJQUMvQixJQUFJMkYsU0FBUyxXQUFXLEdBQUUxRixnREFBbUIsQ0FBQyxtQkFBbUI7UUFDL0Q4RyxRQUFRO1FBQ1I1RSxPQUFPd0QsTUFBTUcsTUFBTSxHQUFHNkI7UUFDdEJYLE9BQU9yQjtRQUNQc0IsVUFBVTtRQUNWQyxPQUFPbEgsbURBQXNCO0lBQy9CLEtBQUs4RTtBQUNQO0FBQ0EsTUFBTXhDLFNBQVMsYUFBYSxpQkFBRXJDLDZDQUFnQixDQUFDLENBQUNnRixPQUFPMkM7SUFDckQsSUFBSTNDLE1BQU1RLFNBQVMsWUFBWUcsY0FBYztRQUMzQyxPQUFPLFdBQVcsR0FBRTNGLGdEQUFtQixDQUFDeUgsY0FBYzNILDhFQUFRQSxDQUFDLENBQUMsR0FBR2tGLE9BQU87WUFDeEVDLEtBQUswQztRQUNQO0lBQ0YsT0FBTyxPQUFPLFdBQVcsR0FBRTNILGdEQUFtQixDQUFDMkUsaUJBQWlCN0UsOEVBQVFBLENBQUMsQ0FBQyxHQUFHa0YsT0FBTztRQUNsRkMsS0FBSzBDO0lBQ1A7QUFDRjtBQUVzRCIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL1BvaW50cy5qcz9jNzI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGV4dGVuZCwgdXNlRnJhbWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuXG5jb25zdCBfaW52ZXJzZU1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqL25ldyBUSFJFRS5NYXRyaXg0KCk7XG5jb25zdCBfcmF5ID0gLyogQF9fUFVSRV9fICovbmV3IFRIUkVFLlJheSgpO1xuY29uc3QgX3NwaGVyZSA9IC8qIEBfX1BVUkVfXyAqL25ldyBUSFJFRS5TcGhlcmUoKTtcbmNvbnN0IF9wb3NpdGlvbiA9IC8qIEBfX1BVUkVfXyAqL25ldyBUSFJFRS5WZWN0b3IzKCk7XG5jbGFzcyBQb3NpdGlvblBvaW50IGV4dGVuZHMgVEhSRUUuR3JvdXAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvcignd2hpdGUnKTtcbiAgICB0aGlzLmluc3RhbmNlID0ge1xuICAgICAgY3VycmVudDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICB0aGlzLmluc3RhbmNlS2V5ID0ge1xuICAgICAgY3VycmVudDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIC8vIFRoaXMgd2lsbCBhbGxvdyB0aGUgdmlydHVhbCBpbnN0YW5jZSBoYXZlIGJvdW5kc1xuICBnZXQgZ2VvbWV0cnkoKSB7XG4gICAgdmFyIF90aGlzJGluc3RhbmNlJGN1cnJlbjtcbiAgICByZXR1cm4gKF90aGlzJGluc3RhbmNlJGN1cnJlbiA9IHRoaXMuaW5zdGFuY2UuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGluc3RhbmNlJGN1cnJlbi5nZW9tZXRyeTtcbiAgfVxuICByYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuICAgIHZhciBfcmF5Y2FzdGVyJHBhcmFtcyRQb2ksIF9yYXljYXN0ZXIkcGFyYW1zJFBvaTI7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5pbnN0YW5jZS5jdXJyZW50O1xuICAgIGlmICghcGFyZW50IHx8ICFwYXJlbnQuZ2VvbWV0cnkpIHJldHVybjtcbiAgICBjb25zdCBpbnN0YW5jZUlkID0gcGFyZW50LnVzZXJEYXRhLmluc3RhbmNlcy5pbmRleE9mKHRoaXMuaW5zdGFuY2VLZXkpO1xuICAgIC8vIElmIHRoZSBpbnN0YW5jZSB3YXNuJ3QgZm91bmQgb3IgZXhjZWVkcyB0aGUgcGFyZW50cyBkcmF3IHJhbmdlLCBiYWlsIG91dFxuICAgIGlmIChpbnN0YW5jZUlkID09PSAtMSB8fCBpbnN0YW5jZUlkID4gcGFyZW50Lmdlb21ldHJ5LmRyYXdSYW5nZS5jb3VudCkgcmV0dXJuO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IChfcmF5Y2FzdGVyJHBhcmFtcyRQb2kgPSAoX3JheWNhc3RlciRwYXJhbXMkUG9pMiA9IHJheWNhc3Rlci5wYXJhbXMuUG9pbnRzKSA9PSBudWxsID8gdm9pZCAwIDogX3JheWNhc3RlciRwYXJhbXMkUG9pMi50aHJlc2hvbGQpICE9PSBudWxsICYmIF9yYXljYXN0ZXIkcGFyYW1zJFBvaSAhPT0gdm9pZCAwID8gX3JheWNhc3RlciRwYXJhbXMkUG9pIDogMTtcbiAgICBfc3BoZXJlLnNldCh0aGlzLmdldFdvcmxkUG9zaXRpb24oX3Bvc2l0aW9uKSwgdGhyZXNob2xkKTtcbiAgICBpZiAocmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKF9zcGhlcmUpID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIF9pbnZlcnNlTWF0cml4LmNvcHkocGFyZW50Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgICBfcmF5LmNvcHkocmF5Y2FzdGVyLnJheSkuYXBwbHlNYXRyaXg0KF9pbnZlcnNlTWF0cml4KTtcbiAgICBjb25zdCBsb2NhbFRocmVzaG9sZCA9IHRocmVzaG9sZCAvICgodGhpcy5zY2FsZS54ICsgdGhpcy5zY2FsZS55ICsgdGhpcy5zY2FsZS56KSAvIDMpO1xuICAgIGNvbnN0IGxvY2FsVGhyZXNob2xkU3EgPSBsb2NhbFRocmVzaG9sZCAqIGxvY2FsVGhyZXNob2xkO1xuICAgIGNvbnN0IHJheVBvaW50RGlzdGFuY2VTcSA9IF9yYXkuZGlzdGFuY2VTcVRvUG9pbnQodGhpcy5wb3NpdGlvbik7XG4gICAgaWYgKHJheVBvaW50RGlzdGFuY2VTcSA8IGxvY2FsVGhyZXNob2xkU3EpIHtcbiAgICAgIGNvbnN0IGludGVyc2VjdFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIF9yYXkuY2xvc2VzdFBvaW50VG9Qb2ludCh0aGlzLnBvc2l0aW9uLCBpbnRlcnNlY3RQb2ludCk7XG4gICAgICBpbnRlcnNlY3RQb2ludC5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCk7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oaW50ZXJzZWN0UG9pbnQpO1xuICAgICAgaWYgKGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyKSByZXR1cm47XG4gICAgICBpbnRlcnNlY3RzLnB1c2goe1xuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgIGRpc3RhbmNlVG9SYXk6IE1hdGguc3FydChyYXlQb2ludERpc3RhbmNlU3EpLFxuICAgICAgICBwb2ludDogaW50ZXJzZWN0UG9pbnQsXG4gICAgICAgIGluZGV4OiBpbnN0YW5jZUlkLFxuICAgICAgICBmYWNlOiBudWxsLFxuICAgICAgICBvYmplY3Q6IHRoaXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxubGV0IGksIHBvc2l0aW9uUmVmO1xuY29uc3QgY29udGV4dCA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBwYXJlbnRNYXRyaXggPSAvKiBAX19QVVJFX18gKi9uZXcgVEhSRUUuTWF0cml4NCgpO1xuY29uc3QgcG9zaXRpb24gPSAvKiBAX19QVVJFX18gKi9uZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4vKipcbiAqIEluc3RhbmNlIGltcGxlbWVudGF0aW9uLCByZWxpZXMgb24gcmVhY3QgKyBjb250ZXh0IHRvIHVwZGF0ZSB0aGUgYXR0cmlidXRlcyBiYXNlZCBvbiB0aGUgY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnRcbiAqL1xuY29uc3QgUG9pbnRzSW5zdGFuY2VzID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBjaGlsZHJlbixcbiAgcmFuZ2UsXG4gIGxpbWl0ID0gMTAwMCxcbiAgLi4ucHJvcHNcbn0sIHJlZikgPT4ge1xuICBjb25zdCBwYXJlbnRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiBwYXJlbnRSZWYuY3VycmVudCwgW10pO1xuICBjb25zdCBbcmVmcywgc2V0UmVmc10gPSBSZWFjdC51c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtbcG9zaXRpb25zLCBjb2xvcnMsIHNpemVzXV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBbbmV3IEZsb2F0MzJBcnJheShsaW1pdCAqIDMpLCBGbG9hdDMyQXJyYXkuZnJvbSh7XG4gICAgbGVuZ3RoOiBsaW1pdCAqIDNcbiAgfSwgKCkgPT4gMSksIEZsb2F0MzJBcnJheS5mcm9tKHtcbiAgICBsZW5ndGg6IGxpbWl0XG4gIH0sICgpID0+IDEpXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gV2UgbWlnaHQgYmUgYSBmcmFtZSB0b28gbGF0ZT8g8J+kt+KAjeKZgu+4j1xuICAgIHBhcmVudFJlZi5jdXJyZW50Lmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9KTtcbiAgdXNlRnJhbWUoKCkgPT4ge1xuICAgIHBhcmVudFJlZi5jdXJyZW50LnVwZGF0ZU1hdHJpeCgpO1xuICAgIHBhcmVudFJlZi5jdXJyZW50LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgcGFyZW50TWF0cml4LmNvcHkocGFyZW50UmVmLmN1cnJlbnQubWF0cml4V29ybGQpLmludmVydCgpO1xuICAgIHBhcmVudFJlZi5jdXJyZW50Lmdlb21ldHJ5LmRyYXdSYW5nZS5jb3VudCA9IE1hdGgubWluKGxpbWl0LCByYW5nZSAhPT0gdW5kZWZpbmVkID8gcmFuZ2UgOiBsaW1pdCwgcmVmcy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCByZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3NpdGlvblJlZiA9IHJlZnNbaV0uY3VycmVudDtcbiAgICAgIHBvc2l0aW9uUmVmLmdldFdvcmxkUG9zaXRpb24ocG9zaXRpb24pLmFwcGx5TWF0cml4NChwYXJlbnRNYXRyaXgpO1xuICAgICAgcG9zaXRpb24udG9BcnJheShwb3NpdGlvbnMsIGkgKiAzKTtcbiAgICAgIHBhcmVudFJlZi5jdXJyZW50Lmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgcG9zaXRpb25SZWYubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICBwb3NpdGlvblJlZi5jb2xvci50b0FycmF5KGNvbG9ycywgaSAqIDMpO1xuICAgICAgcGFyZW50UmVmLmN1cnJlbnQuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICBzaXplcy5zZXQoW3Bvc2l0aW9uUmVmLnNpemVdLCBpKTtcbiAgICAgIHBhcmVudFJlZi5jdXJyZW50Lmdlb21ldHJ5LmF0dHJpYnV0ZXMuc2l6ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgYXBpID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGdldFBhcmVudDogKCkgPT4gcGFyZW50UmVmLFxuICAgIHN1YnNjcmliZTogcmVmID0+IHtcbiAgICAgIHNldFJlZnMocmVmcyA9PiBbLi4ucmVmcywgcmVmXSk7XG4gICAgICByZXR1cm4gKCkgPT4gc2V0UmVmcyhyZWZzID0+IHJlZnMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5jdXJyZW50ICE9PSByZWYuY3VycmVudCkpO1xuICAgIH1cbiAgfSksIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicG9pbnRzXCIsIF9leHRlbmRzKHtcbiAgICB1c2VyRGF0YToge1xuICAgICAgaW5zdGFuY2VzOiByZWZzXG4gICAgfSxcbiAgICBtYXRyaXhBdXRvVXBkYXRlOiBmYWxzZSxcbiAgICByZWY6IHBhcmVudFJlZixcbiAgICByYXljYXN0OiAoKSA9PiBudWxsXG4gIH0sIHByb3BzKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJHZW9tZXRyeVwiLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLCB7XG4gICAgYXR0YWNoOiBcImF0dHJpYnV0ZXMtcG9zaXRpb25cIixcbiAgICBjb3VudDogcG9zaXRpb25zLmxlbmd0aCAvIDMsXG4gICAgYXJyYXk6IHBvc2l0aW9ucyxcbiAgICBpdGVtU2l6ZTogMyxcbiAgICB1c2FnZTogVEhSRUUuRHluYW1pY0RyYXdVc2FnZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJBdHRyaWJ1dGVcIiwge1xuICAgIGF0dGFjaDogXCJhdHRyaWJ1dGVzLWNvbG9yXCIsXG4gICAgY291bnQ6IGNvbG9ycy5sZW5ndGggLyAzLFxuICAgIGFycmF5OiBjb2xvcnMsXG4gICAgaXRlbVNpemU6IDMsXG4gICAgdXNhZ2U6IFRIUkVFLkR5bmFtaWNEcmF3VXNhZ2VcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIsIHtcbiAgICBhdHRhY2g6IFwiYXR0cmlidXRlcy1zaXplXCIsXG4gICAgY291bnQ6IHNpemVzLmxlbmd0aCxcbiAgICBhcnJheTogc2l6ZXMsXG4gICAgaXRlbVNpemU6IDEsXG4gICAgdXNhZ2U6IFRIUkVFLkR5bmFtaWNEcmF3VXNhZ2VcbiAgfSkpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGFwaVxuICB9LCBjaGlsZHJlbikpO1xufSk7XG5jb25zdCBQb2ludCA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgY2hpbGRyZW4sXG4gIC4uLnByb3BzXG59LCByZWYpID0+IHtcbiAgUmVhY3QudXNlTWVtbygoKSA9PiBleHRlbmQoe1xuICAgIFBvc2l0aW9uUG9pbnRcbiAgfSksIFtdKTtcbiAgY29uc3QgZ3JvdXAgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiBncm91cC5jdXJyZW50LCBbXSk7XG4gIGNvbnN0IHtcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0UGFyZW50XG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gc3Vic2NyaWJlKGdyb3VwKSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb3NpdGlvblBvaW50XCIsIF9leHRlbmRzKHtcbiAgICBpbnN0YW5jZTogZ2V0UGFyZW50KCksXG4gICAgaW5zdGFuY2VLZXk6IGdyb3VwLFxuICAgIHJlZjogZ3JvdXBcbiAgfSwgcHJvcHMpLCBjaGlsZHJlbik7XG59KTtcblxuLyoqXG4gKiBCdWZmZXIgaW1wbGVtZW50YXRpb24sIHJlbGllcyBvbiBjb21wbGV0ZSBidWZmZXJzIG9mIHRoZSBjb3JyZWN0IG51bWJlciwgbGVhdmVzIGl0IHRvIHRoZSB1c2VyIHRvIHVwZGF0ZSB0aGVtXG4gKi9cblxuY29uc3QgUG9pbnRzQnVmZmVyID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBjaGlsZHJlbixcbiAgcG9zaXRpb25zLFxuICBjb2xvcnMsXG4gIHNpemVzLFxuICBzdHJpZGUgPSAzLFxuICAuLi5wcm9wc1xufSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHBvaW50c1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpID0+IHBvaW50c1JlZi5jdXJyZW50LCBbXSk7XG4gIHVzZUZyYW1lKCgpID0+IHtcbiAgICBjb25zdCBhdHRyID0gcG9pbnRzUmVmLmN1cnJlbnQuZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICBhdHRyLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBpZiAoY29sb3JzKSBhdHRyLmNvbG9yLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBpZiAoc2l6ZXMpIGF0dHIuc2l6ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb2ludHNcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcG9pbnRzUmVmXG4gIH0sIHByb3BzKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJHZW9tZXRyeVwiLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLCB7XG4gICAgYXR0YWNoOiBcImF0dHJpYnV0ZXMtcG9zaXRpb25cIixcbiAgICBjb3VudDogcG9zaXRpb25zLmxlbmd0aCAvIHN0cmlkZSxcbiAgICBhcnJheTogcG9zaXRpb25zLFxuICAgIGl0ZW1TaXplOiBzdHJpZGUsXG4gICAgdXNhZ2U6IFRIUkVFLkR5bmFtaWNEcmF3VXNhZ2VcbiAgfSksIGNvbG9ycyAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLCB7XG4gICAgYXR0YWNoOiBcImF0dHJpYnV0ZXMtY29sb3JcIixcbiAgICBjb3VudDogY29sb3JzLmxlbmd0aCAvIHN0cmlkZSxcbiAgICBhcnJheTogY29sb3JzLFxuICAgIGl0ZW1TaXplOiAzLFxuICAgIHVzYWdlOiBUSFJFRS5EeW5hbWljRHJhd1VzYWdlXG4gIH0pLCBzaXplcyAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLCB7XG4gICAgYXR0YWNoOiBcImF0dHJpYnV0ZXMtc2l6ZVwiLFxuICAgIGNvdW50OiBzaXplcy5sZW5ndGggLyBzdHJpZGUsXG4gICAgYXJyYXk6IHNpemVzLFxuICAgIGl0ZW1TaXplOiAxLFxuICAgIHVzYWdlOiBUSFJFRS5EeW5hbWljRHJhd1VzYWdlXG4gIH0pKSwgY2hpbGRyZW4pO1xufSk7XG5jb25zdCBQb2ludHMgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGlmIChwcm9wcy5wb3NpdGlvbnMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUG9pbnRzQnVmZmVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIHJlZjogZm9yd2FyZGVkUmVmXG4gICAgfSkpO1xuICB9IGVsc2UgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvaW50c0luc3RhbmNlcywgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgcmVmOiBmb3J3YXJkZWRSZWZcbiAgfSkpO1xufSk7XG5cbmV4cG9ydCB7IFBvaW50LCBQb2ludHMsIFBvaW50c0J1ZmZlciwgUG9zaXRpb25Qb2ludCB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiVEhSRUUiLCJSZWFjdCIsImV4dGVuZCIsInVzZUZyYW1lIiwiX2ludmVyc2VNYXRyaXgiLCJNYXRyaXg0IiwiX3JheSIsIlJheSIsIl9zcGhlcmUiLCJTcGhlcmUiLCJfcG9zaXRpb24iLCJWZWN0b3IzIiwiUG9zaXRpb25Qb2ludCIsIkdyb3VwIiwiY29uc3RydWN0b3IiLCJzaXplIiwiY29sb3IiLCJDb2xvciIsImluc3RhbmNlIiwiY3VycmVudCIsInVuZGVmaW5lZCIsImluc3RhbmNlS2V5IiwiZ2VvbWV0cnkiLCJfdGhpcyRpbnN0YW5jZSRjdXJyZW4iLCJyYXljYXN0IiwicmF5Y2FzdGVyIiwiaW50ZXJzZWN0cyIsIl9yYXljYXN0ZXIkcGFyYW1zJFBvaSIsIl9yYXljYXN0ZXIkcGFyYW1zJFBvaTIiLCJwYXJlbnQiLCJpbnN0YW5jZUlkIiwidXNlckRhdGEiLCJpbnN0YW5jZXMiLCJpbmRleE9mIiwiZHJhd1JhbmdlIiwiY291bnQiLCJ0aHJlc2hvbGQiLCJwYXJhbXMiLCJQb2ludHMiLCJzZXQiLCJnZXRXb3JsZFBvc2l0aW9uIiwicmF5IiwiaW50ZXJzZWN0c1NwaGVyZSIsImNvcHkiLCJtYXRyaXhXb3JsZCIsImludmVydCIsImFwcGx5TWF0cml4NCIsImxvY2FsVGhyZXNob2xkIiwic2NhbGUiLCJ4IiwieSIsInoiLCJsb2NhbFRocmVzaG9sZFNxIiwicmF5UG9pbnREaXN0YW5jZVNxIiwiZGlzdGFuY2VTcVRvUG9pbnQiLCJwb3NpdGlvbiIsImludGVyc2VjdFBvaW50IiwiY2xvc2VzdFBvaW50VG9Qb2ludCIsImRpc3RhbmNlIiwib3JpZ2luIiwiZGlzdGFuY2VUbyIsIm5lYXIiLCJmYXIiLCJwdXNoIiwiZGlzdGFuY2VUb1JheSIsIk1hdGgiLCJzcXJ0IiwicG9pbnQiLCJpbmRleCIsImZhY2UiLCJvYmplY3QiLCJpIiwicG9zaXRpb25SZWYiLCJjb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInBhcmVudE1hdHJpeCIsIlBvaW50c0luc3RhbmNlcyIsImZvcndhcmRSZWYiLCJjaGlsZHJlbiIsInJhbmdlIiwibGltaXQiLCJwcm9wcyIsInJlZiIsInBhcmVudFJlZiIsInVzZVJlZiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJyZWZzIiwic2V0UmVmcyIsInVzZVN0YXRlIiwicG9zaXRpb25zIiwiY29sb3JzIiwic2l6ZXMiLCJGbG9hdDMyQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwidXNlRWZmZWN0IiwiYXR0cmlidXRlcyIsIm5lZWRzVXBkYXRlIiwidXBkYXRlTWF0cml4IiwidXBkYXRlTWF0cml4V29ybGQiLCJtaW4iLCJ0b0FycmF5IiwibWF0cml4V29ybGROZWVkc1VwZGF0ZSIsImFwaSIsInVzZU1lbW8iLCJnZXRQYXJlbnQiLCJzdWJzY3JpYmUiLCJmaWx0ZXIiLCJpdGVtIiwiY3JlYXRlRWxlbWVudCIsIm1hdHJpeEF1dG9VcGRhdGUiLCJhdHRhY2giLCJhcnJheSIsIml0ZW1TaXplIiwidXNhZ2UiLCJEeW5hbWljRHJhd1VzYWdlIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsIlBvaW50IiwiZ3JvdXAiLCJ1c2VDb250ZXh0IiwidXNlTGF5b3V0RWZmZWN0IiwiUG9pbnRzQnVmZmVyIiwic3RyaWRlIiwiZm9yd2FyZGVkUmVmIiwicG9pbnRzUmVmIiwiYXR0ciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Points.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nconst getVersion = ()=>parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"));\nconst version = /* @__PURE__ */ getVersion();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFFakMsTUFBTUMsYUFBYSxJQUFNQyxTQUFTRiwyQ0FBUUEsQ0FBQ0csT0FBTyxDQUFDLFFBQVE7QUFDM0QsTUFBTUMsVUFBVSxhQUFhLEdBQUVIO0FBRVoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9jb25zdGFudHMuanM/NTA5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSRVZJU0lPTiB9IGZyb20gJ3RocmVlJztcblxuY29uc3QgZ2V0VmVyc2lvbiA9ICgpID0+IHBhcnNlSW50KFJFVklTSU9OLnJlcGxhY2UoL1xcRCsvZywgJycpKTtcbmNvbnN0IHZlcnNpb24gPSAvKiBAX19QVVJFX18gKi9nZXRWZXJzaW9uKCk7XG5cbmV4cG9ydCB7IHZlcnNpb24gfTtcbiJdLCJuYW1lcyI6WyJSRVZJU0lPTiIsImdldFZlcnNpb24iLCJwYXJzZUludCIsInJlcGxhY2UiLCJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/events-776716bd.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/events-776716bd.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ useInstanceHandle),\n/* harmony export */   B: () => (/* binding */ Block),\n/* harmony export */   C: () => (/* binding */ useStore),\n/* harmony export */   D: () => (/* binding */ useThree),\n/* harmony export */   E: () => (/* binding */ ErrorBoundary),\n/* harmony export */   F: () => (/* binding */ useFrame),\n/* harmony export */   G: () => (/* binding */ useGraph),\n/* harmony export */   H: () => (/* binding */ useLoader),\n/* harmony export */   a: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   b: () => (/* binding */ createRoot),\n/* harmony export */   c: () => (/* binding */ createPointerEvents),\n/* harmony export */   d: () => (/* binding */ unmountComponentAtNode),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   f: () => (/* binding */ createEvents),\n/* harmony export */   g: () => (/* binding */ context),\n/* harmony export */   h: () => (/* binding */ createPortal),\n/* harmony export */   i: () => (/* binding */ isRef),\n/* harmony export */   j: () => (/* binding */ reconciler),\n/* harmony export */   k: () => (/* binding */ applyProps),\n/* harmony export */   l: () => (/* binding */ dispose),\n/* harmony export */   m: () => (/* binding */ invalidate),\n/* harmony export */   n: () => (/* binding */ advance),\n/* harmony export */   o: () => (/* binding */ addEffect),\n/* harmony export */   p: () => (/* binding */ addAfterEffect),\n/* harmony export */   q: () => (/* binding */ addTail),\n/* harmony export */   r: () => (/* binding */ render),\n/* harmony export */   s: () => (/* binding */ flushGlobalEffects),\n/* harmony export */   t: () => (/* binding */ threeTypes),\n/* harmony export */   u: () => (/* binding */ useMutableCallback),\n/* harmony export */   v: () => (/* binding */ flushSync),\n/* harmony export */   w: () => (/* binding */ getRootState),\n/* harmony export */   x: () => (/* binding */ act),\n/* harmony export */   y: () => (/* binding */ buildGraph),\n/* harmony export */   z: () => (/* binding */ roots)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\nvar threeTypes = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nconst catalogue = {};\nconst extend = (objects)=>void Object.assign(catalogue, objects);\nfunction createRenderer(_roots, _getEventPriority) {\n    function createInstance(type, { args = [], attach, ...props }, root) {\n        let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n        let instance;\n        if (type === \"primitive\") {\n            if (props.object === undefined) throw new Error(\"R3F: Primitives without 'object' are invalid!\");\n            const object = props.object;\n            instance = prepare(object, {\n                type,\n                root,\n                attach,\n                primitive: true\n            });\n        } else {\n            const target = catalogue[name];\n            if (!target) {\n                throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n            }\n            // Throw if an object or literal was passed for args\n            if (!Array.isArray(args)) throw new Error(\"R3F: The args prop must be an array!\");\n            // Instanciate new object, link it to the root\n            // Append memoized props with args so it's not forgotten\n            instance = prepare(new target(...args), {\n                type,\n                root,\n                attach,\n                // Save args in case we need to reconstruct later for HMR\n                memoizedProps: {\n                    args\n                }\n            });\n        }\n        // Auto-attach geometries and materials\n        if (instance.__r3f.attach === undefined) {\n            if (instance.isBufferGeometry) instance.__r3f.attach = \"geometry\";\n            else if (instance.isMaterial) instance.__r3f.attach = \"material\";\n        }\n        // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n        // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n        // why it passes \"true\" here\n        // There is no reason to apply props to injects\n        if (name !== \"inject\") applyProps$1(instance, props);\n        return instance;\n    }\n    function appendChild(parentInstance, child) {\n        let added = false;\n        if (child) {\n            var _child$__r3f, _parentInstance$__r3f;\n            // The attach attribute implies that the object attaches itself on the parent\n            if ((_child$__r3f = child.__r3f) != null && _child$__r3f.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                // add in the usual parent-child way\n                parentInstance.add(child);\n                added = true;\n            }\n            // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n            // that is, anything that's a child in React but not a child in the scenegraph.\n            if (!added) (_parentInstance$__r3f = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function insertBefore(parentInstance, child, beforeChild) {\n        let added = false;\n        if (child) {\n            var _child$__r3f2, _parentInstance$__r3f2;\n            if ((_child$__r3f2 = child.__r3f) != null && _child$__r3f2.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                child.parent = parentInstance;\n                child.dispatchEvent({\n                    type: \"added\"\n                });\n                parentInstance.dispatchEvent({\n                    type: \"childadded\",\n                    child\n                });\n                const restSiblings = parentInstance.children.filter((sibling)=>sibling !== child);\n                const index = restSiblings.indexOf(beforeChild);\n                parentInstance.children = [\n                    ...restSiblings.slice(0, index),\n                    child,\n                    ...restSiblings.slice(index)\n                ];\n                added = true;\n            }\n            if (!added) (_parentInstance$__r3f2 = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f2.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function removeRecursive(array, parent, dispose = false) {\n        if (array) [\n            ...array\n        ].forEach((child)=>removeChild(parent, child, dispose));\n    }\n    function removeChild(parentInstance, child, dispose) {\n        if (child) {\n            var _parentInstance$__r3f3, _child$__r3f3, _child$__r3f5;\n            // Clear the parent reference\n            if (child.__r3f) child.__r3f.parent = null;\n            // Remove child from the parents objects\n            if ((_parentInstance$__r3f3 = parentInstance.__r3f) != null && _parentInstance$__r3f3.objects) parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter((x)=>x !== child);\n            // Remove attachment\n            if ((_child$__r3f3 = child.__r3f) != null && _child$__r3f3.attach) {\n                detach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                var _child$__r3f4;\n                parentInstance.remove(child);\n                // @ts-expect-error\n                // Remove interactivity on the initial root\n                if ((_child$__r3f4 = child.__r3f) != null && _child$__r3f4.root) {\n                    removeInteractivity(findInitialRoot(child), child);\n                }\n            }\n            // Allow objects to bail out of recursive dispose altogether by passing dispose={null}\n            // Never dispose of primitives because their state may be kept outside of React!\n            // In order for an object to be able to dispose it has to have\n            //   - a dispose method,\n            //   - it cannot be a <primitive object={...} />\n            //   - it cannot be a THREE.Scene, because three has broken it's own api\n            //\n            // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n            // when the reconciler calls it, but then carry our own check recursively\n            const isPrimitive = (_child$__r3f5 = child.__r3f) == null ? void 0 : _child$__r3f5.primitive;\n            const shouldDispose = !isPrimitive && (dispose === undefined ? child.dispose !== null : dispose);\n            // Remove nested child objects. Primitives should not have objects and children that are\n            // attached to them declaratively ...\n            if (!isPrimitive) {\n                var _child$__r3f6;\n                removeRecursive((_child$__r3f6 = child.__r3f) == null ? void 0 : _child$__r3f6.objects, child, shouldDispose);\n                removeRecursive(child.children, child, shouldDispose);\n            }\n            // Remove references\n            delete child.__r3f;\n            // Dispose item whenever the reconciler feels like it\n            if (shouldDispose && child.dispose && child.type !== \"Scene\") {\n                const callback = ()=>{\n                    try {\n                        child.dispose();\n                    } catch (e) {\n                    /* ... */ }\n                };\n                // Schedule async at runtime, flush sync in testing\n                if (typeof IS_REACT_ACT_ENVIRONMENT === \"undefined\") {\n                    (0,scheduler__WEBPACK_IMPORTED_MODULE_4__.unstable_scheduleCallback)(scheduler__WEBPACK_IMPORTED_MODULE_4__.unstable_IdlePriority, callback);\n                } else {\n                    callback();\n                }\n            }\n            invalidateInstance(parentInstance);\n        }\n    }\n    function switchInstance(instance, type, newProps, fiber) {\n        var _instance$__r3f;\n        const parent = (_instance$__r3f = instance.__r3f) == null ? void 0 : _instance$__r3f.parent;\n        if (!parent) return;\n        const newInstance = createInstance(type, newProps, instance.__r3f.root);\n        // https://github.com/pmndrs/react-three-fiber/issues/1348\n        // When args change the instance has to be re-constructed, which then\n        // forces r3f to re-parent the children and non-scene objects\n        if (instance.children) {\n            for (const child of instance.children){\n                if (child.__r3f) appendChild(newInstance, child);\n            }\n            instance.children = instance.children.filter((child)=>!child.__r3f);\n        }\n        instance.__r3f.objects.forEach((child)=>appendChild(newInstance, child));\n        instance.__r3f.objects = [];\n        if (!instance.__r3f.autoRemovedBeforeAppend) {\n            removeChild(parent, instance);\n        }\n        if (newInstance.parent) {\n            newInstance.__r3f.autoRemovedBeforeAppend = true;\n        }\n        appendChild(parent, newInstance);\n        // Re-bind event handlers on the initial root\n        if (newInstance.raycast && newInstance.__r3f.eventCount) {\n            const rootState = findInitialRoot(newInstance).getState();\n            rootState.internal.interaction.push(newInstance);\n        }\n        [\n            fiber,\n            fiber.alternate\n        ].forEach((fiber)=>{\n            if (fiber !== null) {\n                fiber.stateNode = newInstance;\n                if (fiber.ref) {\n                    if (typeof fiber.ref === \"function\") fiber.ref(newInstance);\n                    else fiber.ref.current = newInstance;\n                }\n            }\n        });\n    }\n    // Don't handle text instances, make it no-op\n    const handleTextInstance = ()=>{};\n    const reconciler = react_reconciler__WEBPACK_IMPORTED_MODULE_3___default()({\n        createInstance,\n        removeChild,\n        appendChild,\n        appendInitialChild: appendChild,\n        insertBefore,\n        supportsMutation: true,\n        isPrimaryRenderer: false,\n        supportsPersistence: false,\n        supportsHydration: false,\n        noTimeout: -1,\n        appendChildToContainer: (container, child)=>{\n            if (!child) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            // Link current root to the default scene\n            scene.__r3f.root = container;\n            appendChild(scene, child);\n        },\n        removeChildFromContainer: (container, child)=>{\n            if (!child) return;\n            removeChild(container.getState().scene, child);\n        },\n        insertInContainerBefore: (container, child, beforeChild)=>{\n            if (!child || !beforeChild) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            insertBefore(scene, child, beforeChild);\n        },\n        getRootHostContext: ()=>null,\n        getChildHostContext: (parentHostContext)=>parentHostContext,\n        finalizeInitialChildren (instance) {\n            var _instance$__r3f2;\n            const localState = (_instance$__r3f2 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f2 : {};\n            // https://github.com/facebook/react/issues/20271\n            // Returning true will trigger commitMount\n            return Boolean(localState.handlers);\n        },\n        prepareUpdate (instance, _type, oldProps, newProps) {\n            var _instance$__r3f3;\n            const localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};\n            // Create diff-sets\n            if (localState.primitive && newProps.object && newProps.object !== instance) {\n                return [\n                    true\n                ];\n            } else {\n                // This is a data object, let's extract critical information about it\n                const { args: argsNew = [], children: cN, ...restNew } = newProps;\n                const { args: argsOld = [], children: cO, ...restOld } = oldProps;\n                // Throw if an object or literal was passed for args\n                if (!Array.isArray(argsNew)) throw new Error(\"R3F: the args prop must be an array!\");\n                // If it has new props or arguments, then it needs to be re-instantiated\n                if (argsNew.some((value, index)=>value !== argsOld[index])) return [\n                    true\n                ];\n                // Create a diff-set, flag if there are any changes\n                const diff = diffProps(instance, restNew, restOld, true);\n                if (diff.changes.length) return [\n                    false,\n                    diff\n                ];\n                // Otherwise do not touch the instance\n                return null;\n            }\n        },\n        commitUpdate (instance, [reconstruct, diff], type, _oldProps, newProps, fiber) {\n            // Reconstruct when args or <primitive object={...} have changes\n            if (reconstruct) switchInstance(instance, type, newProps, fiber);\n            else applyProps$1(instance, diff);\n        },\n        commitMount (instance, _type, _props, _int) {\n            var _instance$__r3f4;\n            // https://github.com/facebook/react/issues/20271\n            // This will make sure events are only added once to the central container on the initial root\n            const localState = (_instance$__r3f4 = instance.__r3f) != null ? _instance$__r3f4 : {};\n            if (instance.raycast && localState.handlers && localState.eventCount) {\n                findInitialRoot(instance).getState().internal.interaction.push(instance);\n            }\n        },\n        getPublicInstance: (instance)=>instance,\n        prepareForCommit: ()=>null,\n        preparePortalMount: (container)=>prepare(container.getState().scene),\n        resetAfterCommit: ()=>{},\n        shouldSetTextContent: ()=>false,\n        clearContainer: ()=>false,\n        hideInstance (instance) {\n            var _instance$__r3f5;\n            // Detach while the instance is hidden\n            const { attach: type, parent } = (_instance$__r3f5 = instance.__r3f) != null ? _instance$__r3f5 : {};\n            if (type && parent) detach(parent, instance, type);\n            if (instance.isObject3D) instance.visible = false;\n            invalidateInstance(instance);\n        },\n        unhideInstance (instance, props) {\n            var _instance$__r3f6;\n            // Re-attach when the instance is unhidden\n            const { attach: type, parent } = (_instance$__r3f6 = instance.__r3f) != null ? _instance$__r3f6 : {};\n            if (type && parent) attach(parent, instance, type);\n            if (instance.isObject3D && props.visible == null || props.visible) instance.visible = true;\n            invalidateInstance(instance);\n        },\n        createTextInstance: handleTextInstance,\n        hideTextInstance: handleTextInstance,\n        unhideTextInstance: handleTextInstance,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874\n        // @ts-expect-error\n        getCurrentEventPriority: ()=>_getEventPriority ? _getEventPriority() : react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority,\n        beforeActiveInstanceBlur: ()=>{},\n        afterActiveInstanceBlur: ()=>{},\n        detachDeletedInstance: ()=>{},\n        now: typeof performance !== \"undefined\" && is.fun(performance.now) ? performance.now : is.fun(Date.now) ? Date.now : ()=>0,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503\n        scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n        cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined\n    });\n    return {\n        reconciler,\n        applyProps: applyProps$1\n    };\n}\nvar _window$document, _window$navigator;\n/**\r\n * Returns `true` with correct TS type inference if an object has a configurable color space (since r152).\r\n */ const hasColorSpace = (object)=>\"colorSpace\" in object || \"outputColorSpace\" in object;\n/**\r\n * The current THREE.ColorManagement instance, if present.\r\n */ const getColorManagement = ()=>{\n    var _ColorManagement;\n    return (_ColorManagement = catalogue.ColorManagement) != null ? _ColorManagement : null;\n};\nconst isOrthographicCamera = (def)=>def && def.isOrthographicCamera;\nconst isRef = (obj)=>obj && obj.hasOwnProperty(\"current\");\n/**\r\n * An SSR-friendly useLayoutEffect.\r\n *\r\n * React currently throws a warning when using useLayoutEffect on the server.\r\n * To get around it, we can conditionally useEffect on the server (no-op) and\r\n * useLayoutEffect elsewhere.\r\n *\r\n * @see https://github.com/facebook/react/issues/14927\r\n */ const useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useMutableCallback(fn) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fn);\n    useIsomorphicLayoutEffect(()=>void (ref.current = fn), [\n        fn\n    ]);\n    return ref;\n}\nfunction Block({ set }) {\n    useIsomorphicLayoutEffect(()=>{\n        set(new Promise(()=>null));\n        return ()=>set(false);\n    }, [\n        set\n    ]);\n    return null;\n}\nclass ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(...args){\n        super(...args);\n        this.state = {\n            error: false\n        };\n    }\n    componentDidCatch(err) {\n        this.props.set(err);\n    }\n    render() {\n        return this.state.error ? null : this.props.children;\n    }\n}\nErrorBoundary.getDerivedStateFromError = ()=>({\n        error: true\n    });\nconst DEFAULT = \"__default\";\nconst DEFAULTS = new Map();\nconst isDiffSet = (def)=>def && !!def.memoized && !!def.changes;\nfunction calculateDpr(dpr) {\n    var _window$devicePixelRa;\n    // Err on the side of progress by assuming 2x dpr if we can't detect it\n    // This will happen in workers where window is defined but dpr isn't.\n    const target =  false ? 0 : 1;\n    return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n/**\r\n * Returns instance root state\r\n */ const getRootState = (obj)=>{\n    var _r3f;\n    return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n};\n/**\r\n * Returns the instances initial (outmost) root\r\n */ function findInitialRoot(child) {\n    let root = child.__r3f.root;\n    while(root.getState().previousRoot)root = root.getState().previousRoot;\n    return root;\n}\n// A collection of compare functions\nconst is = {\n    obj: (a)=>a === Object(a) && !is.arr(a) && typeof a !== \"function\",\n    fun: (a)=>typeof a === \"function\",\n    str: (a)=>typeof a === \"string\",\n    num: (a)=>typeof a === \"number\",\n    boo: (a)=>typeof a === \"boolean\",\n    und: (a)=>a === void 0,\n    arr: (a)=>Array.isArray(a),\n    equ (a, b, { arrays = \"shallow\", objects = \"reference\", strict = true } = {}) {\n        // Wrong type or one of the two undefined, doesn't match\n        if (typeof a !== typeof b || !!a !== !!b) return false;\n        // Atomic, just compare a against b\n        if (is.str(a) || is.num(a) || is.boo(a)) return a === b;\n        const isObj = is.obj(a);\n        if (isObj && objects === \"reference\") return a === b;\n        const isArr = is.arr(a);\n        if (isArr && arrays === \"reference\") return a === b;\n        // Array or Object, shallow compare first to see if it's a match\n        if ((isArr || isObj) && a === b) return true;\n        // Last resort, go through keys\n        let i;\n        // Check if a has all the keys of b\n        for(i in a)if (!(i in b)) return false;\n        // Check if values between keys match\n        if (isObj && arrays === \"shallow\" && objects === \"shallow\") {\n            for(i in strict ? b : a)if (!is.equ(a[i], b[i], {\n                strict,\n                objects: \"reference\"\n            })) return false;\n        } else {\n            for(i in strict ? b : a)if (a[i] !== b[i]) return false;\n        }\n        // If i is undefined\n        if (is.und(i)) {\n            // If both arrays are empty we consider them equal\n            if (isArr && a.length === 0 && b.length === 0) return true;\n            // If both objects are empty we consider them equal\n            if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n            // Otherwise match them by value\n            if (a !== b) return false;\n        }\n        return true;\n    }\n};\n/**\r\n * Collects nodes and materials from a THREE.Object3D.\r\n */ function buildGraph(object) {\n    const data = {\n        nodes: {},\n        materials: {}\n    };\n    if (object) {\n        object.traverse((obj)=>{\n            if (obj.name) data.nodes[obj.name] = obj;\n            if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n        });\n    }\n    return data;\n}\n// Disposes an object and all its properties\nfunction dispose(obj) {\n    if (obj.dispose && obj.type !== \"Scene\") obj.dispose();\n    for(const p in obj){\n        p.dispose == null ? void 0 : p.dispose();\n        delete obj[p];\n    }\n}\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(object, state) {\n    const instance = object;\n    instance.__r3f = {\n        type: \"\",\n        root: null,\n        previousAttach: null,\n        memoizedProps: {},\n        eventCount: 0,\n        handlers: {},\n        objects: [],\n        parent: null,\n        ...state\n    };\n    return object;\n}\nfunction resolve(instance, key) {\n    let target = instance;\n    if (key.includes(\"-\")) {\n        const entries = key.split(\"-\");\n        const last = entries.pop();\n        target = entries.reduce((acc, key)=>acc[key], instance);\n        return {\n            target,\n            key: last\n        };\n    } else return {\n        target,\n        key\n    };\n}\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child, type) {\n    if (is.str(type)) {\n        // If attaching into an array (foo-0), create one\n        if (INDEX_REGEX.test(type)) {\n            const root = type.replace(INDEX_REGEX, \"\");\n            const { target, key } = resolve(parent, root);\n            if (!Array.isArray(target[key])) target[key] = [];\n        }\n        const { target, key } = resolve(parent, type);\n        child.__r3f.previousAttach = target[key];\n        target[key] = child;\n    } else child.__r3f.previousAttach = type(parent, child);\n}\nfunction detach(parent, child, type) {\n    var _child$__r3f, _child$__r3f2;\n    if (is.str(type)) {\n        const { target, key } = resolve(parent, type);\n        const previous = child.__r3f.previousAttach;\n        // When the previous value was undefined, it means the value was never set to begin with\n        if (previous === undefined) delete target[key];\n        else target[key] = previous;\n    } else (_child$__r3f = child.__r3f) == null ? void 0 : _child$__r3f.previousAttach == null ? void 0 : _child$__r3f.previousAttach(parent, child);\n    (_child$__r3f2 = child.__r3f) == null ? true : delete _child$__r3f2.previousAttach;\n}\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, { children: cN, key: kN, ref: rN, ...props }, { children: cP, key: kP, ref: rP, ...previous } = {}, remove = false) {\n    const localState = instance.__r3f;\n    const entries = Object.entries(props);\n    const changes = [];\n    // Catch removed props, prepend them so they can be reset or removed\n    if (remove) {\n        const previousKeys = Object.keys(previous);\n        for(let i = 0; i < previousKeys.length; i++){\n            if (!props.hasOwnProperty(previousKeys[i])) entries.unshift([\n                previousKeys[i],\n                DEFAULT + \"remove\"\n            ]);\n        }\n    }\n    entries.forEach(([key, value])=>{\n        var _instance$__r3f;\n        // Bail out on primitive object\n        if ((_instance$__r3f = instance.__r3f) != null && _instance$__r3f.primitive && key === \"object\") return;\n        // When props match bail out\n        if (is.equ(value, previous[key])) return;\n        // Collect handlers and bail out\n        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([\n            key,\n            value,\n            true,\n            []\n        ]);\n        // Split dashed props\n        let entries = [];\n        if (key.includes(\"-\")) entries = key.split(\"-\");\n        changes.push([\n            key,\n            value,\n            false,\n            entries\n        ]);\n        // Reset pierced props\n        for(const prop in props){\n            const value = props[prop];\n            if (prop.startsWith(`${key}-`)) changes.push([\n                prop,\n                value,\n                false,\n                prop.split(\"-\")\n            ]);\n        }\n    });\n    const memoized = {\n        ...props\n    };\n    if (localState != null && localState.memoizedProps && localState != null && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;\n    if (localState != null && localState.memoizedProps && localState != null && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;\n    return {\n        memoized,\n        changes\n    };\n}\nconst __DEV__ = typeof process !== \"undefined\" && \"development\" !== \"production\";\n// This function applies a set of changes to the instance\nfunction applyProps$1(instance, data) {\n    var _instance$__r3f2;\n    // Filter equals, events and reserved props\n    const localState = instance.__r3f;\n    const root = localState == null ? void 0 : localState.root;\n    const rootState = root == null ? void 0 : root.getState == null ? void 0 : root.getState();\n    const { memoized, changes } = isDiffSet(data) ? data : diffProps(instance, data);\n    const prevHandlers = localState == null ? void 0 : localState.eventCount;\n    // Prepare memoized props\n    if (instance.__r3f) instance.__r3f.memoizedProps = memoized;\n    for(let i = 0; i < changes.length; i++){\n        let [key, value, isEvent, keys] = changes[i];\n        // Alias (output)encoding => (output)colorSpace (since r152)\n        // https://github.com/pmndrs/react-three-fiber/pull/2829\n        if (hasColorSpace(instance)) {\n            const sRGBEncoding = 3001;\n            const SRGBColorSpace = \"srgb\";\n            const LinearSRGBColorSpace = \"srgb-linear\";\n            if (key === \"encoding\") {\n                key = \"colorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            } else if (key === \"outputEncoding\") {\n                key = \"outputColorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            }\n        }\n        let currentInstance = instance;\n        let targetProp = currentInstance[key];\n        // Revolve dashed props\n        if (keys.length) {\n            targetProp = keys.reduce((acc, key)=>acc[key], instance);\n            // If the target is atomic, it forces us to switch the root\n            if (!(targetProp && targetProp.set)) {\n                const [name, ...reverseEntries] = keys.reverse();\n                currentInstance = reverseEntries.reverse().reduce((acc, key)=>acc[key], instance);\n                key = name;\n            }\n        }\n        // https://github.com/mrdoob/three.js/issues/21209\n        // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n        // has no means to do this. Hence we curate a small collection of value-classes\n        // with their respective constructor/set arguments\n        // For removed props, try to set default values, if possible\n        if (value === DEFAULT + \"remove\") {\n            if (currentInstance.constructor) {\n                // create a blank slate of the instance and copy the particular parameter.\n                let ctor = DEFAULTS.get(currentInstance.constructor);\n                if (!ctor) {\n                    // @ts-expect-error\n                    ctor = new currentInstance.constructor();\n                    DEFAULTS.set(currentInstance.constructor, ctor);\n                }\n                value = ctor[key];\n            } else {\n                // instance does not have constructor, just set it to 0\n                value = 0;\n            }\n        }\n        // Deal with pointer events ...\n        if (isEvent && localState) {\n            if (value) localState.handlers[key] = value;\n            else delete localState.handlers[key];\n            localState.eventCount = Object.keys(localState.handlers).length;\n        } else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof three__WEBPACK_IMPORTED_MODULE_5__.Layers)) {\n            // If value is an array\n            if (Array.isArray(value)) {\n                if (targetProp.fromArray) targetProp.fromArray(value);\n                else targetProp.set(...value);\n            } else if (targetProp.copy && value && value.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.\n            // Loosen to unminified names, ignoring descendents.\n            // https://github.com/pmndrs/react-three-fiber/issues/2856\n            // TODO: fix upstream and remove in v9\n            (__DEV__ ? targetProp.constructor.name === value.constructor.name : targetProp.constructor === value.constructor)) {\n                targetProp.copy(value);\n            } else if (value !== undefined) {\n                var _targetProp;\n                const isColor = (_targetProp = targetProp) == null ? void 0 : _targetProp.isColor;\n                // Allow setting array scalars\n                if (!isColor && targetProp.setScalar) targetProp.setScalar(value);\n                else if (targetProp instanceof three__WEBPACK_IMPORTED_MODULE_5__.Layers && value instanceof three__WEBPACK_IMPORTED_MODULE_5__.Layers) targetProp.mask = value.mask;\n                else targetProp.set(value);\n                // For versions of three which don't support THREE.ColorManagement,\n                // Auto-convert sRGB colors\n                // https://github.com/pmndrs/react-three-fiber/issues/344\n                if (!getColorManagement() && rootState && !rootState.linear && isColor) targetProp.convertSRGBToLinear();\n            }\n        // Else, just overwrite the value\n        } else {\n            var _currentInstance$key;\n            currentInstance[key] = value;\n            // Auto-convert sRGB textures, for now ...\n            // https://github.com/pmndrs/react-three-fiber/issues/344\n            if ((_currentInstance$key = currentInstance[key]) != null && _currentInstance$key.isTexture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n            currentInstance[key].format === three__WEBPACK_IMPORTED_MODULE_5__.RGBAFormat && currentInstance[key].type === three__WEBPACK_IMPORTED_MODULE_5__.UnsignedByteType && rootState) {\n                const texture = currentInstance[key];\n                if (hasColorSpace(texture) && hasColorSpace(rootState.gl)) texture.colorSpace = rootState.gl.outputColorSpace;\n                else texture.encoding = rootState.gl.outputEncoding;\n            }\n        }\n        invalidateInstance(instance);\n    }\n    if (localState && localState.parent && instance.raycast && prevHandlers !== localState.eventCount) {\n        // Get the initial root state's internals\n        const internal = findInitialRoot(instance).getState().internal;\n        // Pre-emptively remove the instance from the interaction manager\n        const index = internal.interaction.indexOf(instance);\n        if (index > -1) internal.interaction.splice(index, 1);\n        // Add the instance to the interaction manager only when it has handlers\n        if (localState.eventCount) internal.interaction.push(instance);\n    }\n    // Call the update lifecycle when it is being updated, but only when it is part of the scene.\n    // Skip updates to the `onUpdate` prop itself\n    const isCircular = changes.length === 1 && changes[0][0] === \"onUpdate\";\n    if (!isCircular && changes.length && (_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.parent) updateInstance(instance);\n    return instance;\n}\nfunction invalidateInstance(instance) {\n    var _instance$__r3f3, _instance$__r3f3$root;\n    const state = (_instance$__r3f3 = instance.__r3f) == null ? void 0 : (_instance$__r3f3$root = _instance$__r3f3.root) == null ? void 0 : _instance$__r3f3$root.getState == null ? void 0 : _instance$__r3f3$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateInstance(instance) {\n    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n}\nfunction updateCamera(camera, size) {\n    // https://github.com/pmndrs/react-three-fiber/issues/92\n    // Do not mess with the camera if it belongs to the user\n    if (!camera.manual) {\n        if (isOrthographicCamera(camera)) {\n            camera.left = size.width / -2;\n            camera.right = size.width / 2;\n            camera.top = size.height / 2;\n            camera.bottom = size.height / -2;\n        } else {\n            camera.aspect = size.width / size.height;\n        }\n        camera.updateProjectionMatrix();\n        // https://github.com/pmndrs/react-three-fiber/issues/178\n        // Update matrix world since the renderer is a frame late\n        camera.updateMatrixWorld();\n    }\n}\nfunction makeId(event) {\n    return (event.eventObject || event.object).uuid + \"/\" + event.index + event.instanceId;\n}\n// https://github.com/facebook/react/tree/main/packages/react-reconciler#getcurrenteventpriority\n// Gives React a clue as to how import the current interaction is\nfunction getEventPriority() {\n    var _globalScope$event;\n    // Get a handle to the current global scope in window and worker contexts if able\n    // https://github.com/pmndrs/react-three-fiber/pull/2493\n    const globalScope = typeof self !== \"undefined\" && self ||  false && 0;\n    if (!globalScope) return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    const name = (_globalScope$event = globalScope.event) == null ? void 0 : _globalScope$event.type;\n    switch(name){\n        case \"click\":\n        case \"contextmenu\":\n        case \"dblclick\":\n        case \"pointercancel\":\n        case \"pointerdown\":\n        case \"pointerup\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DiscreteEventPriority;\n        case \"pointermove\":\n        case \"pointerout\":\n        case \"pointerover\":\n        case \"pointerenter\":\n        case \"pointerleave\":\n        case \"wheel\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ContinuousEventPriority;\n        default:\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    }\n}\n/**\r\n * Release pointer captures.\r\n * This is called by releasePointerCapture in the API, and when an object is removed.\r\n */ function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n    const captureData = captures.get(obj);\n    if (captureData) {\n        captures.delete(obj);\n        // If this was the last capturing object for this pointer\n        if (captures.size === 0) {\n            capturedMap.delete(pointerId);\n            captureData.target.releasePointerCapture(pointerId);\n        }\n    }\n}\nfunction removeInteractivity(store, object) {\n    const { internal } = store.getState();\n    // Removes every trace of an object from the data store\n    internal.interaction = internal.interaction.filter((o)=>o !== object);\n    internal.initialHits = internal.initialHits.filter((o)=>o !== object);\n    internal.hovered.forEach((value, key)=>{\n        if (value.eventObject === object || value.object === object) {\n            // Clear out intersects, they are outdated by now\n            internal.hovered.delete(key);\n        }\n    });\n    internal.capturedMap.forEach((captures, pointerId)=>{\n        releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n    });\n}\nfunction createEvents(store) {\n    /** Calculates delta */ function calculateDistance(event) {\n        const { internal } = store.getState();\n        const dx = event.offsetX - internal.initialClick[0];\n        const dy = event.offsetY - internal.initialClick[1];\n        return Math.round(Math.sqrt(dx * dx + dy * dy));\n    }\n    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */ function filterPointerEvents(objects) {\n        return objects.filter((obj)=>[\n                \"Move\",\n                \"Over\",\n                \"Enter\",\n                \"Out\",\n                \"Leave\"\n            ].some((name)=>{\n                var _r3f;\n                return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers[\"onPointer\" + name];\n            }));\n    }\n    function intersect(event, filter) {\n        const state = store.getState();\n        const duplicates = new Set();\n        const intersections = [];\n        // Allow callers to eliminate event objects\n        const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n        // Reset all raycaster cameras to undefined\n        for(let i = 0; i < eventsObjects.length; i++){\n            const state = getRootState(eventsObjects[i]);\n            if (state) {\n                state.raycaster.camera = undefined;\n            }\n        }\n        if (!state.previousRoot) {\n            // Make sure root-level pointer and ray are set up\n            state.events.compute == null ? void 0 : state.events.compute(event, state);\n        }\n        function handleRaycast(obj) {\n            const state = getRootState(obj);\n            // Skip event handling when noEvents is set, or when the raycasters camera is null\n            if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n            // When the camera is undefined we have to call the event layers update function\n            if (state.raycaster.camera === undefined) {\n                var _state$previousRoot;\n                state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n                // If the camera is still undefined we have to skip this layer entirely\n                if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n            }\n            // Intersect object by object\n            return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n        }\n        // Collect events\n        let hits = eventsObjects// Intersect objects\n        .flatMap(handleRaycast)// Sort by event priority and distance\n        .sort((a, b)=>{\n            const aState = getRootState(a.object);\n            const bState = getRootState(b.object);\n            if (!aState || !bState) return a.distance - b.distance;\n            return bState.events.priority - aState.events.priority || a.distance - b.distance;\n        })// Filter out duplicates\n        .filter((item)=>{\n            const id = makeId(item);\n            if (duplicates.has(id)) return false;\n            duplicates.add(id);\n            return true;\n        });\n        // https://github.com/mrdoob/three.js/issues/16031\n        // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n        if (state.events.filter) hits = state.events.filter(hits, state);\n        // Bubble up the events, find the event source (eventObject)\n        for (const hit of hits){\n            let eventObject = hit.object;\n            // Bubble event up\n            while(eventObject){\n                var _r3f2;\n                if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n                    ...hit,\n                    eventObject\n                });\n                eventObject = eventObject.parent;\n            }\n        }\n        // If the interaction is captured, make all capturing targets part of the intersect.\n        if (\"pointerId\" in event && state.internal.capturedMap.has(event.pointerId)) {\n            for (let captureData of state.internal.capturedMap.get(event.pointerId).values()){\n                if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n            }\n        }\n        return intersections;\n    }\n    /**  Handles intersections by forwarding them to handlers */ function handleIntersects(intersections, event, delta, callback) {\n        const rootState = store.getState();\n        // If anything has been found, forward it to the event listeners\n        if (intersections.length) {\n            const localState = {\n                stopped: false\n            };\n            for (const hit of intersections){\n                const state = getRootState(hit.object) || rootState;\n                const { raycaster, pointer, camera, internal } = state;\n                const unprojectedPoint = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n                const hasPointerCapture = (id)=>{\n                    var _internal$capturedMap, _internal$capturedMap2;\n                    return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n                };\n                const setPointerCapture = (id)=>{\n                    const captureData = {\n                        intersection: hit,\n                        target: event.target\n                    };\n                    if (internal.capturedMap.has(id)) {\n                        // if the pointerId was previously captured, we add the hit to the\n                        // event capturedMap.\n                        internal.capturedMap.get(id).set(hit.eventObject, captureData);\n                    } else {\n                        // if the pointerId was not previously captured, we create a map\n                        // containing the hitObject, and the hit. hitObject is used for\n                        // faster access.\n                        internal.capturedMap.set(id, new Map([\n                            [\n                                hit.eventObject,\n                                captureData\n                            ]\n                        ]));\n                    }\n                    event.target.setPointerCapture(id);\n                };\n                const releasePointerCapture = (id)=>{\n                    const captures = internal.capturedMap.get(id);\n                    if (captures) {\n                        releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n                    }\n                };\n                // Add native event props\n                let extractEventProps = {};\n                // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n                for(let prop in event){\n                    let property = event[prop];\n                    // Only copy over atomics, leave functions alone as these should be\n                    // called as event.nativeEvent.fn()\n                    if (typeof property !== \"function\") extractEventProps[prop] = property;\n                }\n                let raycastEvent = {\n                    ...hit,\n                    ...extractEventProps,\n                    pointer,\n                    intersections,\n                    stopped: localState.stopped,\n                    delta,\n                    unprojectedPoint,\n                    ray: raycaster.ray,\n                    camera: camera,\n                    // Hijack stopPropagation, which just sets a flag\n                    stopPropagation () {\n                        // https://github.com/pmndrs/react-three-fiber/issues/596\n                        // Events are not allowed to stop propagation if the pointer has been captured\n                        const capturesForPointer = \"pointerId\" in event && internal.capturedMap.get(event.pointerId);\n                        // We only authorize stopPropagation...\n                        if (// ...if this pointer hasn't been captured\n                        !capturesForPointer || // ... or if the hit object is capturing the pointer\n                        capturesForPointer.has(hit.eventObject)) {\n                            raycastEvent.stopped = localState.stopped = true;\n                            // Propagation is stopped, remove all other hover records\n                            // An event handler is only allowed to flush other handlers if it is hovered itself\n                            if (internal.hovered.size && Array.from(internal.hovered.values()).find((i)=>i.eventObject === hit.eventObject)) {\n                                // Objects cannot flush out higher up objects that have already caught the event\n                                const higher = intersections.slice(0, intersections.indexOf(hit));\n                                cancelPointer([\n                                    ...higher,\n                                    hit\n                                ]);\n                            }\n                        }\n                    },\n                    // there should be a distinction between target and currentTarget\n                    target: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    currentTarget: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    nativeEvent: event\n                };\n                // Call subscribers\n                callback(raycastEvent);\n                // Event bubbling may be interrupted by stopPropagation\n                if (localState.stopped === true) break;\n            }\n        }\n        return intersections;\n    }\n    function cancelPointer(intersections) {\n        const { internal } = store.getState();\n        for (const hoveredObj of internal.hovered.values()){\n            // When no objects were hit or the the hovered object wasn't found underneath the cursor\n            // we call onPointerOut and delete the object from the hovered-elements map\n            if (!intersections.length || !intersections.find((hit)=>hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n                const eventObject = hoveredObj.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                internal.hovered.delete(makeId(hoveredObj));\n                if (instance != null && instance.eventCount) {\n                    // Clear out intersects, they are outdated by now\n                    const data = {\n                        ...hoveredObj,\n                        intersections\n                    };\n                    handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n                    handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n                }\n            }\n        }\n    }\n    function pointerMissed(event, objects) {\n        for(let i = 0; i < objects.length; i++){\n            const instance = objects[i].__r3f;\n            instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n        }\n    }\n    function handlePointer(name) {\n        // Deal with cancelation\n        switch(name){\n            case \"onPointerLeave\":\n            case \"onPointerCancel\":\n                return ()=>cancelPointer([]);\n            case \"onLostPointerCapture\":\n                return (event)=>{\n                    const { internal } = store.getState();\n                    if (\"pointerId\" in event && internal.capturedMap.has(event.pointerId)) {\n                        // If the object event interface had onLostPointerCapture, we'd call it here on every\n                        // object that's getting removed. We call it on the next frame because onLostPointerCapture\n                        // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n                        // happen in the object it originated from, leaving components in a in-between state.\n                        requestAnimationFrame(()=>{\n                            // Only release if pointer-up didn't do it already\n                            if (internal.capturedMap.has(event.pointerId)) {\n                                internal.capturedMap.delete(event.pointerId);\n                                cancelPointer([]);\n                            }\n                        });\n                    }\n                };\n        }\n        // Any other pointer goes here ...\n        return function handleEvent(event) {\n            const { onPointerMissed, internal } = store.getState();\n            // prepareRay(event)\n            internal.lastEvent.current = event;\n            // Get fresh intersects\n            const isPointerMove = name === \"onPointerMove\";\n            const isClickEvent = name === \"onClick\" || name === \"onContextMenu\" || name === \"onDoubleClick\";\n            const filter = isPointerMove ? filterPointerEvents : undefined;\n            const hits = intersect(event, filter);\n            const delta = isClickEvent ? calculateDistance(event) : 0;\n            // Save initial coordinates on pointer-down\n            if (name === \"onPointerDown\") {\n                internal.initialClick = [\n                    event.offsetX,\n                    event.offsetY\n                ];\n                internal.initialHits = hits.map((hit)=>hit.eventObject);\n            }\n            // If a click yields no results, pass it back to the user as a miss\n            // Missed events have to come first in order to establish user-land side-effect clean up\n            if (isClickEvent && !hits.length) {\n                if (delta <= 2) {\n                    pointerMissed(event, internal.interaction);\n                    if (onPointerMissed) onPointerMissed(event);\n                }\n            }\n            // Take care of unhover\n            if (isPointerMove) cancelPointer(hits);\n            function onIntersect(data) {\n                const eventObject = data.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                // Check presence of handlers\n                if (!(instance != null && instance.eventCount)) return;\n                /*\r\n        MAYBE TODO, DELETE IF NOT: \r\n          Check if the object is captured, captured events should not have intersects running in parallel\r\n          But wouldn't it be better to just replace capturedMap with a single entry?\r\n          Also, are we OK with straight up making picking up multiple objects impossible?\r\n          \r\n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \r\n        if (pointerId !== undefined) {\r\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\r\n          if (capturedMeshSet) {\r\n            const captured = capturedMeshSet.get(eventObject)\r\n            if (captured && captured.localState.stopped) return\r\n          }\r\n        }*/ if (isPointerMove) {\n                    // Move event ...\n                    if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n                        // When enter or out is present take care of hover-state\n                        const id = makeId(data);\n                        const hoveredItem = internal.hovered.get(id);\n                        if (!hoveredItem) {\n                            // If the object wasn't previously hovered, book it and call its handler\n                            internal.hovered.set(id, data);\n                            handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n                            handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n                        } else if (hoveredItem.stopped) {\n                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n                            data.stopPropagation();\n                        }\n                    }\n                    // Call mouse move\n                    handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n                } else {\n                    // All other events ...\n                    const handler = handlers[name];\n                    if (handler) {\n                        // Forward all events back to their respective handlers with the exception of click events,\n                        // which must use the initial target\n                        if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n                            // Missed events have to come first\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                            // Now call the handler\n                            handler(data);\n                        }\n                    } else {\n                        // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n                        if (isClickEvent && internal.initialHits.includes(eventObject)) {\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                        }\n                    }\n                }\n            }\n            handleIntersects(hits, event, delta, onIntersect);\n        };\n    }\n    return {\n        handlePointer\n    };\n}\n// Keys that shouldn't be copied between R3F stores\nconst privateKeys = [\n    \"set\",\n    \"get\",\n    \"setSize\",\n    \"setFrameloop\",\n    \"setDpr\",\n    \"events\",\n    \"invalidate\",\n    \"advance\",\n    \"size\",\n    \"viewport\"\n];\nconst isRenderer = (def)=>!!(def != null && def.render);\nconst context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst createStore = (invalidate, advance)=>{\n    const rootState = (0,zustand__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((set, get)=>{\n        const position = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n        const defaultTarget = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n        const tempTarget = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n        function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n            const { width, height, top, left } = size;\n            const aspect = width / height;\n            if (target.isVector3) tempTarget.copy(target);\n            else tempTarget.set(...target);\n            const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n            if (isOrthographicCamera(camera)) {\n                return {\n                    width: width / camera.zoom,\n                    height: height / camera.zoom,\n                    top,\n                    left,\n                    factor: 1,\n                    distance,\n                    aspect\n                };\n            } else {\n                const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n                const h = 2 * Math.tan(fov / 2) * distance; // visible height\n                const w = h * (width / height);\n                return {\n                    width: w,\n                    height: h,\n                    top,\n                    left,\n                    factor: width / w,\n                    distance,\n                    aspect\n                };\n            }\n        }\n        let performanceTimeout = undefined;\n        const setPerformanceCurrent = (current)=>set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        current\n                    }\n                }));\n        const pointer = new three__WEBPACK_IMPORTED_MODULE_5__.Vector2();\n        const rootState = {\n            set,\n            get,\n            // Mock objects that have to be configured\n            gl: null,\n            camera: null,\n            raycaster: null,\n            events: {\n                priority: 1,\n                enabled: true,\n                connected: false\n            },\n            xr: null,\n            scene: null,\n            invalidate: (frames = 1)=>invalidate(get(), frames),\n            advance: (timestamp, runGlobalEffects)=>advance(timestamp, runGlobalEffects, get()),\n            legacy: false,\n            linear: false,\n            flat: false,\n            controls: null,\n            clock: new three__WEBPACK_IMPORTED_MODULE_5__.Clock(),\n            pointer,\n            mouse: pointer,\n            frameloop: \"always\",\n            onPointerMissed: undefined,\n            performance: {\n                current: 1,\n                min: 0.5,\n                max: 1,\n                debounce: 200,\n                regress: ()=>{\n                    const state = get();\n                    // Clear timeout\n                    if (performanceTimeout) clearTimeout(performanceTimeout);\n                    // Set lower bound performance\n                    if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n                    // Go back to upper bound performance after a while unless something regresses meanwhile\n                    performanceTimeout = setTimeout(()=>setPerformanceCurrent(get().performance.max), state.performance.debounce);\n                }\n            },\n            size: {\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                updateStyle: false\n            },\n            viewport: {\n                initialDpr: 0,\n                dpr: 0,\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                aspect: 0,\n                distance: 0,\n                factor: 0,\n                getCurrentViewport\n            },\n            setEvents: (events)=>set((state)=>({\n                        ...state,\n                        events: {\n                            ...state.events,\n                            ...events\n                        }\n                    })),\n            setSize: (width, height, updateStyle, top, left)=>{\n                const camera = get().camera;\n                const size = {\n                    width,\n                    height,\n                    top: top || 0,\n                    left: left || 0,\n                    updateStyle\n                };\n                set((state)=>({\n                        size,\n                        viewport: {\n                            ...state.viewport,\n                            ...getCurrentViewport(camera, defaultTarget, size)\n                        }\n                    }));\n            },\n            setDpr: (dpr)=>set((state)=>{\n                    const resolved = calculateDpr(dpr);\n                    return {\n                        viewport: {\n                            ...state.viewport,\n                            dpr: resolved,\n                            initialDpr: state.viewport.initialDpr || resolved\n                        }\n                    };\n                }),\n            setFrameloop: (frameloop = \"always\")=>{\n                const clock = get().clock;\n                // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n                clock.stop();\n                clock.elapsedTime = 0;\n                if (frameloop !== \"never\") {\n                    clock.start();\n                    clock.elapsedTime = 0;\n                }\n                set(()=>({\n                        frameloop\n                    }));\n            },\n            previousRoot: undefined,\n            internal: {\n                active: false,\n                priority: 0,\n                frames: 0,\n                lastEvent: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n                interaction: [],\n                hovered: new Map(),\n                subscribers: [],\n                initialClick: [\n                    0,\n                    0\n                ],\n                initialHits: [],\n                capturedMap: new Map(),\n                subscribe: (ref, priority, store)=>{\n                    const internal = get().internal;\n                    // If this subscription was given a priority, it takes rendering into its own hands\n                    // For that reason we switch off automatic rendering and increase the manual flag\n                    // As long as this flag is positive there can be no internal rendering at all\n                    // because there could be multiple render subscriptions\n                    internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n                    internal.subscribers.push({\n                        ref,\n                        priority,\n                        store\n                    });\n                    // Register subscriber and sort layers from lowest to highest, meaning,\n                    // highest priority renders last (on top of the other frames)\n                    internal.subscribers = internal.subscribers.sort((a, b)=>a.priority - b.priority);\n                    return ()=>{\n                        const internal = get().internal;\n                        if (internal != null && internal.subscribers) {\n                            // Decrease manual flag if this subscription had a priority\n                            internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n                            // Remove subscriber from list\n                            internal.subscribers = internal.subscribers.filter((s)=>s.ref !== ref);\n                        }\n                    };\n                }\n            }\n        };\n        return rootState;\n    });\n    const state = rootState.getState();\n    let oldSize = state.size;\n    let oldDpr = state.viewport.dpr;\n    let oldCamera = state.camera;\n    rootState.subscribe(()=>{\n        const { camera, size, viewport, gl, set } = rootState.getState();\n        // Resize camera and renderer on changes to size and pixelratio\n        if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n            var _size$updateStyle;\n            oldSize = size;\n            oldDpr = viewport.dpr;\n            // Update camera & renderer\n            updateCamera(camera, size);\n            gl.setPixelRatio(viewport.dpr);\n            const updateStyle = (_size$updateStyle = size.updateStyle) != null ? _size$updateStyle : typeof HTMLCanvasElement !== \"undefined\" && gl.domElement instanceof HTMLCanvasElement;\n            gl.setSize(size.width, size.height, updateStyle);\n        }\n        // Update viewport once the camera changes\n        if (camera !== oldCamera) {\n            oldCamera = camera;\n            // Update viewport\n            set((state)=>({\n                    viewport: {\n                        ...state.viewport,\n                        ...state.viewport.getCurrentViewport(camera)\n                    }\n                }));\n        }\n    });\n    // Invalidate on any change\n    rootState.subscribe((state)=>invalidate(state));\n    // Return root state\n    return rootState;\n};\nfunction createSubs(callback, subs) {\n    const sub = {\n        callback\n    };\n    subs.add(sub);\n    return ()=>void subs.delete(sub);\n}\nlet i;\nlet globalEffects = new Set();\nlet globalAfterEffects = new Set();\nlet globalTailEffects = new Set();\n/**\r\n * Adds a global render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\r\n */ const addEffect = (callback)=>createSubs(callback, globalEffects);\n/**\r\n * Adds a global after-render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\r\n */ const addAfterEffect = (callback)=>createSubs(callback, globalAfterEffects);\n/**\r\n * Adds a global callback which is called when rendering stops.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\r\n */ const addTail = (callback)=>createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n    if (!effects.size) return;\n    for (const { callback } of effects.values()){\n        callback(timestamp);\n    }\n}\nfunction flushGlobalEffects(type, timestamp) {\n    switch(type){\n        case \"before\":\n            return run(globalEffects, timestamp);\n        case \"after\":\n            return run(globalAfterEffects, timestamp);\n        case \"tail\":\n            return run(globalTailEffects, timestamp);\n    }\n}\nlet subscribers;\nlet subscription;\nfunction render$1(timestamp, state, frame) {\n    // Run local effects\n    let delta = state.clock.getDelta();\n    // In frameloop='never' mode, clock times are updated using the provided timestamp\n    if (state.frameloop === \"never\" && typeof timestamp === \"number\") {\n        delta = timestamp - state.clock.elapsedTime;\n        state.clock.oldTime = state.clock.elapsedTime;\n        state.clock.elapsedTime = timestamp;\n    }\n    // Call subscribers (useFrame)\n    subscribers = state.internal.subscribers;\n    for(i = 0; i < subscribers.length; i++){\n        subscription = subscribers[i];\n        subscription.ref.current(subscription.store.getState(), delta, frame);\n    }\n    // Render content\n    if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n    // Decrease frame count\n    state.internal.frames = Math.max(0, state.internal.frames - 1);\n    return state.frameloop === \"always\" ? 1 : state.internal.frames;\n}\nfunction createLoop(roots) {\n    let running = false;\n    let useFrameInProgress = false;\n    let repeat;\n    let frame;\n    let state;\n    function loop(timestamp) {\n        frame = requestAnimationFrame(loop);\n        running = true;\n        repeat = 0;\n        // Run effects\n        flushGlobalEffects(\"before\", timestamp);\n        // Render all roots\n        useFrameInProgress = true;\n        for (const root of roots.values()){\n            var _state$gl$xr;\n            state = root.store.getState();\n            // If the frameloop is invalidated, do not run another frame\n            if (state.internal.active && (state.frameloop === \"always\" || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n                repeat += render$1(timestamp, state);\n            }\n        }\n        useFrameInProgress = false;\n        // Run after-effects\n        flushGlobalEffects(\"after\", timestamp);\n        // Stop the loop if nothing invalidates it\n        if (repeat === 0) {\n            // Tail call effects, they are called when rendering stops\n            flushGlobalEffects(\"tail\", timestamp);\n            // Flag end of operation\n            running = false;\n            return cancelAnimationFrame(frame);\n        }\n    }\n    function invalidate(state, frames = 1) {\n        var _state$gl$xr2;\n        if (!state) return roots.forEach((root)=>invalidate(root.store.getState(), frames));\n        if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === \"never\") return;\n        if (frames > 1) {\n            // legacy support for people using frames parameters\n            // Increase frames, do not go higher than 60\n            state.internal.frames = Math.min(60, state.internal.frames + frames);\n        } else {\n            if (useFrameInProgress) {\n                //called from within a useFrame, it means the user wants an additional frame\n                state.internal.frames = 2;\n            } else {\n                //the user need a new frame, no need to increment further than 1\n                state.internal.frames = 1;\n            }\n        }\n        // If the render-loop isn't active, start it\n        if (!running) {\n            running = true;\n            requestAnimationFrame(loop);\n        }\n    }\n    function advance(timestamp, runGlobalEffects = true, state, frame) {\n        if (runGlobalEffects) flushGlobalEffects(\"before\", timestamp);\n        if (!state) for (const root of roots.values())render$1(timestamp, root.store.getState());\n        else render$1(timestamp, state, frame);\n        if (runGlobalEffects) flushGlobalEffects(\"after\", timestamp);\n    }\n    return {\n        loop,\n        invalidate,\n        advance\n    };\n}\n/**\r\n * Exposes an object's {@link LocalState}.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\r\n *\r\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\r\n */ function useInstanceHandle(ref) {\n    const instance = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    useIsomorphicLayoutEffect(()=>void (instance.current = ref.current.__r3f), [\n        ref\n    ]);\n    return instance;\n}\nfunction useStore() {\n    const store = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (!store) throw new Error(\"R3F: Hooks can only be used within the Canvas component!\");\n    return store;\n}\n/**\r\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\r\n */ function useThree(selector = (state)=>state, equalityFn) {\n    return useStore()(selector, equalityFn);\n}\n/**\r\n * Executes a callback before render in a shared frame loop.\r\n * Can order effects with render priority or manually render with a positive priority.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\r\n */ function useFrame(callback, renderPriority = 0) {\n    const store = useStore();\n    const subscribe = store.getState().internal.subscribe;\n    // Memoize ref\n    const ref = useMutableCallback(callback);\n    // Subscribe on mount, unsubscribe on unmount\n    useIsomorphicLayoutEffect(()=>subscribe(ref, renderPriority, store), [\n        renderPriority,\n        subscribe,\n        store\n    ]);\n    return null;\n}\n/**\r\n * Returns a node graph of an object with named nodes & materials.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\r\n */ function useGraph(object) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>buildGraph(object), [\n        object\n    ]);\n}\nconst memoizedLoaders = new WeakMap();\nfunction loadingFn(extensions, onProgress) {\n    return function(Proto, ...input) {\n        // Construct new loader and run extensions\n        let loader = memoizedLoaders.get(Proto);\n        if (!loader) {\n            loader = new Proto();\n            memoizedLoaders.set(Proto, loader);\n        }\n        if (extensions) extensions(loader);\n        // Go through the urls and load them\n        return Promise.all(input.map((input)=>new Promise((res, reject)=>loader.load(input, (data)=>{\n                    if (data.scene) Object.assign(data, buildGraph(data.scene));\n                    res(data);\n                }, onProgress, (error)=>reject(new Error(`Could not load ${input}: ${error == null ? void 0 : error.message}`))))));\n    };\n}\n/**\r\n * Synchronously loads and caches assets with a three loader.\r\n *\r\n * Note: this hook's caller must be wrapped with `React.Suspense`\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\r\n */ function useLoader(Proto, input, extensions, onProgress) {\n    // Use suspense to load async assets\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    const results = (0,suspend_react__WEBPACK_IMPORTED_MODULE_7__.suspend)(loadingFn(extensions, onProgress), [\n        Proto,\n        ...keys\n    ], {\n        equal: is.equ\n    });\n    // Return the object/s\n    return Array.isArray(input) ? results : results[0];\n}\n/**\r\n * Preloads an asset into cache as a side-effect.\r\n */ useLoader.preload = function(Proto, input, extensions) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_7__.preload)(loadingFn(extensions), [\n        Proto,\n        ...keys\n    ]);\n};\n/**\r\n * Removes a loaded asset from cache.\r\n */ useLoader.clear = function(Proto, input) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_7__.clear)([\n        Proto,\n        ...keys\n    ]);\n};\nconst roots = new Map();\nconst { invalidate, advance } = createLoop(roots);\nconst { reconciler, applyProps } = createRenderer(roots, getEventPriority);\nconst shallowLoose = {\n    objects: \"shallow\",\n    strict: false\n};\nconst createRendererInstance = (gl, canvas)=>{\n    const customRenderer = typeof gl === \"function\" ? gl(canvas) : gl;\n    if (isRenderer(customRenderer)) return customRenderer;\n    else return new three__WEBPACK_IMPORTED_MODULE_8__.WebGLRenderer({\n        powerPreference: \"high-performance\",\n        canvas: canvas,\n        antialias: true,\n        alpha: true,\n        ...gl\n    });\n};\nfunction computeInitialSize(canvas, defaultSize) {\n    const defaultStyle = typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement;\n    if (defaultSize) {\n        const { width, height, top, left, updateStyle = defaultStyle } = defaultSize;\n        return {\n            width,\n            height,\n            top,\n            left,\n            updateStyle\n        };\n    } else if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n        const { width, height, top, left } = canvas.parentElement.getBoundingClientRect();\n        return {\n            width,\n            height,\n            top,\n            left,\n            updateStyle: defaultStyle\n        };\n    } else if (typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n        return {\n            width: canvas.width,\n            height: canvas.height,\n            top: 0,\n            left: 0,\n            updateStyle: defaultStyle\n        };\n    }\n    return {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0\n    };\n}\nfunction createRoot(canvas) {\n    // Check against mistaken use of createRoot\n    const prevRoot = roots.get(canvas);\n    const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n    const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n    if (prevRoot) console.warn(\"R3F.createRoot should only be called once!\");\n    // Report when an error was detected in a previous render\n    // https://github.com/pmndrs/react-three-fiber/pull/2261\n    const logRecoverableError = typeof reportError === \"function\" ? // In modern browsers, reportError will dispatch an error event,\n    // emulating an uncaught JavaScript error.\n    reportError : // In older browsers and test environments, fallback to console.error.\n    console.error;\n    // Create store\n    const store = prevStore || createStore(invalidate, advance);\n    // Create renderer\n    const fiber = prevFiber || reconciler.createContainer(store, react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ConcurrentRoot, null, false, null, \"\", logRecoverableError, null);\n    // Map it\n    if (!prevRoot) roots.set(canvas, {\n        fiber,\n        store\n    });\n    // Locals\n    let onCreated;\n    let configured = false;\n    let lastCamera;\n    return {\n        configure (props = {}) {\n            let { gl: glConfig, size: propsSize, scene: sceneOptions, events, onCreated: onCreatedCallback, shadows = false, linear = false, flat = false, legacy = false, orthographic = false, frameloop = \"always\", dpr = [\n                1,\n                2\n            ], performance: performance1, raycaster: raycastOptions, camera: cameraOptions, onPointerMissed } = props;\n            let state = store.getState();\n            // Set up renderer (one time only!)\n            let gl = state.gl;\n            if (!state.gl) state.set({\n                gl: gl = createRendererInstance(glConfig, canvas)\n            });\n            // Set up raycaster (one time only!)\n            let raycaster = state.raycaster;\n            if (!raycaster) state.set({\n                raycaster: raycaster = new three__WEBPACK_IMPORTED_MODULE_5__.Raycaster()\n            });\n            // Set raycaster options\n            const { params, ...options } = raycastOptions || {};\n            if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n                ...options\n            });\n            if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n                params: {\n                    ...raycaster.params,\n                    ...params\n                }\n            });\n            // Create default camera, don't overwrite any user-set state\n            if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n                lastCamera = cameraOptions;\n                const isCamera = cameraOptions instanceof three__WEBPACK_IMPORTED_MODULE_5__.Camera;\n                const camera = isCamera ? cameraOptions : orthographic ? new three__WEBPACK_IMPORTED_MODULE_5__.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new three__WEBPACK_IMPORTED_MODULE_5__.PerspectiveCamera(75, 0, 0.1, 1000);\n                if (!isCamera) {\n                    camera.position.z = 5;\n                    if (cameraOptions) {\n                        applyProps(camera, cameraOptions);\n                        // Preserve user-defined frustum if possible\n                        // https://github.com/pmndrs/react-three-fiber/issues/3160\n                        if (\"aspect\" in cameraOptions || \"left\" in cameraOptions || \"right\" in cameraOptions || \"bottom\" in cameraOptions || \"top\" in cameraOptions) {\n                            camera.manual = true;\n                            camera.updateProjectionMatrix();\n                        }\n                    }\n                    // Always look at center by default\n                    if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n                }\n                state.set({\n                    camera\n                });\n                // Configure raycaster\n                // https://github.com/pmndrs/react-xr/issues/300\n                raycaster.camera = camera;\n            }\n            // Set up scene (one time only!)\n            if (!state.scene) {\n                let scene;\n                if (sceneOptions != null && sceneOptions.isScene) {\n                    scene = sceneOptions;\n                } else {\n                    scene = new three__WEBPACK_IMPORTED_MODULE_5__.Scene();\n                    if (sceneOptions) applyProps(scene, sceneOptions);\n                }\n                state.set({\n                    scene: prepare(scene)\n                });\n            }\n            // Set up XR (one time only!)\n            if (!state.xr) {\n                var _gl$xr;\n                // Handle frame behavior in WebXR\n                const handleXRFrame = (timestamp, frame)=>{\n                    const state = store.getState();\n                    if (state.frameloop === \"never\") return;\n                    advance(timestamp, true, state, frame);\n                };\n                // Toggle render switching on session\n                const handleSessionChange = ()=>{\n                    const state = store.getState();\n                    state.gl.xr.enabled = state.gl.xr.isPresenting;\n                    state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n                    if (!state.gl.xr.isPresenting) invalidate(state);\n                };\n                // WebXR session manager\n                const xr = {\n                    connect () {\n                        const gl = store.getState().gl;\n                        gl.xr.addEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.addEventListener(\"sessionend\", handleSessionChange);\n                    },\n                    disconnect () {\n                        const gl = store.getState().gl;\n                        gl.xr.removeEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.removeEventListener(\"sessionend\", handleSessionChange);\n                    }\n                };\n                // Subscribe to WebXR session events\n                if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === \"function\") xr.connect();\n                state.set({\n                    xr\n                });\n            }\n            // Set shadowmap\n            if (gl.shadowMap) {\n                const oldEnabled = gl.shadowMap.enabled;\n                const oldType = gl.shadowMap.type;\n                gl.shadowMap.enabled = !!shadows;\n                if (is.boo(shadows)) {\n                    gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_5__.PCFSoftShadowMap;\n                } else if (is.str(shadows)) {\n                    var _types$shadows;\n                    const types = {\n                        basic: three__WEBPACK_IMPORTED_MODULE_5__.BasicShadowMap,\n                        percentage: three__WEBPACK_IMPORTED_MODULE_5__.PCFShadowMap,\n                        soft: three__WEBPACK_IMPORTED_MODULE_5__.PCFSoftShadowMap,\n                        variance: three__WEBPACK_IMPORTED_MODULE_5__.VSMShadowMap\n                    };\n                    gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : three__WEBPACK_IMPORTED_MODULE_5__.PCFSoftShadowMap;\n                } else if (is.obj(shadows)) {\n                    Object.assign(gl.shadowMap, shadows);\n                }\n                if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n            }\n            // Safely set color management if available.\n            // Avoid accessing THREE.ColorManagement to play nice with older versions\n            const ColorManagement = getColorManagement();\n            if (ColorManagement) {\n                if (\"enabled\" in ColorManagement) ColorManagement.enabled = !legacy;\n                else if (\"legacyMode\" in ColorManagement) ColorManagement.legacyMode = legacy;\n            }\n            if (!configured) {\n                // Set color space and tonemapping preferences, once\n                const LinearEncoding = 3000;\n                const sRGBEncoding = 3001;\n                applyProps(gl, {\n                    outputEncoding: linear ? LinearEncoding : sRGBEncoding,\n                    toneMapping: flat ? three__WEBPACK_IMPORTED_MODULE_5__.NoToneMapping : three__WEBPACK_IMPORTED_MODULE_5__.ACESFilmicToneMapping\n                });\n            }\n            // Update color management state\n            if (state.legacy !== legacy) state.set(()=>({\n                    legacy\n                }));\n            if (state.linear !== linear) state.set(()=>({\n                    linear\n                }));\n            if (state.flat !== flat) state.set(()=>({\n                    flat\n                }));\n            // Set gl props\n            if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n            // Store events internally\n            if (events && !state.events.handlers) state.set({\n                events: events(store)\n            });\n            // Check size, allow it to take on container bounds initially\n            const size = computeInitialSize(canvas, propsSize);\n            if (!is.equ(size, state.size, shallowLoose)) {\n                state.setSize(size.width, size.height, size.updateStyle, size.top, size.left);\n            }\n            // Check pixelratio\n            if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n            // Check frameloop\n            if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n            // Check pointer missed\n            if (!state.onPointerMissed) state.set({\n                onPointerMissed\n            });\n            // Check performance\n            if (performance1 && !is.equ(performance1, state.performance, shallowLoose)) state.set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        ...performance1\n                    }\n                }));\n            // Set locals\n            onCreated = onCreatedCallback;\n            configured = true;\n            return this;\n        },\n        render (children) {\n            // The root has to be configured before it can be rendered\n            if (!configured) this.configure();\n            reconciler.updateContainer(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Provider, {\n                store: store,\n                children: children,\n                onCreated: onCreated,\n                rootElement: canvas\n            }), fiber, null, ()=>undefined);\n            return store;\n        },\n        unmount () {\n            unmountComponentAtNode(canvas);\n        }\n    };\n}\nfunction render(children, canvas, config) {\n    console.warn(\"R3F.render is no longer supported in React 18. Use createRoot instead!\");\n    const root = createRoot(canvas);\n    root.configure(config);\n    return root.render(children);\n}\nfunction Provider({ store, children, onCreated, rootElement }) {\n    useIsomorphicLayoutEffect(()=>{\n        const state = store.getState();\n        // Flag the canvas active, rendering will now begin\n        state.set((state)=>({\n                internal: {\n                    ...state.internal,\n                    active: true\n                }\n            }));\n        // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n        if (onCreated) onCreated(state);\n        // Connect events to the targets parent, this is done to ensure events are registered on\n        // a shared target, and not on the canvas itself\n        if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(context.Provider, {\n        value: store,\n        children: children\n    });\n}\nfunction unmountComponentAtNode(canvas, callback) {\n    const root = roots.get(canvas);\n    const fiber = root == null ? void 0 : root.fiber;\n    if (fiber) {\n        const state = root == null ? void 0 : root.store.getState();\n        if (state) state.internal.active = false;\n        reconciler.updateContainer(null, fiber, null, ()=>{\n            if (state) {\n                setTimeout(()=>{\n                    try {\n                        var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n                        state.events.disconnect == null ? void 0 : state.events.disconnect();\n                        (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n                        (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n                        if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n                        dispose(state);\n                        roots.delete(canvas);\n                        if (callback) callback(canvas);\n                    } catch (e) {\n                    /* ... */ }\n                }, 500);\n            }\n        });\n    }\n}\nfunction createPortal(children, container, state) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Portal, {\n        children: children,\n        container: container,\n        state: state\n    }, container.uuid);\n}\nfunction Portal({ state = {}, children, container }) {\n    /** This has to be a component because it would not be able to call useThree/useStore otherwise since\r\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\r\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\r\n   *  <Canvas>\r\n   *    {createPortal(...)} */ const { events, size, ...rest } = state;\n    const previousRoot = useStore();\n    const [raycaster] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_5__.Raycaster());\n    const [pointer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_5__.Vector2());\n    const inject = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootState, injectState)=>{\n        const intersect = {\n            ...rootState\n        }; // all prev state props\n        // Only the fields of \"rootState\" that do not differ from injectState\n        // Some props should be off-limits\n        // Otherwise filter out the props that are different and let the inject layer take precedence\n        Object.keys(rootState).forEach((key)=>{\n            if (// Some props should be off-limits\n            privateKeys.includes(key) || // Otherwise filter out the props that are different and let the inject layer take precedence\n            // Unless the inject layer props is undefined, then we keep the root layer\n            rootState[key] !== injectState[key] && injectState[key]) {\n                delete intersect[key];\n            }\n        });\n        let viewport = undefined;\n        if (injectState && size) {\n            const camera = injectState.camera;\n            // Calculate the override viewport, if present\n            viewport = rootState.viewport.getCurrentViewport(camera, new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(), size);\n            // Update the portal camera, if it differs from the previous layer\n            if (camera !== rootState.camera) updateCamera(camera, size);\n        }\n        return {\n            // The intersect consists of the previous root state\n            ...intersect,\n            // Portals have their own scene, which forms the root, a raycaster and a pointer\n            scene: container,\n            raycaster,\n            pointer,\n            mouse: pointer,\n            // Their previous root is the layer before it\n            previousRoot,\n            // Events, size and viewport can be overridden by the inject layer\n            events: {\n                ...rootState.events,\n                ...injectState == null ? void 0 : injectState.events,\n                ...events\n            },\n            size: {\n                ...rootState.size,\n                ...size\n            },\n            viewport: {\n                ...rootState.viewport,\n                ...viewport\n            },\n            ...rest\n        };\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        state\n    ]);\n    const [usePortalStore] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>{\n        // Create a mirrored store, based on the previous root with a few overrides ...\n        const previousState = previousRoot.getState();\n        const store = (0,zustand__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((set, get)=>({\n                ...previousState,\n                scene: container,\n                raycaster,\n                pointer,\n                mouse: pointer,\n                previousRoot,\n                events: {\n                    ...previousState.events,\n                    ...events\n                },\n                size: {\n                    ...previousState.size,\n                    ...size\n                },\n                ...rest,\n                // Set and get refer to this root-state\n                set,\n                get,\n                // Layers are allowed to override events\n                setEvents: (events)=>set((state)=>({\n                            ...state,\n                            events: {\n                                ...state.events,\n                                ...events\n                            }\n                        }))\n            }));\n        return store;\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n        const unsub = previousRoot.subscribe((prev)=>usePortalStore.setState((state)=>inject(prev, state)));\n        return ()=>{\n            unsub();\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        inject\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        usePortalStore.setState((injectState)=>inject(previousRoot.getState(), injectState));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        inject\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            usePortalStore.destroy();\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n        children: reconciler.createPortal(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(context.Provider, {\n            value: usePortalStore,\n            children: children\n        }), usePortalStore, null)\n    });\n}\n/**\r\n * Force React to flush any updates inside the provided callback synchronously and immediately.\r\n * All the same caveats documented for react-dom's `flushSync` apply here (see https://react.dev/reference/react-dom/flushSync).\r\n * Nevertheless, sometimes one needs to render synchronously, for example to keep DOM and 3D changes in lock-step without\r\n * having to revert to a non-React solution.\r\n */ function flushSync(fn) {\n    // `flushSync` implementation only takes one argument. I don't know what's up with the type declaration for it.\n    return reconciler.flushSync(fn, undefined);\n}\nreconciler.injectIntoDevTools({\n    bundleType:  false ? 0 : 1,\n    rendererPackageName: \"@react-three/fiber\",\n    version: react__WEBPACK_IMPORTED_MODULE_0__.version\n});\nconst act = react__WEBPACK_IMPORTED_MODULE_0__.unstable_act;\nconst DOM_EVENTS = {\n    onClick: [\n        \"click\",\n        false\n    ],\n    onContextMenu: [\n        \"contextmenu\",\n        false\n    ],\n    onDoubleClick: [\n        \"dblclick\",\n        false\n    ],\n    onWheel: [\n        \"wheel\",\n        true\n    ],\n    onPointerDown: [\n        \"pointerdown\",\n        true\n    ],\n    onPointerUp: [\n        \"pointerup\",\n        true\n    ],\n    onPointerLeave: [\n        \"pointerleave\",\n        true\n    ],\n    onPointerMove: [\n        \"pointermove\",\n        true\n    ],\n    onPointerCancel: [\n        \"pointercancel\",\n        true\n    ],\n    onLostPointerCapture: [\n        \"lostpointercapture\",\n        true\n    ]\n};\n/** Default R3F event manager for web */ function createPointerEvents(store) {\n    const { handlePointer } = createEvents(store);\n    return {\n        priority: 1,\n        enabled: true,\n        compute (event, state, previous) {\n            // https://github.com/pmndrs/react-three-fiber/pull/782\n            // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n            state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n            state.raycaster.setFromCamera(state.pointer, state.camera);\n        },\n        connected: undefined,\n        handlers: Object.keys(DOM_EVENTS).reduce((acc, key)=>({\n                ...acc,\n                [key]: handlePointer(key)\n            }), {}),\n        update: ()=>{\n            var _internal$lastEvent;\n            const { events, internal } = store.getState();\n            if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n        },\n        connect: (target)=>{\n            var _events$handlers;\n            const { set, events } = store.getState();\n            events.disconnect == null ? void 0 : events.disconnect();\n            set((state)=>({\n                    events: {\n                        ...state.events,\n                        connected: target\n                    }\n                }));\n            Object.entries((_events$handlers = events.handlers) != null ? _events$handlers : []).forEach(([name, event])=>{\n                const [eventName, passive] = DOM_EVENTS[name];\n                target.addEventListener(eventName, event, {\n                    passive\n                });\n            });\n        },\n        disconnect: ()=>{\n            const { set, events } = store.getState();\n            if (events.connected) {\n                var _events$handlers2;\n                Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event])=>{\n                    if (events && events.connected instanceof HTMLElement) {\n                        const [eventName] = DOM_EVENTS[name];\n                        events.connected.removeEventListener(eventName, event);\n                    }\n                });\n                set((state)=>({\n                        events: {\n                            ...state.events,\n                            connected: undefined\n                        }\n                    }));\n            }\n        }\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvZXZlbnRzLTc3NjcxNmJkLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0E7QUFDbUc7QUFDckc7QUFDMkI7QUFDTjtBQUNSO0FBQ21DO0FBRTdFLElBQUllLGFBQWEsV0FBVyxHQUFFQyxPQUFPQyxNQUFNLENBQUM7SUFDMUNDLFdBQVc7QUFDYjtBQUVBLE1BQU1DLFlBQVksQ0FBQztBQUNuQixNQUFNQyxTQUFTQyxDQUFBQSxVQUFXLEtBQUtMLE9BQU9NLE1BQU0sQ0FBQ0gsV0FBV0U7QUFDeEQsU0FBU0UsZUFBZUMsTUFBTSxFQUFFQyxpQkFBaUI7SUFDL0MsU0FBU0MsZUFBZUMsSUFBSSxFQUFFLEVBQzVCQyxPQUFPLEVBQUUsRUFDVEMsTUFBTSxFQUNOLEdBQUdDLE9BQ0osRUFBRUMsSUFBSTtRQUNMLElBQUlDLE9BQU8sQ0FBQyxFQUFFTCxJQUFJLENBQUMsRUFBRSxDQUFDTSxXQUFXLEdBQUcsRUFBRU4sS0FBS08sS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUNyRCxJQUFJQztRQUNKLElBQUlSLFNBQVMsYUFBYTtZQUN4QixJQUFJRyxNQUFNTSxNQUFNLEtBQUtDLFdBQVcsTUFBTSxJQUFJQyxNQUFNO1lBQ2hELE1BQU1GLFNBQVNOLE1BQU1NLE1BQU07WUFDM0JELFdBQVdJLFFBQVFILFFBQVE7Z0JBQ3pCVDtnQkFDQUk7Z0JBQ0FGO2dCQUNBVyxXQUFXO1lBQ2I7UUFDRixPQUFPO1lBQ0wsTUFBTUMsU0FBU3RCLFNBQVMsQ0FBQ2EsS0FBSztZQUM5QixJQUFJLENBQUNTLFFBQVE7Z0JBQ1gsTUFBTSxJQUFJSCxNQUFNLENBQUMsS0FBSyxFQUFFTixLQUFLLDRKQUE0SixDQUFDO1lBQzVMO1lBRUEsb0RBQW9EO1lBQ3BELElBQUksQ0FBQ1UsTUFBTUMsT0FBTyxDQUFDZixPQUFPLE1B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LElBQUltTjtnQkFDSmpvQixPQUFPOE8sT0FBTyxDQUFDLENBQUNtWixvQkFBb0J4UyxPQUFPek8sUUFBUSxLQUFLLE9BQU9paEIsb0JBQW9CLEVBQUUsRUFBRXRrQixPQUFPLENBQUMsQ0FBQyxDQUFDM0MsTUFBTXNTLE1BQU07b0JBQzNHLElBQUltQyxVQUFVQSxPQUFPcUYsU0FBUyxZQUFZb04sYUFBYTt3QkFDckQsTUFBTSxDQUFDSCxVQUFVLEdBQUdkLFVBQVUsQ0FBQ2ptQixLQUFLO3dCQUNwQ3lVLE9BQU9xRixTQUFTLENBQUMrSSxtQkFBbUIsQ0FBQ2tFLFdBQVd6VTtvQkFDbEQ7Z0JBQ0Y7Z0JBQ0EzSCxJQUFJSyxDQUFBQSxRQUFVO3dCQUNaeUosUUFBUTs0QkFDTixHQUFHekosTUFBTXlKLE1BQU07NEJBQ2ZxRixXQUFXelo7d0JBQ2I7b0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUUrbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvZXZlbnRzLTc3NjcxNmJkLmVzbS5qcz8wOGQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERlZmF1bHRFdmVudFByaW9yaXR5LCBDb250aW51b3VzRXZlbnRQcmlvcml0eSwgRGlzY3JldGVFdmVudFByaW9yaXR5LCBDb25jdXJyZW50Um9vdCB9IGZyb20gJ3JlYWN0LXJlY29uY2lsZXIvY29uc3RhbnRzJztcbmltcG9ydCBjcmVhdGUgZnJvbSAnenVzdGFuZCc7XG5pbXBvcnQgeyBzdXNwZW5kLCBwcmVsb2FkLCBjbGVhciB9IGZyb20gJ3N1c3BlbmQtcmVhY3QnO1xuaW1wb3J0IHsganN4LCBGcmFnbWVudCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCBSZWNvbmNpbGVyIGZyb20gJ3JlYWN0LXJlY29uY2lsZXInO1xuaW1wb3J0IHsgdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaywgdW5zdGFibGVfSWRsZVByaW9yaXR5IH0gZnJvbSAnc2NoZWR1bGVyJztcblxudmFyIHRocmVlVHlwZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbmNvbnN0IGNhdGFsb2d1ZSA9IHt9O1xuY29uc3QgZXh0ZW5kID0gb2JqZWN0cyA9PiB2b2lkIE9iamVjdC5hc3NpZ24oY2F0YWxvZ3VlLCBvYmplY3RzKTtcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyKF9yb290cywgX2dldEV2ZW50UHJpb3JpdHkpIHtcbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UodHlwZSwge1xuICAgIGFyZ3MgPSBbXSxcbiAgICBhdHRhY2gsXG4gICAgLi4ucHJvcHNcbiAgfSwgcm9vdCkge1xuICAgIGxldCBuYW1lID0gYCR7dHlwZVswXS50b1VwcGVyQ2FzZSgpfSR7dHlwZS5zbGljZSgxKX1gO1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBpZiAodHlwZSA9PT0gJ3ByaW1pdGl2ZScpIHtcbiAgICAgIGlmIChwcm9wcy5vYmplY3QgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiUjNGOiBQcmltaXRpdmVzIHdpdGhvdXQgJ29iamVjdCcgYXJlIGludmFsaWQhXCIpO1xuICAgICAgY29uc3Qgb2JqZWN0ID0gcHJvcHMub2JqZWN0O1xuICAgICAgaW5zdGFuY2UgPSBwcmVwYXJlKG9iamVjdCwge1xuICAgICAgICB0eXBlLFxuICAgICAgICByb290LFxuICAgICAgICBhdHRhY2gsXG4gICAgICAgIHByaW1pdGl2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGNhdGFsb2d1ZVtuYW1lXTtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUjNGOiAke25hbWV9IGlzIG5vdCBwYXJ0IG9mIHRoZSBUSFJFRSBuYW1lc3BhY2UhIERpZCB5b3UgZm9yZ2V0IHRvIGV4dGVuZD8gU2VlOiBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvb2JqZWN0cyN1c2luZy0zcmQtcGFydHktb2JqZWN0cy1kZWNsYXJhdGl2ZWx5YCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRocm93IGlmIGFuIG9iamVjdCBvciBsaXRlcmFsIHdhcyBwYXNzZWQgZm9yIGFyZ3NcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmdzKSkgdGhyb3cgbmV3IEVycm9yKCdSM0Y6IFRoZSBhcmdzIHByb3AgbXVzdCBiZSBhbiBhcnJheSEnKTtcblxuICAgICAgLy8gSW5zdGFuY2lhdGUgbmV3IG9iamVjdCwgbGluayBpdCB0byB0aGUgcm9vdFxuICAgICAgLy8gQXBwZW5kIG1lbW9pemVkIHByb3BzIHdpdGggYXJncyBzbyBpdCdzIG5vdCBmb3Jnb3R0ZW5cbiAgICAgIGluc3RhbmNlID0gcHJlcGFyZShuZXcgdGFyZ2V0KC4uLmFyZ3MpLCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJvb3QsXG4gICAgICAgIGF0dGFjaCxcbiAgICAgICAgLy8gU2F2ZSBhcmdzIGluIGNhc2Ugd2UgbmVlZCB0byByZWNvbnN0cnVjdCBsYXRlciBmb3IgSE1SXG4gICAgICAgIG1lbW9pemVkUHJvcHM6IHtcbiAgICAgICAgICBhcmdzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEF1dG8tYXR0YWNoIGdlb21ldHJpZXMgYW5kIG1hdGVyaWFsc1xuICAgIGlmIChpbnN0YW5jZS5fX3IzZi5hdHRhY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluc3RhbmNlLmlzQnVmZmVyR2VvbWV0cnkpIGluc3RhbmNlLl9fcjNmLmF0dGFjaCA9ICdnZW9tZXRyeSc7ZWxzZSBpZiAoaW5zdGFuY2UuaXNNYXRlcmlhbCkgaW5zdGFuY2UuX19yM2YuYXR0YWNoID0gJ21hdGVyaWFsJztcbiAgICB9XG5cbiAgICAvLyBJdCBzaG91bGQgTk9UIGNhbGwgb25VcGRhdGUgb24gb2JqZWN0IGluc3RhbmNpYXRpb24sIGJlY2F1c2UgaXQgaGFzbid0IGJlZW4gYWRkZWQgdG8gdGhlXG4gICAgLy8gdmlldyB5ZXQuIElmIHRoZSBjYWxsYmFjayByZWxpZXMgb24gcmVmZXJlbmNlcyBmb3IgaW5zdGFuY2UsIHRoZXkgd29uJ3QgYmUgcmVhZHkgeWV0LCB0aGlzIGlzXG4gICAgLy8gd2h5IGl0IHBhc3NlcyBcInRydWVcIiBoZXJlXG4gICAgLy8gVGhlcmUgaXMgbm8gcmVhc29uIHRvIGFwcGx5IHByb3BzIHRvIGluamVjdHNcbiAgICBpZiAobmFtZSAhPT0gJ2luamVjdCcpIGFwcGx5UHJvcHMkMShpbnN0YW5jZSwgcHJvcHMpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICBmdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICBsZXQgYWRkZWQgPSBmYWxzZTtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIHZhciBfY2hpbGQkX19yM2YsIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjtcbiAgICAgIC8vIFRoZSBhdHRhY2ggYXR0cmlidXRlIGltcGxpZXMgdGhhdCB0aGUgb2JqZWN0IGF0dGFjaGVzIGl0c2VsZiBvbiB0aGUgcGFyZW50XG4gICAgICBpZiAoKF9jaGlsZCRfX3IzZiA9IGNoaWxkLl9fcjNmKSAhPSBudWxsICYmIF9jaGlsZCRfX3IzZi5hdHRhY2gpIHtcbiAgICAgICAgYXR0YWNoKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgY2hpbGQuX19yM2YuYXR0YWNoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQuaXNPYmplY3QzRCAmJiBwYXJlbnRJbnN0YW5jZS5pc09iamVjdDNEKSB7XG4gICAgICAgIC8vIGFkZCBpbiB0aGUgdXN1YWwgcGFyZW50LWNoaWxkIHdheVxuICAgICAgICBwYXJlbnRJbnN0YW5jZS5hZGQoY2hpbGQpO1xuICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGlzIGZvciBhbnl0aGluZyB0aGF0IHVzZWQgYXR0YWNoLCBhbmQgZm9yIG5vbi1PYmplY3QzRHMgdGhhdCBkb24ndCBnZXQgYXR0YWNoZWQgdG8gcHJvcHM7XG4gICAgICAvLyB0aGF0IGlzLCBhbnl0aGluZyB0aGF0J3MgYSBjaGlsZCBpbiBSZWFjdCBidXQgbm90IGEgY2hpbGQgaW4gdGhlIHNjZW5lZ3JhcGguXG4gICAgICBpZiAoIWFkZGVkKSAoX3BhcmVudEluc3RhbmNlJF9fcjNmID0gcGFyZW50SW5zdGFuY2UuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfcGFyZW50SW5zdGFuY2UkX19yM2Yub2JqZWN0cy5wdXNoKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuX19yM2YpIHByZXBhcmUoY2hpbGQsIHt9KTtcbiAgICAgIGNoaWxkLl9fcjNmLnBhcmVudCA9IHBhcmVudEluc3RhbmNlO1xuICAgICAgdXBkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICBsZXQgYWRkZWQgPSBmYWxzZTtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIHZhciBfY2hpbGQkX19yM2YyLCBfcGFyZW50SW5zdGFuY2UkX19yM2YyO1xuICAgICAgaWYgKChfY2hpbGQkX19yM2YyID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmMi5hdHRhY2gpIHtcbiAgICAgICAgYXR0YWNoKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgY2hpbGQuX19yM2YuYXR0YWNoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQuaXNPYmplY3QzRCAmJiBwYXJlbnRJbnN0YW5jZS5pc09iamVjdDNEKSB7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHBhcmVudEluc3RhbmNlO1xuICAgICAgICBjaGlsZC5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICB0eXBlOiAnYWRkZWQnXG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnRJbnN0YW5jZS5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICB0eXBlOiAnY2hpbGRhZGRlZCcsXG4gICAgICAgICAgY2hpbGRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3RTaWJsaW5ncyA9IHBhcmVudEluc3RhbmNlLmNoaWxkcmVuLmZpbHRlcihzaWJsaW5nID0+IHNpYmxpbmcgIT09IGNoaWxkKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSByZXN0U2libGluZ3MuaW5kZXhPZihiZWZvcmVDaGlsZCk7XG4gICAgICAgIHBhcmVudEluc3RhbmNlLmNoaWxkcmVuID0gWy4uLnJlc3RTaWJsaW5ncy5zbGljZSgwLCBpbmRleCksIGNoaWxkLCAuLi5yZXN0U2libGluZ3Muc2xpY2UoaW5kZXgpXTtcbiAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFhZGRlZCkgKF9wYXJlbnRJbnN0YW5jZSRfX3IzZjIgPSBwYXJlbnRJbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJlbnRJbnN0YW5jZSRfX3IzZjIub2JqZWN0cy5wdXNoKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuX19yM2YpIHByZXBhcmUoY2hpbGQsIHt9KTtcbiAgICAgIGNoaWxkLl9fcjNmLnBhcmVudCA9IHBhcmVudEluc3RhbmNlO1xuICAgICAgdXBkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlUmVjdXJzaXZlKGFycmF5LCBwYXJlbnQsIGRpc3Bvc2UgPSBmYWxzZSkge1xuICAgIGlmIChhcnJheSkgWy4uLmFycmF5XS5mb3JFYWNoKGNoaWxkID0+IHJlbW92ZUNoaWxkKHBhcmVudCwgY2hpbGQsIGRpc3Bvc2UpKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGRpc3Bvc2UpIHtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIHZhciBfcGFyZW50SW5zdGFuY2UkX19yM2YzLCBfY2hpbGQkX19yM2YzLCBfY2hpbGQkX19yM2Y1O1xuICAgICAgLy8gQ2xlYXIgdGhlIHBhcmVudCByZWZlcmVuY2VcbiAgICAgIGlmIChjaGlsZC5fX3IzZikgY2hpbGQuX19yM2YucGFyZW50ID0gbnVsbDtcbiAgICAgIC8vIFJlbW92ZSBjaGlsZCBmcm9tIHRoZSBwYXJlbnRzIG9iamVjdHNcbiAgICAgIGlmICgoX3BhcmVudEluc3RhbmNlJF9fcjNmMyA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSAhPSBudWxsICYmIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjMub2JqZWN0cykgcGFyZW50SW5zdGFuY2UuX19yM2Yub2JqZWN0cyA9IHBhcmVudEluc3RhbmNlLl9fcjNmLm9iamVjdHMuZmlsdGVyKHggPT4geCAhPT0gY2hpbGQpO1xuICAgICAgLy8gUmVtb3ZlIGF0dGFjaG1lbnRcbiAgICAgIGlmICgoX2NoaWxkJF9fcjNmMyA9IGNoaWxkLl9fcjNmKSAhPSBudWxsICYmIF9jaGlsZCRfX3IzZjMuYXR0YWNoKSB7XG4gICAgICAgIGRldGFjaChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGNoaWxkLl9fcjNmLmF0dGFjaCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmlzT2JqZWN0M0QgJiYgcGFyZW50SW5zdGFuY2UuaXNPYmplY3QzRCkge1xuICAgICAgICB2YXIgX2NoaWxkJF9fcjNmNDtcbiAgICAgICAgcGFyZW50SW5zdGFuY2UucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAvLyBSZW1vdmUgaW50ZXJhY3Rpdml0eSBvbiB0aGUgaW5pdGlhbCByb290XG4gICAgICAgIGlmICgoX2NoaWxkJF9fcjNmNCA9IGNoaWxkLl9fcjNmKSAhPSBudWxsICYmIF9jaGlsZCRfX3IzZjQucm9vdCkge1xuICAgICAgICAgIHJlbW92ZUludGVyYWN0aXZpdHkoZmluZEluaXRpYWxSb290KGNoaWxkKSwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbG93IG9iamVjdHMgdG8gYmFpbCBvdXQgb2YgcmVjdXJzaXZlIGRpc3Bvc2UgYWx0b2dldGhlciBieSBwYXNzaW5nIGRpc3Bvc2U9e251bGx9XG4gICAgICAvLyBOZXZlciBkaXNwb3NlIG9mIHByaW1pdGl2ZXMgYmVjYXVzZSB0aGVpciBzdGF0ZSBtYXkgYmUga2VwdCBvdXRzaWRlIG9mIFJlYWN0IVxuICAgICAgLy8gSW4gb3JkZXIgZm9yIGFuIG9iamVjdCB0byBiZSBhYmxlIHRvIGRpc3Bvc2UgaXQgaGFzIHRvIGhhdmVcbiAgICAgIC8vICAgLSBhIGRpc3Bvc2UgbWV0aG9kLFxuICAgICAgLy8gICAtIGl0IGNhbm5vdCBiZSBhIDxwcmltaXRpdmUgb2JqZWN0PXsuLi59IC8+XG4gICAgICAvLyAgIC0gaXQgY2Fubm90IGJlIGEgVEhSRUUuU2NlbmUsIGJlY2F1c2UgdGhyZWUgaGFzIGJyb2tlbiBpdCdzIG93biBhcGlcbiAgICAgIC8vXG4gICAgICAvLyBTaW5jZSBkaXNwb3NhbCBpcyByZWN1cnNpdmUsIHdlIGNhbiBjaGVjayB0aGUgb3B0aW9uYWwgZGlzcG9zZSBhcmcsIHdoaWNoIHdpbGwgYmUgdW5kZWZpbmVkXG4gICAgICAvLyB3aGVuIHRoZSByZWNvbmNpbGVyIGNhbGxzIGl0LCBidXQgdGhlbiBjYXJyeSBvdXIgb3duIGNoZWNrIHJlY3Vyc2l2ZWx5XG4gICAgICBjb25zdCBpc1ByaW1pdGl2ZSA9IChfY2hpbGQkX19yM2Y1ID0gY2hpbGQuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfY2hpbGQkX19yM2Y1LnByaW1pdGl2ZTtcbiAgICAgIGNvbnN0IHNob3VsZERpc3Bvc2UgPSAhaXNQcmltaXRpdmUgJiYgKGRpc3Bvc2UgPT09IHVuZGVmaW5lZCA/IGNoaWxkLmRpc3Bvc2UgIT09IG51bGwgOiBkaXNwb3NlKTtcblxuICAgICAgLy8gUmVtb3ZlIG5lc3RlZCBjaGlsZCBvYmplY3RzLiBQcmltaXRpdmVzIHNob3VsZCBub3QgaGF2ZSBvYmplY3RzIGFuZCBjaGlsZHJlbiB0aGF0IGFyZVxuICAgICAgLy8gYXR0YWNoZWQgdG8gdGhlbSBkZWNsYXJhdGl2ZWx5IC4uLlxuICAgICAgaWYgKCFpc1ByaW1pdGl2ZSkge1xuICAgICAgICB2YXIgX2NoaWxkJF9fcjNmNjtcbiAgICAgICAgcmVtb3ZlUmVjdXJzaXZlKChfY2hpbGQkX19yM2Y2ID0gY2hpbGQuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfY2hpbGQkX19yM2Y2Lm9iamVjdHMsIGNoaWxkLCBzaG91bGREaXNwb3NlKTtcbiAgICAgICAgcmVtb3ZlUmVjdXJzaXZlKGNoaWxkLmNoaWxkcmVuLCBjaGlsZCwgc2hvdWxkRGlzcG9zZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSByZWZlcmVuY2VzXG4gICAgICBkZWxldGUgY2hpbGQuX19yM2Y7XG5cbiAgICAgIC8vIERpc3Bvc2UgaXRlbSB3aGVuZXZlciB0aGUgcmVjb25jaWxlciBmZWVscyBsaWtlIGl0XG4gICAgICBpZiAoc2hvdWxkRGlzcG9zZSAmJiBjaGlsZC5kaXNwb3NlICYmIGNoaWxkLnR5cGUgIT09ICdTY2VuZScpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNoaWxkLmRpc3Bvc2UoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiAuLi4gKi9cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2NoZWR1bGUgYXN5bmMgYXQgcnVudGltZSwgZmx1c2ggc3luYyBpbiB0ZXN0aW5nXG4gICAgICAgIGlmICh0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sodW5zdGFibGVfSWRsZVByaW9yaXR5LCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKHBhcmVudEluc3RhbmNlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3dpdGNoSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCBmaWJlcikge1xuICAgIHZhciBfaW5zdGFuY2UkX19yM2Y7XG4gICAgY29uc3QgcGFyZW50ID0gKF9pbnN0YW5jZSRfX3IzZiA9IGluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJF9fcjNmLnBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkgcmV0dXJuO1xuICAgIGNvbnN0IG5ld0luc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIGluc3RhbmNlLl9fcjNmLnJvb3QpO1xuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMTM0OFxuICAgIC8vIFdoZW4gYXJncyBjaGFuZ2UgdGhlIGluc3RhbmNlIGhhcyB0byBiZSByZS1jb25zdHJ1Y3RlZCwgd2hpY2ggdGhlblxuICAgIC8vIGZvcmNlcyByM2YgdG8gcmUtcGFyZW50IHRoZSBjaGlsZHJlbiBhbmQgbm9uLXNjZW5lIG9iamVjdHNcbiAgICBpZiAoaW5zdGFuY2UuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgaW5zdGFuY2UuY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNoaWxkLl9fcjNmKSBhcHBlbmRDaGlsZChuZXdJbnN0YW5jZSwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgaW5zdGFuY2UuY2hpbGRyZW4gPSBpbnN0YW5jZS5jaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4gIWNoaWxkLl9fcjNmKTtcbiAgICB9XG4gICAgaW5zdGFuY2UuX19yM2Yub2JqZWN0cy5mb3JFYWNoKGNoaWxkID0+IGFwcGVuZENoaWxkKG5ld0luc3RhbmNlLCBjaGlsZCkpO1xuICAgIGluc3RhbmNlLl9fcjNmLm9iamVjdHMgPSBbXTtcbiAgICBpZiAoIWluc3RhbmNlLl9fcjNmLmF1dG9SZW1vdmVkQmVmb3JlQXBwZW5kKSB7XG4gICAgICByZW1vdmVDaGlsZChwYXJlbnQsIGluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKG5ld0luc3RhbmNlLnBhcmVudCkge1xuICAgICAgbmV3SW5zdGFuY2UuX19yM2YuYXV0b1JlbW92ZWRCZWZvcmVBcHBlbmQgPSB0cnVlO1xuICAgIH1cbiAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5ld0luc3RhbmNlKTtcblxuICAgIC8vIFJlLWJpbmQgZXZlbnQgaGFuZGxlcnMgb24gdGhlIGluaXRpYWwgcm9vdFxuICAgIGlmIChuZXdJbnN0YW5jZS5yYXljYXN0ICYmIG5ld0luc3RhbmNlLl9fcjNmLmV2ZW50Q291bnQpIHtcbiAgICAgIGNvbnN0IHJvb3RTdGF0ZSA9IGZpbmRJbml0aWFsUm9vdChuZXdJbnN0YW5jZSkuZ2V0U3RhdGUoKTtcbiAgICAgIHJvb3RTdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5wdXNoKG5ld0luc3RhbmNlKTtcbiAgICB9XG4gICAgW2ZpYmVyLCBmaWJlci5hbHRlcm5hdGVdLmZvckVhY2goZmliZXIgPT4ge1xuICAgICAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IG5ld0luc3RhbmNlO1xuICAgICAgICBpZiAoZmliZXIucmVmKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWJlci5yZWYgPT09ICdmdW5jdGlvbicpIGZpYmVyLnJlZihuZXdJbnN0YW5jZSk7ZWxzZSBmaWJlci5yZWYuY3VycmVudCA9IG5ld0luc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBEb24ndCBoYW5kbGUgdGV4dCBpbnN0YW5jZXMsIG1ha2UgaXQgbm8tb3BcbiAgY29uc3QgaGFuZGxlVGV4dEluc3RhbmNlID0gKCkgPT4ge307XG4gIGNvbnN0IHJlY29uY2lsZXIgPSBSZWNvbmNpbGVyKHtcbiAgICBjcmVhdGVJbnN0YW5jZSxcbiAgICByZW1vdmVDaGlsZCxcbiAgICBhcHBlbmRDaGlsZCxcbiAgICBhcHBlbmRJbml0aWFsQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICAgIGluc2VydEJlZm9yZSxcbiAgICBzdXBwb3J0c011dGF0aW9uOiB0cnVlLFxuICAgIGlzUHJpbWFyeVJlbmRlcmVyOiBmYWxzZSxcbiAgICBzdXBwb3J0c1BlcnNpc3RlbmNlOiBmYWxzZSxcbiAgICBzdXBwb3J0c0h5ZHJhdGlvbjogZmFsc2UsXG4gICAgbm9UaW1lb3V0OiAtMSxcbiAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiAoY29udGFpbmVyLCBjaGlsZCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuXG4gICAgICAvLyBEb24ndCBhcHBlbmQgdG8gdW5tb3VudGVkIGNvbnRhaW5lclxuICAgICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZTtcbiAgICAgIGlmICghc2NlbmUuX19yM2YpIHJldHVybjtcblxuICAgICAgLy8gTGluayBjdXJyZW50IHJvb3QgdG8gdGhlIGRlZmF1bHQgc2NlbmVcbiAgICAgIHNjZW5lLl9fcjNmLnJvb3QgPSBjb250YWluZXI7XG4gICAgICBhcHBlbmRDaGlsZChzY2VuZSwgY2hpbGQpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyOiAoY29udGFpbmVyLCBjaGlsZCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuICAgICAgcmVtb3ZlQ2hpbGQoY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmUsIGNoaWxkKTtcbiAgICB9LFxuICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlOiAoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQgfHwgIWJlZm9yZUNoaWxkKSByZXR1cm47XG5cbiAgICAgIC8vIERvbid0IGFwcGVuZCB0byB1bm1vdW50ZWQgY29udGFpbmVyXG4gICAgICBjb25zdCBzY2VuZSA9IGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lO1xuICAgICAgaWYgKCFzY2VuZS5fX3IzZikgcmV0dXJuO1xuICAgICAgaW5zZXJ0QmVmb3JlKHNjZW5lLCBjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgIH0sXG4gICAgZ2V0Um9vdEhvc3RDb250ZXh0OiAoKSA9PiBudWxsLFxuICAgIGdldENoaWxkSG9zdENvbnRleHQ6IHBhcmVudEhvc3RDb250ZXh0ID0+IHBhcmVudEhvc3RDb250ZXh0LFxuICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGluc3RhbmNlKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmMjtcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMiA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjIgOiB7fTtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjAyNzFcbiAgICAgIC8vIFJldHVybmluZyB0cnVlIHdpbGwgdHJpZ2dlciBjb21taXRNb3VudFxuICAgICAgcmV0dXJuIEJvb2xlYW4obG9jYWxTdGF0ZS5oYW5kbGVycyk7XG4gICAgfSxcbiAgICBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCBfdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmMztcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjMgOiB7fTtcblxuICAgICAgLy8gQ3JlYXRlIGRpZmYtc2V0c1xuICAgICAgaWYgKGxvY2FsU3RhdGUucHJpbWl0aXZlICYmIG5ld1Byb3BzLm9iamVjdCAmJiBuZXdQcm9wcy5vYmplY3QgIT09IGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBbdHJ1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgZGF0YSBvYmplY3QsIGxldCdzIGV4dHJhY3QgY3JpdGljYWwgaW5mb3JtYXRpb24gYWJvdXQgaXRcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFyZ3M6IGFyZ3NOZXcgPSBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogY04sXG4gICAgICAgICAgLi4ucmVzdE5ld1xuICAgICAgICB9ID0gbmV3UHJvcHM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhcmdzOiBhcmdzT2xkID0gW10sXG4gICAgICAgICAgY2hpbGRyZW46IGNPLFxuICAgICAgICAgIC4uLnJlc3RPbGRcbiAgICAgICAgfSA9IG9sZFByb3BzO1xuXG4gICAgICAgIC8vIFRocm93IGlmIGFuIG9iamVjdCBvciBsaXRlcmFsIHdhcyBwYXNzZWQgZm9yIGFyZ3NcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3NOZXcpKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogdGhlIGFyZ3MgcHJvcCBtdXN0IGJlIGFuIGFycmF5IScpO1xuXG4gICAgICAgIC8vIElmIGl0IGhhcyBuZXcgcHJvcHMgb3IgYXJndW1lbnRzLCB0aGVuIGl0IG5lZWRzIHRvIGJlIHJlLWluc3RhbnRpYXRlZFxuICAgICAgICBpZiAoYXJnc05ldy5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlICE9PSBhcmdzT2xkW2luZGV4XSkpIHJldHVybiBbdHJ1ZV07XG4gICAgICAgIC8vIENyZWF0ZSBhIGRpZmYtc2V0LCBmbGFnIGlmIHRoZXJlIGFyZSBhbnkgY2hhbmdlc1xuICAgICAgICBjb25zdCBkaWZmID0gZGlmZlByb3BzKGluc3RhbmNlLCByZXN0TmV3LCByZXN0T2xkLCB0cnVlKTtcbiAgICAgICAgaWYgKGRpZmYuY2hhbmdlcy5sZW5ndGgpIHJldHVybiBbZmFsc2UsIGRpZmZdO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBkbyBub3QgdG91Y2ggdGhlIGluc3RhbmNlXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWl0VXBkYXRlKGluc3RhbmNlLCBbcmVjb25zdHJ1Y3QsIGRpZmZdLCB0eXBlLCBfb2xkUHJvcHMsIG5ld1Byb3BzLCBmaWJlcikge1xuICAgICAgLy8gUmVjb25zdHJ1Y3Qgd2hlbiBhcmdzIG9yIDxwcmltaXRpdmUgb2JqZWN0PXsuLi59IGhhdmUgY2hhbmdlc1xuICAgICAgaWYgKHJlY29uc3RydWN0KSBzd2l0Y2hJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIGZpYmVyKTtcbiAgICAgIC8vIE90aGVyd2lzZSBqdXN0IG92ZXJ3cml0ZSBwcm9wc1xuICAgICAgZWxzZSBhcHBseVByb3BzJDEoaW5zdGFuY2UsIGRpZmYpO1xuICAgIH0sXG4gICAgY29tbWl0TW91bnQoaW5zdGFuY2UsIF90eXBlLCBfcHJvcHMsIF9pbnQpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2Y0O1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDI3MVxuICAgICAgLy8gVGhpcyB3aWxsIG1ha2Ugc3VyZSBldmVudHMgYXJlIG9ubHkgYWRkZWQgb25jZSB0byB0aGUgY2VudHJhbCBjb250YWluZXIgb24gdGhlIGluaXRpYWwgcm9vdFxuICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IChfaW5zdGFuY2UkX19yM2Y0ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2Y0IDoge307XG4gICAgICBpZiAoaW5zdGFuY2UucmF5Y2FzdCAmJiBsb2NhbFN0YXRlLmhhbmRsZXJzICYmIGxvY2FsU3RhdGUuZXZlbnRDb3VudCkge1xuICAgICAgICBmaW5kSW5pdGlhbFJvb3QoaW5zdGFuY2UpLmdldFN0YXRlKCkuaW50ZXJuYWwuaW50ZXJhY3Rpb24ucHVzaChpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRQdWJsaWNJbnN0YW5jZTogaW5zdGFuY2UgPT4gaW5zdGFuY2UsXG4gICAgcHJlcGFyZUZvckNvbW1pdDogKCkgPT4gbnVsbCxcbiAgICBwcmVwYXJlUG9ydGFsTW91bnQ6IGNvbnRhaW5lciA9PiBwcmVwYXJlKGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lKSxcbiAgICByZXNldEFmdGVyQ29tbWl0OiAoKSA9PiB7fSxcbiAgICBzaG91bGRTZXRUZXh0Q29udGVudDogKCkgPT4gZmFsc2UsXG4gICAgY2xlYXJDb250YWluZXI6ICgpID0+IGZhbHNlLFxuICAgIGhpZGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjU7XG4gICAgICAvLyBEZXRhY2ggd2hpbGUgdGhlIGluc3RhbmNlIGlzIGhpZGRlblxuICAgICAgY29uc3Qge1xuICAgICAgICBhdHRhY2g6IHR5cGUsXG4gICAgICAgIHBhcmVudFxuICAgICAgfSA9IChfaW5zdGFuY2UkX19yM2Y1ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2Y1IDoge307XG4gICAgICBpZiAodHlwZSAmJiBwYXJlbnQpIGRldGFjaChwYXJlbnQsIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgIGlmIChpbnN0YW5jZS5pc09iamVjdDNEKSBpbnN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIH0sXG4gICAgdW5oaWRlSW5zdGFuY2UoaW5zdGFuY2UsIHByb3BzKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmNjtcbiAgICAgIC8vIFJlLWF0dGFjaCB3aGVuIHRoZSBpbnN0YW5jZSBpcyB1bmhpZGRlblxuICAgICAgY29uc3Qge1xuICAgICAgICBhdHRhY2g6IHR5cGUsXG4gICAgICAgIHBhcmVudFxuICAgICAgfSA9IChfaW5zdGFuY2UkX19yM2Y2ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2Y2IDoge307XG4gICAgICBpZiAodHlwZSAmJiBwYXJlbnQpIGF0dGFjaChwYXJlbnQsIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgIGlmIChpbnN0YW5jZS5pc09iamVjdDNEICYmIHByb3BzLnZpc2libGUgPT0gbnVsbCB8fCBwcm9wcy52aXNpYmxlKSBpbnN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgfSxcbiAgICBjcmVhdGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgICBoaWRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gICAgdW5oaWRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIzNjAjZGlzY3Vzc2lvbl9yOTE2MzU2ODc0XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGdldEN1cnJlbnRFdmVudFByaW9yaXR5OiAoKSA9PiBfZ2V0RXZlbnRQcmlvcml0eSA/IF9nZXRFdmVudFByaW9yaXR5KCkgOiBEZWZhdWx0RXZlbnRQcmlvcml0eSxcbiAgICBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXI6ICgpID0+IHt9LFxuICAgIGFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyOiAoKSA9PiB7fSxcbiAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2U6ICgpID0+IHt9LFxuICAgIG5vdzogdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiBpcy5mdW4ocGVyZm9ybWFuY2Uubm93KSA/IHBlcmZvcm1hbmNlLm5vdyA6IGlzLmZ1bihEYXRlLm5vdykgPyBEYXRlLm5vdyA6ICgpID0+IDAsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIzNjAjZGlzY3Vzc2lvbl9yOTIwODgzNTAzXG4gICAgc2NoZWR1bGVUaW1lb3V0OiBpcy5mdW4oc2V0VGltZW91dCkgPyBzZXRUaW1lb3V0IDogdW5kZWZpbmVkLFxuICAgIGNhbmNlbFRpbWVvdXQ6IGlzLmZ1bihjbGVhclRpbWVvdXQpID8gY2xlYXJUaW1lb3V0IDogdW5kZWZpbmVkXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHJlY29uY2lsZXIsXG4gICAgYXBwbHlQcm9wczogYXBwbHlQcm9wcyQxXG4gIH07XG59XG5cbnZhciBfd2luZG93JGRvY3VtZW50LCBfd2luZG93JG5hdmlnYXRvcjtcbi8qKlxyXG4gKiBSZXR1cm5zIGB0cnVlYCB3aXRoIGNvcnJlY3QgVFMgdHlwZSBpbmZlcmVuY2UgaWYgYW4gb2JqZWN0IGhhcyBhIGNvbmZpZ3VyYWJsZSBjb2xvciBzcGFjZSAoc2luY2UgcjE1MikuXHJcbiAqL1xuY29uc3QgaGFzQ29sb3JTcGFjZSA9IG9iamVjdCA9PiAnY29sb3JTcGFjZScgaW4gb2JqZWN0IHx8ICdvdXRwdXRDb2xvclNwYWNlJyBpbiBvYmplY3Q7XG4vKipcclxuICogVGhlIGN1cnJlbnQgVEhSRUUuQ29sb3JNYW5hZ2VtZW50IGluc3RhbmNlLCBpZiBwcmVzZW50LlxyXG4gKi9cbmNvbnN0IGdldENvbG9yTWFuYWdlbWVudCA9ICgpID0+IHtcbiAgdmFyIF9Db2xvck1hbmFnZW1lbnQ7XG4gIHJldHVybiAoX0NvbG9yTWFuYWdlbWVudCA9IGNhdGFsb2d1ZS5Db2xvck1hbmFnZW1lbnQpICE9IG51bGwgPyBfQ29sb3JNYW5hZ2VtZW50IDogbnVsbDtcbn07XG5jb25zdCBpc09ydGhvZ3JhcGhpY0NhbWVyYSA9IGRlZiA9PiBkZWYgJiYgZGVmLmlzT3J0aG9ncmFwaGljQ2FtZXJhO1xuY29uc3QgaXNSZWYgPSBvYmogPT4gb2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpO1xuXG4vKipcclxuICogQW4gU1NSLWZyaWVuZGx5IHVzZUxheW91dEVmZmVjdC5cclxuICpcclxuICogUmVhY3QgY3VycmVudGx5IHRocm93cyBhIHdhcm5pbmcgd2hlbiB1c2luZyB1c2VMYXlvdXRFZmZlY3Qgb24gdGhlIHNlcnZlci5cclxuICogVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcclxuICogdXNlTGF5b3V0RWZmZWN0IGVsc2V3aGVyZS5cclxuICpcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0OTI3XHJcbiAqL1xuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgoX3dpbmRvdyRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCkgIT0gbnVsbCAmJiBfd2luZG93JGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgfHwgKChfd2luZG93JG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93JG5hdmlnYXRvci5wcm9kdWN0KSA9PT0gJ1JlYWN0TmF0aXZlJykgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5mdW5jdGlvbiB1c2VNdXRhYmxlQ2FsbGJhY2soZm4pIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKGZuKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB2b2lkIChyZWYuY3VycmVudCA9IGZuKSwgW2ZuXSk7XG4gIHJldHVybiByZWY7XG59XG5mdW5jdGlvbiBCbG9jayh7XG4gIHNldFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBzZXQobmV3IFByb21pc2UoKCkgPT4gbnVsbCkpO1xuICAgIHJldHVybiAoKSA9PiBzZXQoZmFsc2UpO1xuICB9LCBbc2V0XSk7XG4gIHJldHVybiBudWxsO1xufVxuY2xhc3MgRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZXJyb3I6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjb21wb25lbnREaWRDYXRjaChlcnIpIHtcbiAgICB0aGlzLnByb3BzLnNldChlcnIpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lcnJvciA/IG51bGwgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59XG5FcnJvckJvdW5kYXJ5LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9ICgpID0+ICh7XG4gIGVycm9yOiB0cnVlXG59KTtcbmNvbnN0IERFRkFVTFQgPSAnX19kZWZhdWx0JztcbmNvbnN0IERFRkFVTFRTID0gbmV3IE1hcCgpO1xuY29uc3QgaXNEaWZmU2V0ID0gZGVmID0+IGRlZiAmJiAhIWRlZi5tZW1vaXplZCAmJiAhIWRlZi5jaGFuZ2VzO1xuZnVuY3Rpb24gY2FsY3VsYXRlRHByKGRwcikge1xuICB2YXIgX3dpbmRvdyRkZXZpY2VQaXhlbFJhO1xuICAvLyBFcnIgb24gdGhlIHNpZGUgb2YgcHJvZ3Jlc3MgYnkgYXNzdW1pbmcgMnggZHByIGlmIHdlIGNhbid0IGRldGVjdCBpdFxuICAvLyBUaGlzIHdpbGwgaGFwcGVuIGluIHdvcmtlcnMgd2hlcmUgd2luZG93IGlzIGRlZmluZWQgYnV0IGRwciBpc24ndC5cbiAgY29uc3QgdGFyZ2V0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAoX3dpbmRvdyRkZXZpY2VQaXhlbFJhID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8pICE9IG51bGwgPyBfd2luZG93JGRldmljZVBpeGVsUmEgOiAyIDogMTtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZHByKSA/IE1hdGgubWluKE1hdGgubWF4KGRwclswXSwgdGFyZ2V0KSwgZHByWzFdKSA6IGRwcjtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgaW5zdGFuY2Ugcm9vdCBzdGF0ZVxyXG4gKi9cbmNvbnN0IGdldFJvb3RTdGF0ZSA9IG9iaiA9PiB7XG4gIHZhciBfcjNmO1xuICByZXR1cm4gKF9yM2YgPSBvYmouX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfcjNmLnJvb3QuZ2V0U3RhdGUoKTtcbn07XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbnN0YW5jZXMgaW5pdGlhbCAob3V0bW9zdCkgcm9vdFxyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbml0aWFsUm9vdChjaGlsZCkge1xuICBsZXQgcm9vdCA9IGNoaWxkLl9fcjNmLnJvb3Q7XG4gIHdoaWxlIChyb290LmdldFN0YXRlKCkucHJldmlvdXNSb290KSByb290ID0gcm9vdC5nZXRTdGF0ZSgpLnByZXZpb3VzUm9vdDtcbiAgcmV0dXJuIHJvb3Q7XG59XG4vLyBBIGNvbGxlY3Rpb24gb2YgY29tcGFyZSBmdW5jdGlvbnNcbmNvbnN0IGlzID0ge1xuICBvYmo6IGEgPT4gYSA9PT0gT2JqZWN0KGEpICYmICFpcy5hcnIoYSkgJiYgdHlwZW9mIGEgIT09ICdmdW5jdGlvbicsXG4gIGZ1bjogYSA9PiB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyxcbiAgc3RyOiBhID0+IHR5cGVvZiBhID09PSAnc3RyaW5nJyxcbiAgbnVtOiBhID0+IHR5cGVvZiBhID09PSAnbnVtYmVyJyxcbiAgYm9vOiBhID0+IHR5cGVvZiBhID09PSAnYm9vbGVhbicsXG4gIHVuZDogYSA9PiBhID09PSB2b2lkIDAsXG4gIGFycjogYSA9PiBBcnJheS5pc0FycmF5KGEpLFxuICBlcXUoYSwgYiwge1xuICAgIGFycmF5cyA9ICdzaGFsbG93JyxcbiAgICBvYmplY3RzID0gJ3JlZmVyZW5jZScsXG4gICAgc3RyaWN0ID0gdHJ1ZVxuICB9ID0ge30pIHtcbiAgICAvLyBXcm9uZyB0eXBlIG9yIG9uZSBvZiB0aGUgdHdvIHVuZGVmaW5lZCwgZG9lc24ndCBtYXRjaFxuICAgIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIgfHwgISFhICE9PSAhIWIpIHJldHVybiBmYWxzZTtcbiAgICAvLyBBdG9taWMsIGp1c3QgY29tcGFyZSBhIGFnYWluc3QgYlxuICAgIGlmIChpcy5zdHIoYSkgfHwgaXMubnVtKGEpIHx8IGlzLmJvbyhhKSkgcmV0dXJuIGEgPT09IGI7XG4gICAgY29uc3QgaXNPYmogPSBpcy5vYmooYSk7XG4gICAgaWYgKGlzT2JqICYmIG9iamVjdHMgPT09ICdyZWZlcmVuY2UnKSByZXR1cm4gYSA9PT0gYjtcbiAgICBjb25zdCBpc0FyciA9IGlzLmFycihhKTtcbiAgICBpZiAoaXNBcnIgJiYgYXJyYXlzID09PSAncmVmZXJlbmNlJykgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gQXJyYXkgb3IgT2JqZWN0LCBzaGFsbG93IGNvbXBhcmUgZmlyc3QgdG8gc2VlIGlmIGl0J3MgYSBtYXRjaFxuICAgIGlmICgoaXNBcnIgfHwgaXNPYmopICYmIGEgPT09IGIpIHJldHVybiB0cnVlO1xuICAgIC8vIExhc3QgcmVzb3J0LCBnbyB0aHJvdWdoIGtleXNcbiAgICBsZXQgaTtcbiAgICAvLyBDaGVjayBpZiBhIGhhcyBhbGwgdGhlIGtleXMgb2YgYlxuICAgIGZvciAoaSBpbiBhKSBpZiAoIShpIGluIGIpKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQ2hlY2sgaWYgdmFsdWVzIGJldHdlZW4ga2V5cyBtYXRjaFxuICAgIGlmIChpc09iaiAmJiBhcnJheXMgPT09ICdzaGFsbG93JyAmJiBvYmplY3RzID09PSAnc2hhbGxvdycpIHtcbiAgICAgIGZvciAoaSBpbiBzdHJpY3QgPyBiIDogYSkgaWYgKCFpcy5lcXUoYVtpXSwgYltpXSwge1xuICAgICAgICBzdHJpY3QsXG4gICAgICAgIG9iamVjdHM6ICdyZWZlcmVuY2UnXG4gICAgICB9KSkgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgaW4gc3RyaWN0ID8gYiA6IGEpIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIElmIGkgaXMgdW5kZWZpbmVkXG4gICAgaWYgKGlzLnVuZChpKSkge1xuICAgICAgLy8gSWYgYm90aCBhcnJheXMgYXJlIGVtcHR5IHdlIGNvbnNpZGVyIHRoZW0gZXF1YWxcbiAgICAgIGlmIChpc0FyciAmJiBhLmxlbmd0aCA9PT0gMCAmJiBiLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBJZiBib3RoIG9iamVjdHMgYXJlIGVtcHR5IHdlIGNvbnNpZGVyIHRoZW0gZXF1YWxcbiAgICAgIGlmIChpc09iaiAmJiBPYmplY3Qua2V5cyhhKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoYikubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIE90aGVyd2lzZSBtYXRjaCB0aGVtIGJ5IHZhbHVlXG4gICAgICBpZiAoYSAhPT0gYikgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXHJcbiAqIENvbGxlY3RzIG5vZGVzIGFuZCBtYXRlcmlhbHMgZnJvbSBhIFRIUkVFLk9iamVjdDNELlxyXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkR3JhcGgob2JqZWN0KSB7XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgbm9kZXM6IHt9LFxuICAgIG1hdGVyaWFsczoge31cbiAgfTtcbiAgaWYgKG9iamVjdCkge1xuICAgIG9iamVjdC50cmF2ZXJzZShvYmogPT4ge1xuICAgICAgaWYgKG9iai5uYW1lKSBkYXRhLm5vZGVzW29iai5uYW1lXSA9IG9iajtcbiAgICAgIGlmIChvYmoubWF0ZXJpYWwgJiYgIWRhdGEubWF0ZXJpYWxzW29iai5tYXRlcmlhbC5uYW1lXSkgZGF0YS5tYXRlcmlhbHNbb2JqLm1hdGVyaWFsLm5hbWVdID0gb2JqLm1hdGVyaWFsO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vLyBEaXNwb3NlcyBhbiBvYmplY3QgYW5kIGFsbCBpdHMgcHJvcGVydGllc1xuZnVuY3Rpb24gZGlzcG9zZShvYmopIHtcbiAgaWYgKG9iai5kaXNwb3NlICYmIG9iai50eXBlICE9PSAnU2NlbmUnKSBvYmouZGlzcG9zZSgpO1xuICBmb3IgKGNvbnN0IHAgaW4gb2JqKSB7XG4gICAgcC5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBwLmRpc3Bvc2UoKTtcbiAgICBkZWxldGUgb2JqW3BdO1xuICB9XG59XG5cbi8vIEVhY2ggb2JqZWN0IGluIHRoZSBzY2VuZSBjYXJyaWVzIGEgc21hbGwgTG9jYWxTdGF0ZSBkZXNjcmlwdG9yXG5mdW5jdGlvbiBwcmVwYXJlKG9iamVjdCwgc3RhdGUpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBvYmplY3Q7XG4gIGluc3RhbmNlLl9fcjNmID0ge1xuICAgIHR5cGU6ICcnLFxuICAgIHJvb3Q6IG51bGwsXG4gICAgcHJldmlvdXNBdHRhY2g6IG51bGwsXG4gICAgbWVtb2l6ZWRQcm9wczoge30sXG4gICAgZXZlbnRDb3VudDogMCxcbiAgICBoYW5kbGVyczoge30sXG4gICAgb2JqZWN0czogW10sXG4gICAgcGFyZW50OiBudWxsLFxuICAgIC4uLnN0YXRlXG4gIH07XG4gIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiByZXNvbHZlKGluc3RhbmNlLCBrZXkpIHtcbiAgbGV0IHRhcmdldCA9IGluc3RhbmNlO1xuICBpZiAoa2V5LmluY2x1ZGVzKCctJykpIHtcbiAgICBjb25zdCBlbnRyaWVzID0ga2V5LnNwbGl0KCctJyk7XG4gICAgY29uc3QgbGFzdCA9IGVudHJpZXMucG9wKCk7XG4gICAgdGFyZ2V0ID0gZW50cmllcy5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2Nba2V5XSwgaW5zdGFuY2UpO1xuICAgIHJldHVybiB7XG4gICAgICB0YXJnZXQsXG4gICAgICBrZXk6IGxhc3RcbiAgICB9O1xuICB9IGVsc2UgcmV0dXJuIHtcbiAgICB0YXJnZXQsXG4gICAga2V5XG4gIH07XG59XG5cbi8vIENoZWNrcyBpZiBhIGRhc2gtY2FzZWQgc3RyaW5nIGVuZHMgd2l0aCBhbiBpbnRlZ2VyXG5jb25zdCBJTkRFWF9SRUdFWCA9IC8tXFxkKyQvO1xuZnVuY3Rpb24gYXR0YWNoKHBhcmVudCwgY2hpbGQsIHR5cGUpIHtcbiAgaWYgKGlzLnN0cih0eXBlKSkge1xuICAgIC8vIElmIGF0dGFjaGluZyBpbnRvIGFuIGFycmF5IChmb28tMCksIGNyZWF0ZSBvbmVcbiAgICBpZiAoSU5ERVhfUkVHRVgudGVzdCh0eXBlKSkge1xuICAgICAgY29uc3Qgcm9vdCA9IHR5cGUucmVwbGFjZShJTkRFWF9SRUdFWCwgJycpO1xuICAgICAgY29uc3Qge1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGtleVxuICAgICAgfSA9IHJlc29sdmUocGFyZW50LCByb290KTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXRba2V5XSkpIHRhcmdldFtrZXldID0gW107XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleVxuICAgIH0gPSByZXNvbHZlKHBhcmVudCwgdHlwZSk7XG4gICAgY2hpbGQuX19yM2YucHJldmlvdXNBdHRhY2ggPSB0YXJnZXRba2V5XTtcbiAgICB0YXJnZXRba2V5XSA9IGNoaWxkO1xuICB9IGVsc2UgY2hpbGQuX19yM2YucHJldmlvdXNBdHRhY2ggPSB0eXBlKHBhcmVudCwgY2hpbGQpO1xufVxuZnVuY3Rpb24gZGV0YWNoKHBhcmVudCwgY2hpbGQsIHR5cGUpIHtcbiAgdmFyIF9jaGlsZCRfX3IzZiwgX2NoaWxkJF9fcjNmMjtcbiAgaWYgKGlzLnN0cih0eXBlKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleVxuICAgIH0gPSByZXNvbHZlKHBhcmVudCwgdHlwZSk7XG4gICAgY29uc3QgcHJldmlvdXMgPSBjaGlsZC5fX3IzZi5wcmV2aW91c0F0dGFjaDtcbiAgICAvLyBXaGVuIHRoZSBwcmV2aW91cyB2YWx1ZSB3YXMgdW5kZWZpbmVkLCBpdCBtZWFucyB0aGUgdmFsdWUgd2FzIG5ldmVyIHNldCB0byBiZWdpbiB3aXRoXG4gICAgaWYgKHByZXZpb3VzID09PSB1bmRlZmluZWQpIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgICAvLyBPdGhlcndpc2Ugc2V0IHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgIGVsc2UgdGFyZ2V0W2tleV0gPSBwcmV2aW91cztcbiAgfSBlbHNlIChfY2hpbGQkX19yM2YgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZi5wcmV2aW91c0F0dGFjaCA9PSBudWxsID8gdm9pZCAwIDogX2NoaWxkJF9fcjNmLnByZXZpb3VzQXR0YWNoKHBhcmVudCwgY2hpbGQpO1xuICAoX2NoaWxkJF9fcjNmMiA9IGNoaWxkLl9fcjNmKSA9PSBudWxsID8gdHJ1ZSA6IGRlbGV0ZSBfY2hpbGQkX19yM2YyLnByZXZpb3VzQXR0YWNoO1xufVxuLy8gVGhpcyBmdW5jdGlvbiBwcmVwYXJlcyBhIHNldCBvZiBjaGFuZ2VzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGluc3RhbmNlXG5mdW5jdGlvbiBkaWZmUHJvcHMoaW5zdGFuY2UsIHtcbiAgY2hpbGRyZW46IGNOLFxuICBrZXk6IGtOLFxuICByZWY6IHJOLFxuICAuLi5wcm9wc1xufSwge1xuICBjaGlsZHJlbjogY1AsXG4gIGtleToga1AsXG4gIHJlZjogclAsXG4gIC4uLnByZXZpb3VzXG59ID0ge30sIHJlbW92ZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGxvY2FsU3RhdGUgPSBpbnN0YW5jZS5fX3IzZjtcbiAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHByb3BzKTtcbiAgY29uc3QgY2hhbmdlcyA9IFtdO1xuXG4gIC8vIENhdGNoIHJlbW92ZWQgcHJvcHMsIHByZXBlbmQgdGhlbSBzbyB0aGV5IGNhbiBiZSByZXNldCBvciByZW1vdmVkXG4gIGlmIChyZW1vdmUpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleXMgPSBPYmplY3Qua2V5cyhwcmV2aW91cyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2aW91c0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJldmlvdXNLZXlzW2ldKSkgZW50cmllcy51bnNoaWZ0KFtwcmV2aW91c0tleXNbaV0sIERFRkFVTFQgKyAncmVtb3ZlJ10pO1xuICAgIH1cbiAgfVxuICBlbnRyaWVzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIHZhciBfaW5zdGFuY2UkX19yM2Y7XG4gICAgLy8gQmFpbCBvdXQgb24gcHJpbWl0aXZlIG9iamVjdFxuICAgIGlmICgoX2luc3RhbmNlJF9fcjNmID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX2luc3RhbmNlJF9fcjNmLnByaW1pdGl2ZSAmJiBrZXkgPT09ICdvYmplY3QnKSByZXR1cm47XG4gICAgLy8gV2hlbiBwcm9wcyBtYXRjaCBiYWlsIG91dFxuICAgIGlmIChpcy5lcXUodmFsdWUsIHByZXZpb3VzW2tleV0pKSByZXR1cm47XG4gICAgLy8gQ29sbGVjdCBoYW5kbGVycyBhbmQgYmFpbCBvdXRcbiAgICBpZiAoL15vbihQb2ludGVyfENsaWNrfERvdWJsZUNsaWNrfENvbnRleHRNZW51fFdoZWVsKS8udGVzdChrZXkpKSByZXR1cm4gY2hhbmdlcy5wdXNoKFtrZXksIHZhbHVlLCB0cnVlLCBbXV0pO1xuICAgIC8vIFNwbGl0IGRhc2hlZCBwcm9wc1xuICAgIGxldCBlbnRyaWVzID0gW107XG4gICAgaWYgKGtleS5pbmNsdWRlcygnLScpKSBlbnRyaWVzID0ga2V5LnNwbGl0KCctJyk7XG4gICAgY2hhbmdlcy5wdXNoKFtrZXksIHZhbHVlLCBmYWxzZSwgZW50cmllc10pO1xuXG4gICAgLy8gUmVzZXQgcGllcmNlZCBwcm9wc1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcykge1xuICAgICAgY29uc3QgdmFsdWUgPSBwcm9wc1twcm9wXTtcbiAgICAgIGlmIChwcm9wLnN0YXJ0c1dpdGgoYCR7a2V5fS1gKSkgY2hhbmdlcy5wdXNoKFtwcm9wLCB2YWx1ZSwgZmFsc2UsIHByb3Auc3BsaXQoJy0nKV0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG1lbW9pemVkID0ge1xuICAgIC4uLnByb3BzXG4gIH07XG4gIGlmIChsb2NhbFN0YXRlICE9IG51bGwgJiYgbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzICYmIGxvY2FsU3RhdGUgIT0gbnVsbCAmJiBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXJncykgbWVtb2l6ZWQuYXJncyA9IGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hcmdzO1xuICBpZiAobG9jYWxTdGF0ZSAhPSBudWxsICYmIGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcyAmJiBsb2NhbFN0YXRlICE9IG51bGwgJiYgbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzLmF0dGFjaCkgbWVtb2l6ZWQuYXR0YWNoID0gbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzLmF0dGFjaDtcbiAgcmV0dXJuIHtcbiAgICBtZW1vaXplZCxcbiAgICBjaGFuZ2VzXG4gIH07XG59XG5jb25zdCBfX0RFVl9fID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XG5cbi8vIFRoaXMgZnVuY3Rpb24gYXBwbGllcyBhIHNldCBvZiBjaGFuZ2VzIHRvIHRoZSBpbnN0YW5jZVxuZnVuY3Rpb24gYXBwbHlQcm9wcyQxKGluc3RhbmNlLCBkYXRhKSB7XG4gIHZhciBfaW5zdGFuY2UkX19yM2YyO1xuICAvLyBGaWx0ZXIgZXF1YWxzLCBldmVudHMgYW5kIHJlc2VydmVkIHByb3BzXG4gIGNvbnN0IGxvY2FsU3RhdGUgPSBpbnN0YW5jZS5fX3IzZjtcbiAgY29uc3Qgcm9vdCA9IGxvY2FsU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGxvY2FsU3RhdGUucm9vdDtcbiAgY29uc3Qgcm9vdFN0YXRlID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5nZXRTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5nZXRTdGF0ZSgpO1xuICBjb25zdCB7XG4gICAgbWVtb2l6ZWQsXG4gICAgY2hhbmdlc1xuICB9ID0gaXNEaWZmU2V0KGRhdGEpID8gZGF0YSA6IGRpZmZQcm9wcyhpbnN0YW5jZSwgZGF0YSk7XG4gIGNvbnN0IHByZXZIYW5kbGVycyA9IGxvY2FsU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGxvY2FsU3RhdGUuZXZlbnRDb3VudDtcblxuICAvLyBQcmVwYXJlIG1lbW9pemVkIHByb3BzXG4gIGlmIChpbnN0YW5jZS5fX3IzZikgaW5zdGFuY2UuX19yM2YubWVtb2l6ZWRQcm9wcyA9IG1lbW9pemVkO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgW2tleSwgdmFsdWUsIGlzRXZlbnQsIGtleXNdID0gY2hhbmdlc1tpXTtcblxuICAgIC8vIEFsaWFzIChvdXRwdXQpZW5jb2RpbmcgPT4gKG91dHB1dCljb2xvclNwYWNlIChzaW5jZSByMTUyKVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yODI5XG4gICAgaWYgKGhhc0NvbG9yU3BhY2UoaW5zdGFuY2UpKSB7XG4gICAgICBjb25zdCBzUkdCRW5jb2RpbmcgPSAzMDAxO1xuICAgICAgY29uc3QgU1JHQkNvbG9yU3BhY2UgPSAnc3JnYic7XG4gICAgICBjb25zdCBMaW5lYXJTUkdCQ29sb3JTcGFjZSA9ICdzcmdiLWxpbmVhcic7XG4gICAgICBpZiAoa2V5ID09PSAnZW5jb2RpbmcnKSB7XG4gICAgICAgIGtleSA9ICdjb2xvclNwYWNlJztcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gc1JHQkVuY29kaW5nID8gU1JHQkNvbG9yU3BhY2UgOiBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnb3V0cHV0RW5jb2RpbmcnKSB7XG4gICAgICAgIGtleSA9ICdvdXRwdXRDb2xvclNwYWNlJztcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gc1JHQkVuY29kaW5nID8gU1JHQkNvbG9yU3BhY2UgOiBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGN1cnJlbnRJbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIGxldCB0YXJnZXRQcm9wID0gY3VycmVudEluc3RhbmNlW2tleV07XG5cbiAgICAvLyBSZXZvbHZlIGRhc2hlZCBwcm9wc1xuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgdGFyZ2V0UHJvcCA9IGtleXMucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjW2tleV0sIGluc3RhbmNlKTtcbiAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYXRvbWljLCBpdCBmb3JjZXMgdXMgdG8gc3dpdGNoIHRoZSByb290XG4gICAgICBpZiAoISh0YXJnZXRQcm9wICYmIHRhcmdldFByb3Auc2V0KSkge1xuICAgICAgICBjb25zdCBbbmFtZSwgLi4ucmV2ZXJzZUVudHJpZXNdID0ga2V5cy5yZXZlcnNlKCk7XG4gICAgICAgIGN1cnJlbnRJbnN0YW5jZSA9IHJldmVyc2VFbnRyaWVzLnJldmVyc2UoKS5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2Nba2V5XSwgaW5zdGFuY2UpO1xuICAgICAgICBrZXkgPSBuYW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzIxMjA5XG4gICAgLy8gSE1SL2Zhc3QtcmVmcmVzaCByZWxpZXMgb24gdGhlIGFiaWxpdHkgdG8gY2FuY2VsIG91dCBwcm9wcywgYnV0IHRocmVlanNcbiAgICAvLyBoYXMgbm8gbWVhbnMgdG8gZG8gdGhpcy4gSGVuY2Ugd2UgY3VyYXRlIGEgc21hbGwgY29sbGVjdGlvbiBvZiB2YWx1ZS1jbGFzc2VzXG4gICAgLy8gd2l0aCB0aGVpciByZXNwZWN0aXZlIGNvbnN0cnVjdG9yL3NldCBhcmd1bWVudHNcbiAgICAvLyBGb3IgcmVtb3ZlZCBwcm9wcywgdHJ5IHRvIHNldCBkZWZhdWx0IHZhbHVlcywgaWYgcG9zc2libGVcbiAgICBpZiAodmFsdWUgPT09IERFRkFVTFQgKyAncmVtb3ZlJykge1xuICAgICAgaWYgKGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAvLyBjcmVhdGUgYSBibGFuayBzbGF0ZSBvZiB0aGUgaW5zdGFuY2UgYW5kIGNvcHkgdGhlIHBhcnRpY3VsYXIgcGFyYW1ldGVyLlxuICAgICAgICBsZXQgY3RvciA9IERFRkFVTFRTLmdldChjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoIWN0b3IpIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgY3RvciA9IG5ldyBjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IoKTtcbiAgICAgICAgICBERUZBVUxUUy5zZXQoY3VycmVudEluc3RhbmNlLmNvbnN0cnVjdG9yLCBjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGN0b3Jba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluc3RhbmNlIGRvZXMgbm90IGhhdmUgY29uc3RydWN0b3IsIGp1c3Qgc2V0IGl0IHRvIDBcbiAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlYWwgd2l0aCBwb2ludGVyIGV2ZW50cyAuLi5cbiAgICBpZiAoaXNFdmVudCAmJiBsb2NhbFN0YXRlKSB7XG4gICAgICBpZiAodmFsdWUpIGxvY2FsU3RhdGUuaGFuZGxlcnNba2V5XSA9IHZhbHVlO2Vsc2UgZGVsZXRlIGxvY2FsU3RhdGUuaGFuZGxlcnNba2V5XTtcbiAgICAgIGxvY2FsU3RhdGUuZXZlbnRDb3VudCA9IE9iamVjdC5rZXlzKGxvY2FsU3RhdGUuaGFuZGxlcnMpLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gU3BlY2lhbCB0cmVhdG1lbnQgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvciBzZXQvY29weSwgYW5kIGxheWVyc1xuICAgIGVsc2UgaWYgKHRhcmdldFByb3AgJiYgdGFyZ2V0UHJvcC5zZXQgJiYgKHRhcmdldFByb3AuY29weSB8fCB0YXJnZXRQcm9wIGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzKSkge1xuICAgICAgLy8gSWYgdmFsdWUgaXMgYW4gYXJyYXlcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAodGFyZ2V0UHJvcC5mcm9tQXJyYXkpIHRhcmdldFByb3AuZnJvbUFycmF5KHZhbHVlKTtlbHNlIHRhcmdldFByb3Auc2V0KC4uLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIFRlc3QgYWdhaW4gdGFyZ2V0LmNvcHkoY2xhc3MpIG5leHQgLi4uXG4gICAgICBlbHNlIGlmICh0YXJnZXRQcm9wLmNvcHkgJiYgdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgKFxuICAgICAgLy8gU29tZSBlbnZpcm9ubWVudHMgbWF5IGJyZWFrIHN0cmljdCBpZGVudGl0eSBjaGVja3MgYnkgZHVwbGljYXRpbmcgdmVyc2lvbnMgb2YgdGhyZWUuanMuXG4gICAgICAvLyBMb29zZW4gdG8gdW5taW5pZmllZCBuYW1lcywgaWdub3JpbmcgZGVzY2VuZGVudHMuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8yODU2XG4gICAgICAvLyBUT0RPOiBmaXggdXBzdHJlYW0gYW5kIHJlbW92ZSBpbiB2OVxuICAgICAgX19ERVZfXyA/IHRhcmdldFByb3AuY29uc3RydWN0b3IubmFtZSA9PT0gdmFsdWUuY29uc3RydWN0b3IubmFtZSA6IHRhcmdldFByb3AuY29uc3RydWN0b3IgPT09IHZhbHVlLmNvbnN0cnVjdG9yKSkge1xuICAgICAgICB0YXJnZXRQcm9wLmNvcHkodmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gSWYgbm90aGluZyBlbHNlIGZpdHMsIGp1c3Qgc2V0IHRoZSBzaW5nbGUgdmFsdWUsIGlnbm9yZSB1bmRlZmluZWRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzI3NFxuICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgX3RhcmdldFByb3A7XG4gICAgICAgIGNvbnN0IGlzQ29sb3IgPSAoX3RhcmdldFByb3AgPSB0YXJnZXRQcm9wKSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldFByb3AuaXNDb2xvcjtcbiAgICAgICAgLy8gQWxsb3cgc2V0dGluZyBhcnJheSBzY2FsYXJzXG4gICAgICAgIGlmICghaXNDb2xvciAmJiB0YXJnZXRQcm9wLnNldFNjYWxhcikgdGFyZ2V0UHJvcC5zZXRTY2FsYXIodmFsdWUpO1xuICAgICAgICAvLyBMYXllcnMgaGF2ZSBubyBjb3B5IGZ1bmN0aW9uLCB3ZSBtdXN0IHRoZXJlZm9yZSBjb3B5IHRoZSBtYXNrIHByb3BlcnR5XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldFByb3AgaW5zdGFuY2VvZiBUSFJFRS5MYXllcnMgJiYgdmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5MYXllcnMpIHRhcmdldFByb3AubWFzayA9IHZhbHVlLm1hc2s7XG4gICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IHNldCAuLi5cbiAgICAgICAgZWxzZSB0YXJnZXRQcm9wLnNldCh2YWx1ZSk7XG4gICAgICAgIC8vIEZvciB2ZXJzaW9ucyBvZiB0aHJlZSB3aGljaCBkb24ndCBzdXBwb3J0IFRIUkVFLkNvbG9yTWFuYWdlbWVudCxcbiAgICAgICAgLy8gQXV0by1jb252ZXJ0IHNSR0IgY29sb3JzXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzM0NFxuICAgICAgICBpZiAoIWdldENvbG9yTWFuYWdlbWVudCgpICYmIHJvb3RTdGF0ZSAmJiAhcm9vdFN0YXRlLmxpbmVhciAmJiBpc0NvbG9yKSB0YXJnZXRQcm9wLmNvbnZlcnRTUkdCVG9MaW5lYXIoKTtcbiAgICAgIH1cbiAgICAgIC8vIEVsc2UsIGp1c3Qgb3ZlcndyaXRlIHRoZSB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2N1cnJlbnRJbnN0YW5jZSRrZXk7XG4gICAgICBjdXJyZW50SW5zdGFuY2Vba2V5XSA9IHZhbHVlO1xuXG4gICAgICAvLyBBdXRvLWNvbnZlcnQgc1JHQiB0ZXh0dXJlcywgZm9yIG5vdyAuLi5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzM0NFxuICAgICAgaWYgKChfY3VycmVudEluc3RhbmNlJGtleSA9IGN1cnJlbnRJbnN0YW5jZVtrZXldKSAhPSBudWxsICYmIF9jdXJyZW50SW5zdGFuY2Uka2V5LmlzVGV4dHVyZSAmJlxuICAgICAgLy8gc1JHQiB0ZXh0dXJlcyBtdXN0IGJlIFJHQkE4IHNpbmNlIHIxMzcgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIzMTI5XG4gICAgICBjdXJyZW50SW5zdGFuY2Vba2V5XS5mb3JtYXQgPT09IFRIUkVFLlJHQkFGb3JtYXQgJiYgY3VycmVudEluc3RhbmNlW2tleV0udHlwZSA9PT0gVEhSRUUuVW5zaWduZWRCeXRlVHlwZSAmJiByb290U3RhdGUpIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IGN1cnJlbnRJbnN0YW5jZVtrZXldO1xuICAgICAgICBpZiAoaGFzQ29sb3JTcGFjZSh0ZXh0dXJlKSAmJiBoYXNDb2xvclNwYWNlKHJvb3RTdGF0ZS5nbCkpIHRleHR1cmUuY29sb3JTcGFjZSA9IHJvb3RTdGF0ZS5nbC5vdXRwdXRDb2xvclNwYWNlO2Vsc2UgdGV4dHVyZS5lbmNvZGluZyA9IHJvb3RTdGF0ZS5nbC5vdXRwdXRFbmNvZGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgfVxuICBpZiAobG9jYWxTdGF0ZSAmJiBsb2NhbFN0YXRlLnBhcmVudCAmJiBpbnN0YW5jZS5yYXljYXN0ICYmIHByZXZIYW5kbGVycyAhPT0gbG9jYWxTdGF0ZS5ldmVudENvdW50KSB7XG4gICAgLy8gR2V0IHRoZSBpbml0aWFsIHJvb3Qgc3RhdGUncyBpbnRlcm5hbHNcbiAgICBjb25zdCBpbnRlcm5hbCA9IGZpbmRJbml0aWFsUm9vdChpbnN0YW5jZSkuZ2V0U3RhdGUoKS5pbnRlcm5hbDtcbiAgICAvLyBQcmUtZW1wdGl2ZWx5IHJlbW92ZSB0aGUgaW5zdGFuY2UgZnJvbSB0aGUgaW50ZXJhY3Rpb24gbWFuYWdlclxuICAgIGNvbnN0IGluZGV4ID0gaW50ZXJuYWwuaW50ZXJhY3Rpb24uaW5kZXhPZihpbnN0YW5jZSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIGludGVybmFsLmludGVyYWN0aW9uLnNwbGljZShpbmRleCwgMSk7XG4gICAgLy8gQWRkIHRoZSBpbnN0YW5jZSB0byB0aGUgaW50ZXJhY3Rpb24gbWFuYWdlciBvbmx5IHdoZW4gaXQgaGFzIGhhbmRsZXJzXG4gICAgaWYgKGxvY2FsU3RhdGUuZXZlbnRDb3VudCkgaW50ZXJuYWwuaW50ZXJhY3Rpb24ucHVzaChpbnN0YW5jZSk7XG4gIH1cblxuICAvLyBDYWxsIHRoZSB1cGRhdGUgbGlmZWN5Y2xlIHdoZW4gaXQgaXMgYmVpbmcgdXBkYXRlZCwgYnV0IG9ubHkgd2hlbiBpdCBpcyBwYXJ0IG9mIHRoZSBzY2VuZS5cbiAgLy8gU2tpcCB1cGRhdGVzIHRvIHRoZSBgb25VcGRhdGVgIHByb3AgaXRzZWxmXG4gIGNvbnN0IGlzQ2lyY3VsYXIgPSBjaGFuZ2VzLmxlbmd0aCA9PT0gMSAmJiBjaGFuZ2VzWzBdWzBdID09PSAnb25VcGRhdGUnO1xuICBpZiAoIWlzQ2lyY3VsYXIgJiYgY2hhbmdlcy5sZW5ndGggJiYgKF9pbnN0YW5jZSRfX3IzZjIgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCAmJiBfaW5zdGFuY2UkX19yM2YyLnBhcmVudCkgdXBkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgdmFyIF9pbnN0YW5jZSRfX3IzZjMsIF9pbnN0YW5jZSRfX3IzZjMkcm9vdDtcbiAgY29uc3Qgc3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMyA9IGluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogKF9pbnN0YW5jZSRfX3IzZjMkcm9vdCA9IF9pbnN0YW5jZSRfX3IzZjMucm9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRfX3IzZjMkcm9vdC5nZXRTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJF9fcjNmMyRyb290LmdldFN0YXRlKCk7XG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPT09IDApIHN0YXRlLmludmFsaWRhdGUoKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLm9uVXBkYXRlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5vblVwZGF0ZShpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzkyXG4gIC8vIERvIG5vdCBtZXNzIHdpdGggdGhlIGNhbWVyYSBpZiBpdCBiZWxvbmdzIHRvIHRoZSB1c2VyXG4gIGlmICghY2FtZXJhLm1hbnVhbCkge1xuICAgIGlmIChpc09ydGhvZ3JhcGhpY0NhbWVyYShjYW1lcmEpKSB7XG4gICAgICBjYW1lcmEubGVmdCA9IHNpemUud2lkdGggLyAtMjtcbiAgICAgIGNhbWVyYS5yaWdodCA9IHNpemUud2lkdGggLyAyO1xuICAgICAgY2FtZXJhLnRvcCA9IHNpemUuaGVpZ2h0IC8gMjtcbiAgICAgIGNhbWVyYS5ib3R0b20gPSBzaXplLmhlaWdodCAvIC0yO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW1lcmEuYXNwZWN0ID0gc2l6ZS53aWR0aCAvIHNpemUuaGVpZ2h0O1xuICAgIH1cbiAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzE3OFxuICAgIC8vIFVwZGF0ZSBtYXRyaXggd29ybGQgc2luY2UgdGhlIHJlbmRlcmVyIGlzIGEgZnJhbWUgbGF0ZVxuICAgIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VJZChldmVudCkge1xuICByZXR1cm4gKGV2ZW50LmV2ZW50T2JqZWN0IHx8IGV2ZW50Lm9iamVjdCkudXVpZCArICcvJyArIGV2ZW50LmluZGV4ICsgZXZlbnQuaW5zdGFuY2VJZDtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3RyZWUvbWFpbi9wYWNrYWdlcy9yZWFjdC1yZWNvbmNpbGVyI2dldGN1cnJlbnRldmVudHByaW9yaXR5XG4vLyBHaXZlcyBSZWFjdCBhIGNsdWUgYXMgdG8gaG93IGltcG9ydCB0aGUgY3VycmVudCBpbnRlcmFjdGlvbiBpc1xuZnVuY3Rpb24gZ2V0RXZlbnRQcmlvcml0eSgpIHtcbiAgdmFyIF9nbG9iYWxTY29wZSRldmVudDtcbiAgLy8gR2V0IGEgaGFuZGxlIHRvIHRoZSBjdXJyZW50IGdsb2JhbCBzY29wZSBpbiB3aW5kb3cgYW5kIHdvcmtlciBjb250ZXh0cyBpZiBhYmxlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yNDkzXG4gIGNvbnN0IGdsb2JhbFNjb3BlID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgfHwgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93O1xuICBpZiAoIWdsb2JhbFNjb3BlKSByZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7XG4gIGNvbnN0IG5hbWUgPSAoX2dsb2JhbFNjb3BlJGV2ZW50ID0gZ2xvYmFsU2NvcGUuZXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsU2NvcGUkZXZlbnQudHlwZTtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnY2xpY2snOlxuICAgIGNhc2UgJ2NvbnRleHRtZW51JzpcbiAgICBjYXNlICdkYmxjbGljayc6XG4gICAgY2FzZSAncG9pbnRlcmNhbmNlbCc6XG4gICAgY2FzZSAncG9pbnRlcmRvd24nOlxuICAgIGNhc2UgJ3BvaW50ZXJ1cCc6XG4gICAgICByZXR1cm4gRGlzY3JldGVFdmVudFByaW9yaXR5O1xuICAgIGNhc2UgJ3BvaW50ZXJtb3ZlJzpcbiAgICBjYXNlICdwb2ludGVyb3V0JzpcbiAgICBjYXNlICdwb2ludGVyb3Zlcic6XG4gICAgY2FzZSAncG9pbnRlcmVudGVyJzpcbiAgICBjYXNlICdwb2ludGVybGVhdmUnOlxuICAgIGNhc2UgJ3doZWVsJzpcbiAgICAgIHJldHVybiBDb250aW51b3VzRXZlbnRQcmlvcml0eTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O1xuICB9XG59XG5cbi8qKlxyXG4gKiBSZWxlYXNlIHBvaW50ZXIgY2FwdHVyZXMuXHJcbiAqIFRoaXMgaXMgY2FsbGVkIGJ5IHJlbGVhc2VQb2ludGVyQ2FwdHVyZSBpbiB0aGUgQVBJLCBhbmQgd2hlbiBhbiBvYmplY3QgaXMgcmVtb3ZlZC5cclxuICovXG5mdW5jdGlvbiByZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZShjYXB0dXJlZE1hcCwgb2JqLCBjYXB0dXJlcywgcG9pbnRlcklkKSB7XG4gIGNvbnN0IGNhcHR1cmVEYXRhID0gY2FwdHVyZXMuZ2V0KG9iaik7XG4gIGlmIChjYXB0dXJlRGF0YSkge1xuICAgIGNhcHR1cmVzLmRlbGV0ZShvYmopO1xuICAgIC8vIElmIHRoaXMgd2FzIHRoZSBsYXN0IGNhcHR1cmluZyBvYmplY3QgZm9yIHRoaXMgcG9pbnRlclxuICAgIGlmIChjYXB0dXJlcy5zaXplID09PSAwKSB7XG4gICAgICBjYXB0dXJlZE1hcC5kZWxldGUocG9pbnRlcklkKTtcbiAgICAgIGNhcHR1cmVEYXRhLnRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUocG9pbnRlcklkKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUludGVyYWN0aXZpdHkoc3RvcmUsIG9iamVjdCkge1xuICBjb25zdCB7XG4gICAgaW50ZXJuYWxcbiAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIC8vIFJlbW92ZXMgZXZlcnkgdHJhY2Ugb2YgYW4gb2JqZWN0IGZyb20gdGhlIGRhdGEgc3RvcmVcbiAgaW50ZXJuYWwuaW50ZXJhY3Rpb24gPSBpbnRlcm5hbC5pbnRlcmFjdGlvbi5maWx0ZXIobyA9PiBvICE9PSBvYmplY3QpO1xuICBpbnRlcm5hbC5pbml0aWFsSGl0cyA9IGludGVybmFsLmluaXRpYWxIaXRzLmZpbHRlcihvID0+IG8gIT09IG9iamVjdCk7XG4gIGludGVybmFsLmhvdmVyZWQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICh2YWx1ZS5ldmVudE9iamVjdCA9PT0gb2JqZWN0IHx8IHZhbHVlLm9iamVjdCA9PT0gb2JqZWN0KSB7XG4gICAgICAvLyBDbGVhciBvdXQgaW50ZXJzZWN0cywgdGhleSBhcmUgb3V0ZGF0ZWQgYnkgbm93XG4gICAgICBpbnRlcm5hbC5ob3ZlcmVkLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfSk7XG4gIGludGVybmFsLmNhcHR1cmVkTWFwLmZvckVhY2goKGNhcHR1cmVzLCBwb2ludGVySWQpID0+IHtcbiAgICByZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZShpbnRlcm5hbC5jYXB0dXJlZE1hcCwgb2JqZWN0LCBjYXB0dXJlcywgcG9pbnRlcklkKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFdmVudHMoc3RvcmUpIHtcbiAgLyoqIENhbGN1bGF0ZXMgZGVsdGEgKi9cbiAgZnVuY3Rpb24gY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcm5hbFxuICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGR4ID0gZXZlbnQub2Zmc2V0WCAtIGludGVybmFsLmluaXRpYWxDbGlja1swXTtcbiAgICBjb25zdCBkeSA9IGV2ZW50Lm9mZnNldFkgLSBpbnRlcm5hbC5pbml0aWFsQ2xpY2tbMV07XG4gICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSk7XG4gIH1cblxuICAvKiogUmV0dXJucyB0cnVlIGlmIGFuIGluc3RhbmNlIGhhcyBhIHZhbGlkIHBvaW50ZXItZXZlbnQgcmVnaXN0ZXJlZCwgdGhpcyBleGNsdWRlcyBzY3JvbGwsIGNsaWNrcyBldGMgKi9cbiAgZnVuY3Rpb24gZmlsdGVyUG9pbnRlckV2ZW50cyhvYmplY3RzKSB7XG4gICAgcmV0dXJuIG9iamVjdHMuZmlsdGVyKG9iaiA9PiBbJ01vdmUnLCAnT3ZlcicsICdFbnRlcicsICdPdXQnLCAnTGVhdmUnXS5zb21lKG5hbWUgPT4ge1xuICAgICAgdmFyIF9yM2Y7XG4gICAgICByZXR1cm4gKF9yM2YgPSBvYmouX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfcjNmLmhhbmRsZXJzWydvblBvaW50ZXInICsgbmFtZV07XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIGludGVyc2VjdChldmVudCwgZmlsdGVyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGR1cGxpY2F0ZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgIC8vIEFsbG93IGNhbGxlcnMgdG8gZWxpbWluYXRlIGV2ZW50IG9iamVjdHNcbiAgICBjb25zdCBldmVudHNPYmplY3RzID0gZmlsdGVyID8gZmlsdGVyKHN0YXRlLmludGVybmFsLmludGVyYWN0aW9uKSA6IHN0YXRlLmludGVybmFsLmludGVyYWN0aW9uO1xuICAgIC8vIFJlc2V0IGFsbCByYXljYXN0ZXIgY2FtZXJhcyB0byB1bmRlZmluZWRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50c09iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZ2V0Um9vdFN0YXRlKGV2ZW50c09iamVjdHNbaV0pO1xuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc3RhdGUucHJldmlvdXNSb290KSB7XG4gICAgICAvLyBNYWtlIHN1cmUgcm9vdC1sZXZlbCBwb2ludGVyIGFuZCByYXkgYXJlIHNldCB1cFxuICAgICAgc3RhdGUuZXZlbnRzLmNvbXB1dGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5jb21wdXRlKGV2ZW50LCBzdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVJheWNhc3Qob2JqKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShvYmopO1xuICAgICAgLy8gU2tpcCBldmVudCBoYW5kbGluZyB3aGVuIG5vRXZlbnRzIGlzIHNldCwgb3Igd2hlbiB0aGUgcmF5Y2FzdGVycyBjYW1lcmEgaXMgbnVsbFxuICAgICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuZXZlbnRzLmVuYWJsZWQgfHwgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuXG4gICAgICAvLyBXaGVuIHRoZSBjYW1lcmEgaXMgdW5kZWZpbmVkIHdlIGhhdmUgdG8gY2FsbCB0aGUgZXZlbnQgbGF5ZXJzIHVwZGF0ZSBmdW5jdGlvblxuICAgICAgaWYgKHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgX3N0YXRlJHByZXZpb3VzUm9vdDtcbiAgICAgICAgc3RhdGUuZXZlbnRzLmNvbXB1dGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5jb21wdXRlKGV2ZW50LCBzdGF0ZSwgKF9zdGF0ZSRwcmV2aW91c1Jvb3QgPSBzdGF0ZS5wcmV2aW91c1Jvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkcHJldmlvdXNSb290LmdldFN0YXRlKCkpO1xuICAgICAgICAvLyBJZiB0aGUgY2FtZXJhIGlzIHN0aWxsIHVuZGVmaW5lZCB3ZSBoYXZlIHRvIHNraXAgdGhpcyBsYXllciBlbnRpcmVseVxuICAgICAgICBpZiAoc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9PT0gdW5kZWZpbmVkKSBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJzZWN0IG9iamVjdCBieSBvYmplY3RcbiAgICAgIHJldHVybiBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID8gc3RhdGUucmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdChvYmosIHRydWUpIDogW107XG4gICAgfVxuXG4gICAgLy8gQ29sbGVjdCBldmVudHNcbiAgICBsZXQgaGl0cyA9IGV2ZW50c09iamVjdHNcbiAgICAvLyBJbnRlcnNlY3Qgb2JqZWN0c1xuICAgIC5mbGF0TWFwKGhhbmRsZVJheWNhc3QpXG4gICAgLy8gU29ydCBieSBldmVudCBwcmlvcml0eSBhbmQgZGlzdGFuY2VcbiAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgYVN0YXRlID0gZ2V0Um9vdFN0YXRlKGEub2JqZWN0KTtcbiAgICAgIGNvbnN0IGJTdGF0ZSA9IGdldFJvb3RTdGF0ZShiLm9iamVjdCk7XG4gICAgICBpZiAoIWFTdGF0ZSB8fCAhYlN0YXRlKSByZXR1cm4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XG4gICAgICByZXR1cm4gYlN0YXRlLmV2ZW50cy5wcmlvcml0eSAtIGFTdGF0ZS5ldmVudHMucHJpb3JpdHkgfHwgYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XG4gICAgfSlcbiAgICAvLyBGaWx0ZXIgb3V0IGR1cGxpY2F0ZXNcbiAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgY29uc3QgaWQgPSBtYWtlSWQoaXRlbSk7XG4gICAgICBpZiAoZHVwbGljYXRlcy5oYXMoaWQpKSByZXR1cm4gZmFsc2U7XG4gICAgICBkdXBsaWNhdGVzLmFkZChpZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzE2MDMxXG4gICAgLy8gQWxsb3cgY3VzdG9tIHVzZXJsYW5kIGludGVyc2VjdCBzb3J0IG9yZGVyLCB0aGlzIGxpa2VseSBvbmx5IG1ha2VzIHNlbnNlIG9uIHRoZSByb290IGZpbHRlclxuICAgIGlmIChzdGF0ZS5ldmVudHMuZmlsdGVyKSBoaXRzID0gc3RhdGUuZXZlbnRzLmZpbHRlcihoaXRzLCBzdGF0ZSk7XG5cbiAgICAvLyBCdWJibGUgdXAgdGhlIGV2ZW50cywgZmluZCB0aGUgZXZlbnQgc291cmNlIChldmVudE9iamVjdClcbiAgICBmb3IgKGNvbnN0IGhpdCBvZiBoaXRzKSB7XG4gICAgICBsZXQgZXZlbnRPYmplY3QgPSBoaXQub2JqZWN0O1xuICAgICAgLy8gQnViYmxlIGV2ZW50IHVwXG4gICAgICB3aGlsZSAoZXZlbnRPYmplY3QpIHtcbiAgICAgICAgdmFyIF9yM2YyO1xuICAgICAgICBpZiAoKF9yM2YyID0gZXZlbnRPYmplY3QuX19yM2YpICE9IG51bGwgJiYgX3IzZjIuZXZlbnRDb3VudCkgaW50ZXJzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAuLi5oaXQsXG4gICAgICAgICAgZXZlbnRPYmplY3RcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50T2JqZWN0ID0gZXZlbnRPYmplY3QucGFyZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBpbnRlcmFjdGlvbiBpcyBjYXB0dXJlZCwgbWFrZSBhbGwgY2FwdHVyaW5nIHRhcmdldHMgcGFydCBvZiB0aGUgaW50ZXJzZWN0LlxuICAgIGlmICgncG9pbnRlcklkJyBpbiBldmVudCAmJiBzdGF0ZS5pbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgZm9yIChsZXQgY2FwdHVyZURhdGEgb2Ygc3RhdGUuaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGV2ZW50LnBvaW50ZXJJZCkudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKCFkdXBsaWNhdGVzLmhhcyhtYWtlSWQoY2FwdHVyZURhdGEuaW50ZXJzZWN0aW9uKSkpIGludGVyc2VjdGlvbnMucHVzaChjYXB0dXJlRGF0YS5pbnRlcnNlY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuXG4gIC8qKiAgSGFuZGxlcyBpbnRlcnNlY3Rpb25zIGJ5IGZvcndhcmRpbmcgdGhlbSB0byBoYW5kbGVycyAqL1xuICBmdW5jdGlvbiBoYW5kbGVJbnRlcnNlY3RzKGludGVyc2VjdGlvbnMsIGV2ZW50LCBkZWx0YSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCByb290U3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgLy8gSWYgYW55dGhpbmcgaGFzIGJlZW4gZm91bmQsIGZvcndhcmQgaXQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHtcbiAgICAgICAgc3RvcHBlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGhpdCBvZiBpbnRlcnNlY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0Um9vdFN0YXRlKGhpdC5vYmplY3QpIHx8IHJvb3RTdGF0ZTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJheWNhc3RlcixcbiAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgIGNhbWVyYSxcbiAgICAgICAgICBpbnRlcm5hbFxuICAgICAgICB9ID0gc3RhdGU7XG4gICAgICAgIGNvbnN0IHVucHJvamVjdGVkUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMyhwb2ludGVyLngsIHBvaW50ZXIueSwgMCkudW5wcm9qZWN0KGNhbWVyYSk7XG4gICAgICAgIGNvbnN0IGhhc1BvaW50ZXJDYXB0dXJlID0gaWQgPT4ge1xuICAgICAgICAgIHZhciBfaW50ZXJuYWwkY2FwdHVyZWRNYXAsIF9pbnRlcm5hbCRjYXB0dXJlZE1hcDI7XG4gICAgICAgICAgcmV0dXJuIChfaW50ZXJuYWwkY2FwdHVyZWRNYXAgPSAoX2ludGVybmFsJGNhcHR1cmVkTWFwMiA9IGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCkpID09IG51bGwgPyB2b2lkIDAgOiBfaW50ZXJuYWwkY2FwdHVyZWRNYXAyLmhhcyhoaXQuZXZlbnRPYmplY3QpKSAhPSBudWxsID8gX2ludGVybmFsJGNhcHR1cmVkTWFwIDogZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNldFBvaW50ZXJDYXB0dXJlID0gaWQgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhcHR1cmVEYXRhID0ge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uOiBoaXQsXG4gICAgICAgICAgICB0YXJnZXQ6IGV2ZW50LnRhcmdldFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludGVySWQgd2FzIHByZXZpb3VzbHkgY2FwdHVyZWQsIHdlIGFkZCB0aGUgaGl0IHRvIHRoZVxuICAgICAgICAgICAgLy8gZXZlbnQgY2FwdHVyZWRNYXAuXG4gICAgICAgICAgICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpLnNldChoaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVEYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBvaW50ZXJJZCB3YXMgbm90IHByZXZpb3VzbHkgY2FwdHVyZWQsIHdlIGNyZWF0ZSBhIG1hcFxuICAgICAgICAgICAgLy8gY29udGFpbmluZyB0aGUgaGl0T2JqZWN0LCBhbmQgdGhlIGhpdC4gaGl0T2JqZWN0IGlzIHVzZWQgZm9yXG4gICAgICAgICAgICAvLyBmYXN0ZXIgYWNjZXNzLlxuICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuc2V0KGlkLCBuZXcgTWFwKFtbaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlRGF0YV1dKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2ZW50LnRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShpZCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlbGVhc2VQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlcyA9IGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCk7XG4gICAgICAgICAgaWYgKGNhcHR1cmVzKSB7XG4gICAgICAgICAgICByZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZShpbnRlcm5hbC5jYXB0dXJlZE1hcCwgaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlcywgaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBZGQgbmF0aXZlIGV2ZW50IHByb3BzXG4gICAgICAgIGxldCBleHRyYWN0RXZlbnRQcm9wcyA9IHt9O1xuICAgICAgICAvLyBUaGlzIGl0ZXJhdGVzIG92ZXIgdGhlIGV2ZW50J3MgcHJvcGVydGllcyBpbmNsdWRpbmcgdGhlIGluaGVyaXRlZCBvbmVzLiBOYXRpdmUgUG9pbnRlckV2ZW50cyBoYXZlIG1vc3Qgb2YgdGhlaXIgcHJvcHMgYXMgZ2V0dGVycyB3aGljaCBhcmUgaW5oZXJpdGVkLCBidXQgcG9seWZpbGxlZCBQb2ludGVyRXZlbnRzIGhhdmUgdGhlbSBhbGwgYXMgdGhlaXIgb3duIHByb3BlcnRpZXMgKGkuZS4gbm90IGluaGVyaXRlZCkuIFdlIGNhbid0IHVzZSBPYmplY3Qua2V5cygpIG9yIE9iamVjdC5lbnRyaWVzKCkgYXMgdGhleSBvbmx5IHJldHVybiBcIm93blwiIHByb3BlcnRpZXM7IG5vciBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXZlbnQpIGFzIHRoYXQgKmRvZXNuJ3QqIHJldHVybiBcIm93blwiIHByb3BlcnRpZXMsIG9ubHkgaW5oZXJpdGVkIG9uZXMuXG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gZXZlbnQpIHtcbiAgICAgICAgICBsZXQgcHJvcGVydHkgPSBldmVudFtwcm9wXTtcbiAgICAgICAgICAvLyBPbmx5IGNvcHkgb3ZlciBhdG9taWNzLCBsZWF2ZSBmdW5jdGlvbnMgYWxvbmUgYXMgdGhlc2Ugc2hvdWxkIGJlXG4gICAgICAgICAgLy8gY2FsbGVkIGFzIGV2ZW50Lm5hdGl2ZUV2ZW50LmZuKClcbiAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ICE9PSAnZnVuY3Rpb24nKSBleHRyYWN0RXZlbnRQcm9wc1twcm9wXSA9IHByb3BlcnR5O1xuICAgICAgICB9XG4gICAgICAgIGxldCByYXljYXN0RXZlbnQgPSB7XG4gICAgICAgICAgLi4uaGl0LFxuICAgICAgICAgIC4uLmV4dHJhY3RFdmVudFByb3BzLFxuICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgaW50ZXJzZWN0aW9ucyxcbiAgICAgICAgICBzdG9wcGVkOiBsb2NhbFN0YXRlLnN0b3BwZWQsXG4gICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgdW5wcm9qZWN0ZWRQb2ludCxcbiAgICAgICAgICByYXk6IHJheWNhc3Rlci5yYXksXG4gICAgICAgICAgY2FtZXJhOiBjYW1lcmEsXG4gICAgICAgICAgLy8gSGlqYWNrIHN0b3BQcm9wYWdhdGlvbiwgd2hpY2gganVzdCBzZXRzIGEgZmxhZ1xuICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzU5NlxuICAgICAgICAgICAgLy8gRXZlbnRzIGFyZSBub3QgYWxsb3dlZCB0byBzdG9wIHByb3BhZ2F0aW9uIGlmIHRoZSBwb2ludGVyIGhhcyBiZWVuIGNhcHR1cmVkXG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlc0ZvclBvaW50ZXIgPSAncG9pbnRlcklkJyBpbiBldmVudCAmJiBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoZXZlbnQucG9pbnRlcklkKTtcblxuICAgICAgICAgICAgLy8gV2Ugb25seSBhdXRob3JpemUgc3RvcFByb3BhZ2F0aW9uLi4uXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyAuLi5pZiB0aGlzIHBvaW50ZXIgaGFzbid0IGJlZW4gY2FwdHVyZWRcbiAgICAgICAgICAgICFjYXB0dXJlc0ZvclBvaW50ZXIgfHxcbiAgICAgICAgICAgIC8vIC4uLiBvciBpZiB0aGUgaGl0IG9iamVjdCBpcyBjYXB0dXJpbmcgdGhlIHBvaW50ZXJcbiAgICAgICAgICAgIGNhcHR1cmVzRm9yUG9pbnRlci5oYXMoaGl0LmV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICByYXljYXN0RXZlbnQuc3RvcHBlZCA9IGxvY2FsU3RhdGUuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgIC8vIFByb3BhZ2F0aW9uIGlzIHN0b3BwZWQsIHJlbW92ZSBhbGwgb3RoZXIgaG92ZXIgcmVjb3Jkc1xuICAgICAgICAgICAgICAvLyBBbiBldmVudCBoYW5kbGVyIGlzIG9ubHkgYWxsb3dlZCB0byBmbHVzaCBvdGhlciBoYW5kbGVycyBpZiBpdCBpcyBob3ZlcmVkIGl0c2VsZlxuICAgICAgICAgICAgICBpZiAoaW50ZXJuYWwuaG92ZXJlZC5zaXplICYmIEFycmF5LmZyb20oaW50ZXJuYWwuaG92ZXJlZC52YWx1ZXMoKSkuZmluZChpID0+IGkuZXZlbnRPYmplY3QgPT09IGhpdC5ldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBPYmplY3RzIGNhbm5vdCBmbHVzaCBvdXQgaGlnaGVyIHVwIG9iamVjdHMgdGhhdCBoYXZlIGFscmVhZHkgY2F1Z2h0IHRoZSBldmVudFxuICAgICAgICAgICAgICAgIGNvbnN0IGhpZ2hlciA9IGludGVyc2VjdGlvbnMuc2xpY2UoMCwgaW50ZXJzZWN0aW9ucy5pbmRleE9mKGhpdCkpO1xuICAgICAgICAgICAgICAgIGNhbmNlbFBvaW50ZXIoWy4uLmhpZ2hlciwgaGl0XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIHRoZXJlIHNob3VsZCBiZSBhIGRpc3RpbmN0aW9uIGJldHdlZW4gdGFyZ2V0IGFuZCBjdXJyZW50VGFyZ2V0XG4gICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICBoYXNQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHNldFBvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgcmVsZWFzZVBvaW50ZXJDYXB0dXJlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB7XG4gICAgICAgICAgICBoYXNQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHNldFBvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgcmVsZWFzZVBvaW50ZXJDYXB0dXJlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYXRpdmVFdmVudDogZXZlbnRcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDYWxsIHN1YnNjcmliZXJzXG4gICAgICAgIGNhbGxiYWNrKHJheWNhc3RFdmVudCk7XG4gICAgICAgIC8vIEV2ZW50IGJ1YmJsaW5nIG1heSBiZSBpbnRlcnJ1cHRlZCBieSBzdG9wUHJvcGFnYXRpb25cbiAgICAgICAgaWYgKGxvY2FsU3RhdGUuc3RvcHBlZCA9PT0gdHJ1ZSkgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9XG4gIGZ1bmN0aW9uIGNhbmNlbFBvaW50ZXIoaW50ZXJzZWN0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVybmFsXG4gICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgZm9yIChjb25zdCBob3ZlcmVkT2JqIG9mIGludGVybmFsLmhvdmVyZWQudmFsdWVzKCkpIHtcbiAgICAgIC8vIFdoZW4gbm8gb2JqZWN0cyB3ZXJlIGhpdCBvciB0aGUgdGhlIGhvdmVyZWQgb2JqZWN0IHdhc24ndCBmb3VuZCB1bmRlcm5lYXRoIHRoZSBjdXJzb3JcbiAgICAgIC8vIHdlIGNhbGwgb25Qb2ludGVyT3V0IGFuZCBkZWxldGUgdGhlIG9iamVjdCBmcm9tIHRoZSBob3ZlcmVkLWVsZW1lbnRzIG1hcFxuICAgICAgaWYgKCFpbnRlcnNlY3Rpb25zLmxlbmd0aCB8fCAhaW50ZXJzZWN0aW9ucy5maW5kKGhpdCA9PiBoaXQub2JqZWN0ID09PSBob3ZlcmVkT2JqLm9iamVjdCAmJiBoaXQuaW5kZXggPT09IGhvdmVyZWRPYmouaW5kZXggJiYgaGl0Lmluc3RhbmNlSWQgPT09IGhvdmVyZWRPYmouaW5zdGFuY2VJZCkpIHtcbiAgICAgICAgY29uc3QgZXZlbnRPYmplY3QgPSBob3ZlcmVkT2JqLmV2ZW50T2JqZWN0O1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGV2ZW50T2JqZWN0Ll9fcjNmO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycztcbiAgICAgICAgaW50ZXJuYWwuaG92ZXJlZC5kZWxldGUobWFrZUlkKGhvdmVyZWRPYmopKTtcbiAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwgJiYgaW5zdGFuY2UuZXZlbnRDb3VudCkge1xuICAgICAgICAgIC8vIENsZWFyIG91dCBpbnRlcnNlY3RzLCB0aGV5IGFyZSBvdXRkYXRlZCBieSBub3dcbiAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgLi4uaG92ZXJlZE9iaixcbiAgICAgICAgICAgIGludGVyc2VjdGlvbnNcbiAgICAgICAgICB9O1xuICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck91dCA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyT3V0KGRhdGEpO1xuICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlckxlYXZlID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwb2ludGVyTWlzc2VkKGV2ZW50LCBvYmplY3RzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IG9iamVjdHNbaV0uX19yM2Y7XG4gICAgICBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnMub25Qb2ludGVyTWlzc2VkID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycy5vblBvaW50ZXJNaXNzZWQoZXZlbnQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVQb2ludGVyKG5hbWUpIHtcbiAgICAvLyBEZWFsIHdpdGggY2FuY2VsYXRpb25cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ29uUG9pbnRlckxlYXZlJzpcbiAgICAgIGNhc2UgJ29uUG9pbnRlckNhbmNlbCc6XG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxQb2ludGVyKFtdKTtcbiAgICAgIGNhc2UgJ29uTG9zdFBvaW50ZXJDYXB0dXJlJzpcbiAgICAgICAgcmV0dXJuIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBpbnRlcm5hbFxuICAgICAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGlmICgncG9pbnRlcklkJyBpbiBldmVudCAmJiBpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBldmVudCBpbnRlcmZhY2UgaGFkIG9uTG9zdFBvaW50ZXJDYXB0dXJlLCB3ZSdkIGNhbGwgaXQgaGVyZSBvbiBldmVyeVxuICAgICAgICAgICAgLy8gb2JqZWN0IHRoYXQncyBnZXR0aW5nIHJlbW92ZWQuIFdlIGNhbGwgaXQgb24gdGhlIG5leHQgZnJhbWUgYmVjYXVzZSBvbkxvc3RQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgICAgLy8gZmlyZXMgYmVmb3JlIG9uUG9pbnRlclVwLiBPdGhlcndpc2UgcG9pbnRlclVwIHdvdWxkIG5ldmVyIGJlIGNhbGxlZCBpZiB0aGUgZXZlbnQgZGlkbid0XG4gICAgICAgICAgICAvLyBoYXBwZW4gaW4gdGhlIG9iamVjdCBpdCBvcmlnaW5hdGVkIGZyb20sIGxlYXZpbmcgY29tcG9uZW50cyBpbiBhIGluLWJldHdlZW4gc3RhdGUuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAvLyBPbmx5IHJlbGVhc2UgaWYgcG9pbnRlci11cCBkaWRuJ3QgZG8gaXQgYWxyZWFkeVxuICAgICAgICAgICAgICBpZiAoaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5kZWxldGUoZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxQb2ludGVyKFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEFueSBvdGhlciBwb2ludGVyIGdvZXMgaGVyZSAuLi5cbiAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkLFxuICAgICAgICBpbnRlcm5hbFxuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIC8vIHByZXBhcmVSYXkoZXZlbnQpXG4gICAgICBpbnRlcm5hbC5sYXN0RXZlbnQuY3VycmVudCA9IGV2ZW50O1xuXG4gICAgICAvLyBHZXQgZnJlc2ggaW50ZXJzZWN0c1xuICAgICAgY29uc3QgaXNQb2ludGVyTW92ZSA9IG5hbWUgPT09ICdvblBvaW50ZXJNb3ZlJztcbiAgICAgIGNvbnN0IGlzQ2xpY2tFdmVudCA9IG5hbWUgPT09ICdvbkNsaWNrJyB8fCBuYW1lID09PSAnb25Db250ZXh0TWVudScgfHwgbmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snO1xuICAgICAgY29uc3QgZmlsdGVyID0gaXNQb2ludGVyTW92ZSA/IGZpbHRlclBvaW50ZXJFdmVudHMgOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBoaXRzID0gaW50ZXJzZWN0KGV2ZW50LCBmaWx0ZXIpO1xuICAgICAgY29uc3QgZGVsdGEgPSBpc0NsaWNrRXZlbnQgPyBjYWxjdWxhdGVEaXN0YW5jZShldmVudCkgOiAwO1xuXG4gICAgICAvLyBTYXZlIGluaXRpYWwgY29vcmRpbmF0ZXMgb24gcG9pbnRlci1kb3duXG4gICAgICBpZiAobmFtZSA9PT0gJ29uUG9pbnRlckRvd24nKSB7XG4gICAgICAgIGludGVybmFsLmluaXRpYWxDbGljayA9IFtldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZXTtcbiAgICAgICAgaW50ZXJuYWwuaW5pdGlhbEhpdHMgPSBoaXRzLm1hcChoaXQgPT4gaGl0LmV2ZW50T2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYSBjbGljayB5aWVsZHMgbm8gcmVzdWx0cywgcGFzcyBpdCBiYWNrIHRvIHRoZSB1c2VyIGFzIGEgbWlzc1xuICAgICAgLy8gTWlzc2VkIGV2ZW50cyBoYXZlIHRvIGNvbWUgZmlyc3QgaW4gb3JkZXIgdG8gZXN0YWJsaXNoIHVzZXItbGFuZCBzaWRlLWVmZmVjdCBjbGVhbiB1cFxuICAgICAgaWYgKGlzQ2xpY2tFdmVudCAmJiAhaGl0cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGRlbHRhIDw9IDIpIHtcbiAgICAgICAgICBwb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbik7XG4gICAgICAgICAgaWYgKG9uUG9pbnRlck1pc3NlZCkgb25Qb2ludGVyTWlzc2VkKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVGFrZSBjYXJlIG9mIHVuaG92ZXJcbiAgICAgIGlmIChpc1BvaW50ZXJNb3ZlKSBjYW5jZWxQb2ludGVyKGhpdHMpO1xuICAgICAgZnVuY3Rpb24gb25JbnRlcnNlY3QoZGF0YSkge1xuICAgICAgICBjb25zdCBldmVudE9iamVjdCA9IGRhdGEuZXZlbnRPYmplY3Q7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZXZlbnRPYmplY3QuX19yM2Y7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzO1xuXG4gICAgICAgIC8vIENoZWNrIHByZXNlbmNlIG9mIGhhbmRsZXJzXG4gICAgICAgIGlmICghKGluc3RhbmNlICE9IG51bGwgJiYgaW5zdGFuY2UuZXZlbnRDb3VudCkpIHJldHVybjtcblxuICAgICAgICAvKlxyXG4gICAgICAgIE1BWUJFIFRPRE8sIERFTEVURSBJRiBOT1Q6IFxyXG4gICAgICAgICAgQ2hlY2sgaWYgdGhlIG9iamVjdCBpcyBjYXB0dXJlZCwgY2FwdHVyZWQgZXZlbnRzIHNob3VsZCBub3QgaGF2ZSBpbnRlcnNlY3RzIHJ1bm5pbmcgaW4gcGFyYWxsZWxcclxuICAgICAgICAgIEJ1dCB3b3VsZG4ndCBpdCBiZSBiZXR0ZXIgdG8ganVzdCByZXBsYWNlIGNhcHR1cmVkTWFwIHdpdGggYSBzaW5nbGUgZW50cnk/XHJcbiAgICAgICAgICBBbHNvLCBhcmUgd2UgT0sgd2l0aCBzdHJhaWdodCB1cCBtYWtpbmcgcGlja2luZyB1cCBtdWx0aXBsZSBvYmplY3RzIGltcG9zc2libGU/XHJcbiAgICAgICAgICBcclxuICAgICAgICBjb25zdCBwb2ludGVySWQgPSAoZGF0YSBhcyBUaHJlZUV2ZW50PFBvaW50ZXJFdmVudD4pLnBvaW50ZXJJZCAgICAgICAgXHJcbiAgICAgICAgaWYgKHBvaW50ZXJJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBjb25zdCBjYXB0dXJlZE1lc2hTZXQgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQocG9pbnRlcklkKVxyXG4gICAgICAgICAgaWYgKGNhcHR1cmVkTWVzaFNldCkge1xyXG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlZCA9IGNhcHR1cmVkTWVzaFNldC5nZXQoZXZlbnRPYmplY3QpXHJcbiAgICAgICAgICAgIGlmIChjYXB0dXJlZCAmJiBjYXB0dXJlZC5sb2NhbFN0YXRlLnN0b3BwZWQpIHJldHVyblxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0qL1xuXG4gICAgICAgIGlmIChpc1BvaW50ZXJNb3ZlKSB7XG4gICAgICAgICAgLy8gTW92ZSBldmVudCAuLi5cbiAgICAgICAgICBpZiAoaGFuZGxlcnMub25Qb2ludGVyT3ZlciB8fCBoYW5kbGVycy5vblBvaW50ZXJFbnRlciB8fCBoYW5kbGVycy5vblBvaW50ZXJPdXQgfHwgaGFuZGxlcnMub25Qb2ludGVyTGVhdmUpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZW50ZXIgb3Igb3V0IGlzIHByZXNlbnQgdGFrZSBjYXJlIG9mIGhvdmVyLXN0YXRlXG4gICAgICAgICAgICBjb25zdCBpZCA9IG1ha2VJZChkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gaW50ZXJuYWwuaG92ZXJlZC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKCFob3ZlcmVkSXRlbSkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhc24ndCBwcmV2aW91c2x5IGhvdmVyZWQsIGJvb2sgaXQgYW5kIGNhbGwgaXRzIGhhbmRsZXJcbiAgICAgICAgICAgICAgaW50ZXJuYWwuaG92ZXJlZC5zZXQoaWQsIGRhdGEpO1xuICAgICAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJPdmVyID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJPdmVyKGRhdGEpO1xuICAgICAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJFbnRlciA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyRW50ZXIoZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCB3YXMgcHJldmlvdXNseSBob3ZlcmVkIGFuZCBzdG9wcGVkLCB3ZSBzaG91bGRuJ3QgYWxsb3cgb3RoZXIgaXRlbXMgdG8gcHJvY2VlZFxuICAgICAgICAgICAgICBkYXRhLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIG1vdXNlIG1vdmVcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJNb3ZlID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJNb3ZlKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFsbCBvdGhlciBldmVudHMgLi4uXG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW25hbWVdO1xuICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAvLyBGb3J3YXJkIGFsbCBldmVudHMgYmFjayB0byB0aGVpciByZXNwZWN0aXZlIGhhbmRsZXJzIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBjbGljayBldmVudHMsXG4gICAgICAgICAgICAvLyB3aGljaCBtdXN0IHVzZSB0aGUgaW5pdGlhbCB0YXJnZXRcbiAgICAgICAgICAgIGlmICghaXNDbGlja0V2ZW50IHx8IGludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKGV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAvLyBNaXNzZWQgZXZlbnRzIGhhdmUgdG8gY29tZSBmaXJzdFxuICAgICAgICAgICAgICBwb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbi5maWx0ZXIob2JqZWN0ID0+ICFpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhvYmplY3QpKSk7XG4gICAgICAgICAgICAgIC8vIE5vdyBjYWxsIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICAgIGhhbmRsZXIoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgb25Qb2ludGVyTWlzc2VkIG9uIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgcG9pbnRlciBvdmVyL291dCBoYW5kbGVycywgYnV0IG5vdCBjbGljayBhbmQgd2VyZW4ndCBoaXRcbiAgICAgICAgICAgIGlmIChpc0NsaWNrRXZlbnQgJiYgaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMoZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvYmplY3QgPT4gIWludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKG9iamVjdCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhhbmRsZUludGVyc2VjdHMoaGl0cywgZXZlbnQsIGRlbHRhLCBvbkludGVyc2VjdCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhhbmRsZVBvaW50ZXJcbiAgfTtcbn1cblxuLy8gS2V5cyB0aGF0IHNob3VsZG4ndCBiZSBjb3BpZWQgYmV0d2VlbiBSM0Ygc3RvcmVzXG5jb25zdCBwcml2YXRlS2V5cyA9IFsnc2V0JywgJ2dldCcsICdzZXRTaXplJywgJ3NldEZyYW1lbG9vcCcsICdzZXREcHInLCAnZXZlbnRzJywgJ2ludmFsaWRhdGUnLCAnYWR2YW5jZScsICdzaXplJywgJ3ZpZXdwb3J0J107XG5jb25zdCBpc1JlbmRlcmVyID0gZGVmID0+ICEhKGRlZiAhPSBudWxsICYmIGRlZi5yZW5kZXIpO1xuY29uc3QgY29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoaW52YWxpZGF0ZSwgYWR2YW5jZSkgPT4ge1xuICBjb25zdCByb290U3RhdGUgPSBjcmVhdGUoKHNldCwgZ2V0KSA9PiB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGNvbnN0IGRlZmF1bHRUYXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGNvbnN0IHRlbXBUYXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEgPSBnZXQoKS5jYW1lcmEsIHRhcmdldCA9IGRlZmF1bHRUYXJnZXQsIHNpemUgPSBnZXQoKS5zaXplKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHRvcCxcbiAgICAgICAgbGVmdFxuICAgICAgfSA9IHNpemU7XG4gICAgICBjb25zdCBhc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcbiAgICAgIGlmICh0YXJnZXQuaXNWZWN0b3IzKSB0ZW1wVGFyZ2V0LmNvcHkodGFyZ2V0KTtlbHNlIHRlbXBUYXJnZXQuc2V0KC4uLnRhcmdldCk7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGNhbWVyYS5nZXRXb3JsZFBvc2l0aW9uKHBvc2l0aW9uKS5kaXN0YW5jZVRvKHRlbXBUYXJnZXQpO1xuICAgICAgaWYgKGlzT3J0aG9ncmFwaGljQ2FtZXJhKGNhbWVyYSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogd2lkdGggLyBjYW1lcmEuem9vbSxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAvIGNhbWVyYS56b29tLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIGZhY3RvcjogMSxcbiAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICBhc3BlY3RcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZvdiA9IGNhbWVyYS5mb3YgKiBNYXRoLlBJIC8gMTgwOyAvLyBjb252ZXJ0IHZlcnRpY2FsIGZvdiB0byByYWRpYW5zXG4gICAgICAgIGNvbnN0IGggPSAyICogTWF0aC50YW4oZm92IC8gMikgKiBkaXN0YW5jZTsgLy8gdmlzaWJsZSBoZWlnaHRcbiAgICAgICAgY29uc3QgdyA9IGggKiAod2lkdGggLyBoZWlnaHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICBmYWN0b3I6IHdpZHRoIC8gdyxcbiAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICBhc3BlY3RcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHBlcmZvcm1hbmNlVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzZXRQZXJmb3JtYW5jZUN1cnJlbnQgPSBjdXJyZW50ID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgLi4uc3RhdGUucGVyZm9ybWFuY2UsXG4gICAgICAgIGN1cnJlbnRcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcG9pbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgY29uc3Qgcm9vdFN0YXRlID0ge1xuICAgICAgc2V0LFxuICAgICAgZ2V0LFxuICAgICAgLy8gTW9jayBvYmplY3RzIHRoYXQgaGF2ZSB0byBiZSBjb25maWd1cmVkXG4gICAgICBnbDogbnVsbCxcbiAgICAgIGNhbWVyYTogbnVsbCxcbiAgICAgIHJheWNhc3RlcjogbnVsbCxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBwcmlvcml0eTogMSxcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgY29ubmVjdGVkOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHhyOiBudWxsLFxuICAgICAgc2NlbmU6IG51bGwsXG4gICAgICBpbnZhbGlkYXRlOiAoZnJhbWVzID0gMSkgPT4gaW52YWxpZGF0ZShnZXQoKSwgZnJhbWVzKSxcbiAgICAgIGFkdmFuY2U6ICh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMpID0+IGFkdmFuY2UodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzLCBnZXQoKSksXG4gICAgICBsZWdhY3k6IGZhbHNlLFxuICAgICAgbGluZWFyOiBmYWxzZSxcbiAgICAgIGZsYXQ6IGZhbHNlLFxuICAgICAgY29udHJvbHM6IG51bGwsXG4gICAgICBjbG9jazogbmV3IFRIUkVFLkNsb2NrKCksXG4gICAgICBwb2ludGVyLFxuICAgICAgbW91c2U6IHBvaW50ZXIsXG4gICAgICBmcmFtZWxvb3A6ICdhbHdheXMnLFxuICAgICAgb25Qb2ludGVyTWlzc2VkOiB1bmRlZmluZWQsXG4gICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICBjdXJyZW50OiAxLFxuICAgICAgICBtaW46IDAuNSxcbiAgICAgICAgbWF4OiAxLFxuICAgICAgICBkZWJvdW5jZTogMjAwLFxuICAgICAgICByZWdyZXNzOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgICAvLyBDbGVhciB0aW1lb3V0XG4gICAgICAgICAgaWYgKHBlcmZvcm1hbmNlVGltZW91dCkgY2xlYXJUaW1lb3V0KHBlcmZvcm1hbmNlVGltZW91dCk7XG4gICAgICAgICAgLy8gU2V0IGxvd2VyIGJvdW5kIHBlcmZvcm1hbmNlXG4gICAgICAgICAgaWYgKHN0YXRlLnBlcmZvcm1hbmNlLmN1cnJlbnQgIT09IHN0YXRlLnBlcmZvcm1hbmNlLm1pbikgc2V0UGVyZm9ybWFuY2VDdXJyZW50KHN0YXRlLnBlcmZvcm1hbmNlLm1pbik7XG4gICAgICAgICAgLy8gR28gYmFjayB0byB1cHBlciBib3VuZCBwZXJmb3JtYW5jZSBhZnRlciBhIHdoaWxlIHVubGVzcyBzb21ldGhpbmcgcmVncmVzc2VzIG1lYW53aGlsZVxuICAgICAgICAgIHBlcmZvcm1hbmNlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gc2V0UGVyZm9ybWFuY2VDdXJyZW50KGdldCgpLnBlcmZvcm1hbmNlLm1heCksIHN0YXRlLnBlcmZvcm1hbmNlLmRlYm91bmNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB1cGRhdGVTdHlsZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICBpbml0aWFsRHByOiAwLFxuICAgICAgICBkcHI6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYXNwZWN0OiAwLFxuICAgICAgICBkaXN0YW5jZTogMCxcbiAgICAgICAgZmFjdG9yOiAwLFxuICAgICAgICBnZXRDdXJyZW50Vmlld3BvcnRcbiAgICAgIH0sXG4gICAgICBzZXRFdmVudHM6IGV2ZW50cyA9PiBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICAuLi5ldmVudHNcbiAgICAgICAgfVxuICAgICAgfSkpLFxuICAgICAgc2V0U2l6ZTogKHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlLCB0b3AsIGxlZnQpID0+IHtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gZ2V0KCkuY2FtZXJhO1xuICAgICAgICBjb25zdCBzaXplID0ge1xuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICB0b3A6IHRvcCB8fCAwLFxuICAgICAgICAgIGxlZnQ6IGxlZnQgfHwgMCxcbiAgICAgICAgICB1cGRhdGVTdHlsZVxuICAgICAgICB9O1xuICAgICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgICAgIC4uLmdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEsIGRlZmF1bHRUYXJnZXQsIHNpemUpXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgc2V0RHByOiBkcHIgPT4gc2V0KHN0YXRlID0+IHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBjYWxjdWxhdGVEcHIoZHByKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgICBkcHI6IHJlc29sdmVkLFxuICAgICAgICAgICAgaW5pdGlhbERwcjogc3RhdGUudmlld3BvcnQuaW5pdGlhbERwciB8fCByZXNvbHZlZFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgc2V0RnJhbWVsb29wOiAoZnJhbWVsb29wID0gJ2Fsd2F5cycpID0+IHtcbiAgICAgICAgY29uc3QgY2xvY2sgPSBnZXQoKS5jbG9jaztcblxuICAgICAgICAvLyBpZiBmcmFtZWxvb3AgPT09IFwibmV2ZXJcIiBjbG9jay5lbGFwc2VkVGltZSBpcyB1cGRhdGVkIHVzaW5nIGFkdmFuY2UodGltZXN0YW1wKVxuICAgICAgICBjbG9jay5zdG9wKCk7XG4gICAgICAgIGNsb2NrLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgaWYgKGZyYW1lbG9vcCAhPT0gJ25ldmVyJykge1xuICAgICAgICAgIGNsb2NrLnN0YXJ0KCk7XG4gICAgICAgICAgY2xvY2suZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHNldCgoKSA9PiAoe1xuICAgICAgICAgIGZyYW1lbG9vcFxuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgcHJldmlvdXNSb290OiB1bmRlZmluZWQsXG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICBwcmlvcml0eTogMCxcbiAgICAgICAgZnJhbWVzOiAwLFxuICAgICAgICBsYXN0RXZlbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVSZWYoKSxcbiAgICAgICAgaW50ZXJhY3Rpb246IFtdLFxuICAgICAgICBob3ZlcmVkOiBuZXcgTWFwKCksXG4gICAgICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICAgICAgaW5pdGlhbENsaWNrOiBbMCwgMF0sXG4gICAgICAgIGluaXRpYWxIaXRzOiBbXSxcbiAgICAgICAgY2FwdHVyZWRNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgc3Vic2NyaWJlOiAocmVmLCBwcmlvcml0eSwgc3RvcmUpID0+IHtcbiAgICAgICAgICBjb25zdCBpbnRlcm5hbCA9IGdldCgpLmludGVybmFsO1xuICAgICAgICAgIC8vIElmIHRoaXMgc3Vic2NyaXB0aW9uIHdhcyBnaXZlbiBhIHByaW9yaXR5LCBpdCB0YWtlcyByZW5kZXJpbmcgaW50byBpdHMgb3duIGhhbmRzXG4gICAgICAgICAgLy8gRm9yIHRoYXQgcmVhc29uIHdlIHN3aXRjaCBvZmYgYXV0b21hdGljIHJlbmRlcmluZyBhbmQgaW5jcmVhc2UgdGhlIG1hbnVhbCBmbGFnXG4gICAgICAgICAgLy8gQXMgbG9uZyBhcyB0aGlzIGZsYWcgaXMgcG9zaXRpdmUgdGhlcmUgY2FuIGJlIG5vIGludGVybmFsIHJlbmRlcmluZyBhdCBhbGxcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIHJlbmRlciBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgaW50ZXJuYWwucHJpb3JpdHkgPSBpbnRlcm5hbC5wcmlvcml0eSArIChwcmlvcml0eSA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMucHVzaCh7XG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgIHN0b3JlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gUmVnaXN0ZXIgc3Vic2NyaWJlciBhbmQgc29ydCBsYXllcnMgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdCwgbWVhbmluZyxcbiAgICAgICAgICAvLyBoaWdoZXN0IHByaW9yaXR5IHJlbmRlcnMgbGFzdCAob24gdG9wIG9mIHRoZSBvdGhlciBmcmFtZXMpXG4gICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMgPSBpbnRlcm5hbC5zdWJzY3JpYmVycy5zb3J0KChhLCBiKSA9PiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVybmFsID0gZ2V0KCkuaW50ZXJuYWw7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWwgIT0gbnVsbCAmJiBpbnRlcm5hbC5zdWJzY3JpYmVycykge1xuICAgICAgICAgICAgICAvLyBEZWNyZWFzZSBtYW51YWwgZmxhZyBpZiB0aGlzIHN1YnNjcmlwdGlvbiBoYWQgYSBwcmlvcml0eVxuICAgICAgICAgICAgICBpbnRlcm5hbC5wcmlvcml0eSA9IGludGVybmFsLnByaW9yaXR5IC0gKHByaW9yaXR5ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXIgZnJvbSBsaXN0XG4gICAgICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzID0gaW50ZXJuYWwuc3Vic2NyaWJlcnMuZmlsdGVyKHMgPT4gcy5yZWYgIT09IHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJvb3RTdGF0ZTtcbiAgfSk7XG4gIGNvbnN0IHN0YXRlID0gcm9vdFN0YXRlLmdldFN0YXRlKCk7XG4gIGxldCBvbGRTaXplID0gc3RhdGUuc2l6ZTtcbiAgbGV0IG9sZERwciA9IHN0YXRlLnZpZXdwb3J0LmRwcjtcbiAgbGV0IG9sZENhbWVyYSA9IHN0YXRlLmNhbWVyYTtcbiAgcm9vdFN0YXRlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2FtZXJhLFxuICAgICAgc2l6ZSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgZ2wsXG4gICAgICBzZXRcbiAgICB9ID0gcm9vdFN0YXRlLmdldFN0YXRlKCk7XG5cbiAgICAvLyBSZXNpemUgY2FtZXJhIGFuZCByZW5kZXJlciBvbiBjaGFuZ2VzIHRvIHNpemUgYW5kIHBpeGVscmF0aW9cbiAgICBpZiAoc2l6ZS53aWR0aCAhPT0gb2xkU2l6ZS53aWR0aCB8fCBzaXplLmhlaWdodCAhPT0gb2xkU2l6ZS5oZWlnaHQgfHwgdmlld3BvcnQuZHByICE9PSBvbGREcHIpIHtcbiAgICAgIHZhciBfc2l6ZSR1cGRhdGVTdHlsZTtcbiAgICAgIG9sZFNpemUgPSBzaXplO1xuICAgICAgb2xkRHByID0gdmlld3BvcnQuZHByO1xuICAgICAgLy8gVXBkYXRlIGNhbWVyYSAmIHJlbmRlcmVyXG4gICAgICB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKTtcbiAgICAgIGdsLnNldFBpeGVsUmF0aW8odmlld3BvcnQuZHByKTtcbiAgICAgIGNvbnN0IHVwZGF0ZVN0eWxlID0gKF9zaXplJHVwZGF0ZVN0eWxlID0gc2l6ZS51cGRhdGVTdHlsZSkgIT0gbnVsbCA/IF9zaXplJHVwZGF0ZVN0eWxlIDogdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBnbC5kb21FbGVtZW50IGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgICBnbC5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB1cGRhdGVTdHlsZSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHZpZXdwb3J0IG9uY2UgdGhlIGNhbWVyYSBjaGFuZ2VzXG4gICAgaWYgKGNhbWVyYSAhPT0gb2xkQ2FtZXJhKSB7XG4gICAgICBvbGRDYW1lcmEgPSBjYW1lcmE7XG4gICAgICAvLyBVcGRhdGUgdmlld3BvcnRcbiAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LmdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEpXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEludmFsaWRhdGUgb24gYW55IGNoYW5nZVxuICByb290U3RhdGUuc3Vic2NyaWJlKHN0YXRlID0+IGludmFsaWRhdGUoc3RhdGUpKTtcblxuICAvLyBSZXR1cm4gcm9vdCBzdGF0ZVxuICByZXR1cm4gcm9vdFN0YXRlO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlU3VicyhjYWxsYmFjaywgc3Vicykge1xuICBjb25zdCBzdWIgPSB7XG4gICAgY2FsbGJhY2tcbiAgfTtcbiAgc3Vicy5hZGQoc3ViKTtcbiAgcmV0dXJuICgpID0+IHZvaWQgc3Vicy5kZWxldGUoc3ViKTtcbn1cbmxldCBpO1xubGV0IGdsb2JhbEVmZmVjdHMgPSBuZXcgU2V0KCk7XG5sZXQgZ2xvYmFsQWZ0ZXJFZmZlY3RzID0gbmV3IFNldCgpO1xubGV0IGdsb2JhbFRhaWxFZmZlY3RzID0gbmV3IFNldCgpO1xuXG4vKipcclxuICogQWRkcyBhIGdsb2JhbCByZW5kZXIgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGVhY2ggZnJhbWUuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRFZmZlY3RcclxuICovXG5jb25zdCBhZGRFZmZlY3QgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxFZmZlY3RzKTtcblxuLyoqXHJcbiAqIEFkZHMgYSBnbG9iYWwgYWZ0ZXItcmVuZGVyIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBlYWNoIGZyYW1lLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkQWZ0ZXJFZmZlY3RcclxuICovXG5jb25zdCBhZGRBZnRlckVmZmVjdCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbEFmdGVyRWZmZWN0cyk7XG5cbi8qKlxyXG4gKiBBZGRzIGEgZ2xvYmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHJlbmRlcmluZyBzdG9wcy5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZFRhaWxcclxuICovXG5jb25zdCBhZGRUYWlsID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsVGFpbEVmZmVjdHMpO1xuZnVuY3Rpb24gcnVuKGVmZmVjdHMsIHRpbWVzdGFtcCkge1xuICBpZiAoIWVmZmVjdHMuc2l6ZSkgcmV0dXJuO1xuICBmb3IgKGNvbnN0IHtcbiAgICBjYWxsYmFja1xuICB9IG9mIGVmZmVjdHMudmFsdWVzKCkpIHtcbiAgICBjYWxsYmFjayh0aW1lc3RhbXApO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaEdsb2JhbEVmZmVjdHModHlwZSwgdGltZXN0YW1wKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2JlZm9yZSc6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbEVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gICAgY2FzZSAnYWZ0ZXInOlxuICAgICAgcmV0dXJuIHJ1bihnbG9iYWxBZnRlckVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gICAgY2FzZSAndGFpbCc6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbFRhaWxFZmZlY3RzLCB0aW1lc3RhbXApO1xuICB9XG59XG5sZXQgc3Vic2NyaWJlcnM7XG5sZXQgc3Vic2NyaXB0aW9uO1xuZnVuY3Rpb24gcmVuZGVyJDEodGltZXN0YW1wLCBzdGF0ZSwgZnJhbWUpIHtcbiAgLy8gUnVuIGxvY2FsIGVmZmVjdHNcbiAgbGV0IGRlbHRhID0gc3RhdGUuY2xvY2suZ2V0RGVsdGEoKTtcbiAgLy8gSW4gZnJhbWVsb29wPSduZXZlcicgbW9kZSwgY2xvY2sgdGltZXMgYXJlIHVwZGF0ZWQgdXNpbmcgdGhlIHByb3ZpZGVkIHRpbWVzdGFtcFxuICBpZiAoc3RhdGUuZnJhbWVsb29wID09PSAnbmV2ZXInICYmIHR5cGVvZiB0aW1lc3RhbXAgPT09ICdudW1iZXInKSB7XG4gICAgZGVsdGEgPSB0aW1lc3RhbXAgLSBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZTtcbiAgICBzdGF0ZS5jbG9jay5vbGRUaW1lID0gc3RhdGUuY2xvY2suZWxhcHNlZFRpbWU7XG4gICAgc3RhdGUuY2xvY2suZWxhcHNlZFRpbWUgPSB0aW1lc3RhbXA7XG4gIH1cbiAgLy8gQ2FsbCBzdWJzY3JpYmVycyAodXNlRnJhbWUpXG4gIHN1YnNjcmliZXJzID0gc3RhdGUuaW50ZXJuYWwuc3Vic2NyaWJlcnM7XG4gIGZvciAoaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkrKykge1xuICAgIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZXJzW2ldO1xuICAgIHN1YnNjcmlwdGlvbi5yZWYuY3VycmVudChzdWJzY3JpcHRpb24uc3RvcmUuZ2V0U3RhdGUoKSwgZGVsdGEsIGZyYW1lKTtcbiAgfVxuICAvLyBSZW5kZXIgY29udGVudFxuICBpZiAoIXN0YXRlLmludGVybmFsLnByaW9yaXR5ICYmIHN0YXRlLmdsLnJlbmRlcikgc3RhdGUuZ2wucmVuZGVyKHN0YXRlLnNjZW5lLCBzdGF0ZS5jYW1lcmEpO1xuICAvLyBEZWNyZWFzZSBmcmFtZSBjb3VudFxuICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1heCgwLCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgLSAxKTtcbiAgcmV0dXJuIHN0YXRlLmZyYW1lbG9vcCA9PT0gJ2Fsd2F5cycgPyAxIDogc3RhdGUuaW50ZXJuYWwuZnJhbWVzO1xufVxuZnVuY3Rpb24gY3JlYXRlTG9vcChyb290cykge1xuICBsZXQgcnVubmluZyA9IGZhbHNlO1xuICBsZXQgdXNlRnJhbWVJblByb2dyZXNzID0gZmFsc2U7XG4gIGxldCByZXBlYXQ7XG4gIGxldCBmcmFtZTtcbiAgbGV0IHN0YXRlO1xuICBmdW5jdGlvbiBsb29wKHRpbWVzdGFtcCkge1xuICAgIGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIHJlcGVhdCA9IDA7XG5cbiAgICAvLyBSdW4gZWZmZWN0c1xuICAgIGZsdXNoR2xvYmFsRWZmZWN0cygnYmVmb3JlJywgdGltZXN0YW1wKTtcblxuICAgIC8vIFJlbmRlciBhbGwgcm9vdHNcbiAgICB1c2VGcmFtZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgIGZvciAoY29uc3Qgcm9vdCBvZiByb290cy52YWx1ZXMoKSkge1xuICAgICAgdmFyIF9zdGF0ZSRnbCR4cjtcbiAgICAgIHN0YXRlID0gcm9vdC5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgLy8gSWYgdGhlIGZyYW1lbG9vcCBpcyBpbnZhbGlkYXRlZCwgZG8gbm90IHJ1biBhbm90aGVyIGZyYW1lXG4gICAgICBpZiAoc3RhdGUuaW50ZXJuYWwuYWN0aXZlICYmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICdhbHdheXMnIHx8IHN0YXRlLmludGVybmFsLmZyYW1lcyA+IDApICYmICEoKF9zdGF0ZSRnbCR4ciA9IHN0YXRlLmdsLnhyKSAhPSBudWxsICYmIF9zdGF0ZSRnbCR4ci5pc1ByZXNlbnRpbmcpKSB7XG4gICAgICAgIHJlcGVhdCArPSByZW5kZXIkMSh0aW1lc3RhbXAsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXNlRnJhbWVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAvLyBSdW4gYWZ0ZXItZWZmZWN0c1xuICAgIGZsdXNoR2xvYmFsRWZmZWN0cygnYWZ0ZXInLCB0aW1lc3RhbXApO1xuXG4gICAgLy8gU3RvcCB0aGUgbG9vcCBpZiBub3RoaW5nIGludmFsaWRhdGVzIGl0XG4gICAgaWYgKHJlcGVhdCA9PT0gMCkge1xuICAgICAgLy8gVGFpbCBjYWxsIGVmZmVjdHMsIHRoZXkgYXJlIGNhbGxlZCB3aGVuIHJlbmRlcmluZyBzdG9wc1xuICAgICAgZmx1c2hHbG9iYWxFZmZlY3RzKCd0YWlsJywgdGltZXN0YW1wKTtcblxuICAgICAgLy8gRmxhZyBlbmQgb2Ygb3BlcmF0aW9uXG4gICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbnZhbGlkYXRlKHN0YXRlLCBmcmFtZXMgPSAxKSB7XG4gICAgdmFyIF9zdGF0ZSRnbCR4cjI7XG4gICAgaWYgKCFzdGF0ZSkgcmV0dXJuIHJvb3RzLmZvckVhY2gocm9vdCA9PiBpbnZhbGlkYXRlKHJvb3Quc3RvcmUuZ2V0U3RhdGUoKSwgZnJhbWVzKSk7XG4gICAgaWYgKChfc3RhdGUkZ2wkeHIyID0gc3RhdGUuZ2wueHIpICE9IG51bGwgJiYgX3N0YXRlJGdsJHhyMi5pc1ByZXNlbnRpbmcgfHwgIXN0YXRlLmludGVybmFsLmFjdGl2ZSB8fCBzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicpIHJldHVybjtcbiAgICBpZiAoZnJhbWVzID4gMSkge1xuICAgICAgLy8gbGVnYWN5IHN1cHBvcnQgZm9yIHBlb3BsZSB1c2luZyBmcmFtZXMgcGFyYW1ldGVyc1xuICAgICAgLy8gSW5jcmVhc2UgZnJhbWVzLCBkbyBub3QgZ28gaGlnaGVyIHRoYW4gNjBcbiAgICAgIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IE1hdGgubWluKDYwLCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgKyBmcmFtZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodXNlRnJhbWVJblByb2dyZXNzKSB7XG4gICAgICAgIC8vY2FsbGVkIGZyb20gd2l0aGluIGEgdXNlRnJhbWUsIGl0IG1lYW5zIHRoZSB1c2VyIHdhbnRzIGFuIGFkZGl0aW9uYWwgZnJhbWVcbiAgICAgICAgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vdGhlIHVzZXIgbmVlZCBhIG5ldyBmcmFtZSwgbm8gbmVlZCB0byBpbmNyZW1lbnQgZnVydGhlciB0aGFuIDFcbiAgICAgICAgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgcmVuZGVyLWxvb3AgaXNuJ3QgYWN0aXZlLCBzdGFydCBpdFxuICAgIGlmICghcnVubmluZykge1xuICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFkdmFuY2UodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzID0gdHJ1ZSwgc3RhdGUsIGZyYW1lKSB7XG4gICAgaWYgKHJ1bkdsb2JhbEVmZmVjdHMpIGZsdXNoR2xvYmFsRWZmZWN0cygnYmVmb3JlJywgdGltZXN0YW1wKTtcbiAgICBpZiAoIXN0YXRlKSBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMudmFsdWVzKCkpIHJlbmRlciQxKHRpbWVzdGFtcCwgcm9vdC5zdG9yZS5nZXRTdGF0ZSgpKTtlbHNlIHJlbmRlciQxKHRpbWVzdGFtcCwgc3RhdGUsIGZyYW1lKTtcbiAgICBpZiAocnVuR2xvYmFsRWZmZWN0cykgZmx1c2hHbG9iYWxFZmZlY3RzKCdhZnRlcicsIHRpbWVzdGFtcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsb29wLFxuICAgIGludmFsaWRhdGUsXG4gICAgYWR2YW5jZVxuICB9O1xufVxuXG4vKipcclxuICogRXhwb3NlcyBhbiBvYmplY3QncyB7QGxpbmsgTG9jYWxTdGF0ZX0uXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyN1c2VJbnN0YW5jZUhhbmRsZVxyXG4gKlxyXG4gKiAqKk5vdGUqKjogdGhpcyBpcyBhbiBlc2NhcGUgaGF0Y2ggdG8gcmVhY3QtaW50ZXJuYWwgZmllbGRzLiBFeHBlY3QgdGhpcyB0byBjaGFuZ2Ugc2lnbmlmaWNhbnRseSBiZXR3ZWVuIHZlcnNpb25zLlxyXG4gKi9cbmZ1bmN0aW9uIHVzZUluc3RhbmNlSGFuZGxlKHJlZikge1xuICBjb25zdCBpbnN0YW5jZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB2b2lkIChpbnN0YW5jZS5jdXJyZW50ID0gcmVmLmN1cnJlbnQuX19yM2YpLCBbcmVmXSk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JlKCkge1xuICBjb25zdCBzdG9yZSA9IFJlYWN0LnVzZUNvbnRleHQoY29udGV4dCk7XG4gIGlmICghc3RvcmUpIHRocm93IG5ldyBFcnJvcignUjNGOiBIb29rcyBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiB0aGUgQ2FudmFzIGNvbXBvbmVudCEnKTtcbiAgcmV0dXJuIHN0b3JlO1xufVxuXG4vKipcclxuICogQWNjZXNzZXMgUjNGJ3MgaW50ZXJuYWwgc3RhdGUsIGNvbnRhaW5pbmcgcmVuZGVyZXIsIGNhbnZhcywgc2NlbmUsIGV0Yy5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNldGhyZWVcclxuICovXG5mdW5jdGlvbiB1c2VUaHJlZShzZWxlY3RvciA9IHN0YXRlID0+IHN0YXRlLCBlcXVhbGl0eUZuKSB7XG4gIHJldHVybiB1c2VTdG9yZSgpKHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbn1cblxuLyoqXHJcbiAqIEV4ZWN1dGVzIGEgY2FsbGJhY2sgYmVmb3JlIHJlbmRlciBpbiBhIHNoYXJlZCBmcmFtZSBsb29wLlxyXG4gKiBDYW4gb3JkZXIgZWZmZWN0cyB3aXRoIHJlbmRlciBwcmlvcml0eSBvciBtYW51YWxseSByZW5kZXIgd2l0aCBhIHBvc2l0aXZlIHByaW9yaXR5LlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2VmcmFtZVxyXG4gKi9cbmZ1bmN0aW9uIHVzZUZyYW1lKGNhbGxiYWNrLCByZW5kZXJQcmlvcml0eSA9IDApIHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSBzdG9yZS5nZXRTdGF0ZSgpLmludGVybmFsLnN1YnNjcmliZTtcbiAgLy8gTWVtb2l6ZSByZWZcbiAgY29uc3QgcmVmID0gdXNlTXV0YWJsZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgLy8gU3Vic2NyaWJlIG9uIG1vdW50LCB1bnN1YnNjcmliZSBvbiB1bm1vdW50XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gc3Vic2NyaWJlKHJlZiwgcmVuZGVyUHJpb3JpdHksIHN0b3JlKSwgW3JlbmRlclByaW9yaXR5LCBzdWJzY3JpYmUsIHN0b3JlXSk7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcclxuICogUmV0dXJucyBhIG5vZGUgZ3JhcGggb2YgYW4gb2JqZWN0IHdpdGggbmFtZWQgbm9kZXMgJiBtYXRlcmlhbHMuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZWdyYXBoXHJcbiAqL1xuZnVuY3Rpb24gdXNlR3JhcGgob2JqZWN0KSB7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGJ1aWxkR3JhcGgob2JqZWN0KSwgW29iamVjdF0pO1xufVxuY29uc3QgbWVtb2l6ZWRMb2FkZXJzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGxvYWRpbmdGbihleHRlbnNpb25zLCBvblByb2dyZXNzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoUHJvdG8sIC4uLmlucHV0KSB7XG4gICAgLy8gQ29uc3RydWN0IG5ldyBsb2FkZXIgYW5kIHJ1biBleHRlbnNpb25zXG4gICAgbGV0IGxvYWRlciA9IG1lbW9pemVkTG9hZGVycy5nZXQoUHJvdG8pO1xuICAgIGlmICghbG9hZGVyKSB7XG4gICAgICBsb2FkZXIgPSBuZXcgUHJvdG8oKTtcbiAgICAgIG1lbW9pemVkTG9hZGVycy5zZXQoUHJvdG8sIGxvYWRlcik7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb25zKSBleHRlbnNpb25zKGxvYWRlcik7XG4gICAgLy8gR28gdGhyb3VnaCB0aGUgdXJscyBhbmQgbG9hZCB0aGVtXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGlucHV0Lm1hcChpbnB1dCA9PiBuZXcgUHJvbWlzZSgocmVzLCByZWplY3QpID0+IGxvYWRlci5sb2FkKGlucHV0LCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnNjZW5lKSBPYmplY3QuYXNzaWduKGRhdGEsIGJ1aWxkR3JhcGgoZGF0YS5zY2VuZSkpO1xuICAgICAgcmVzKGRhdGEpO1xuICAgIH0sIG9uUHJvZ3Jlc3MsIGVycm9yID0+IHJlamVjdChuZXcgRXJyb3IoYENvdWxkIG5vdCBsb2FkICR7aW5wdXR9OiAke2Vycm9yID09IG51bGwgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlfWApKSkpKSk7XG4gIH07XG59XG4vKipcclxuICogU3luY2hyb25vdXNseSBsb2FkcyBhbmQgY2FjaGVzIGFzc2V0cyB3aXRoIGEgdGhyZWUgbG9hZGVyLlxyXG4gKlxyXG4gKiBOb3RlOiB0aGlzIGhvb2sncyBjYWxsZXIgbXVzdCBiZSB3cmFwcGVkIHdpdGggYFJlYWN0LlN1c3BlbnNlYFxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2Vsb2FkZXJcclxuICovXG5mdW5jdGlvbiB1c2VMb2FkZXIoUHJvdG8sIGlucHV0LCBleHRlbnNpb25zLCBvblByb2dyZXNzKSB7XG4gIC8vIFVzZSBzdXNwZW5zZSB0byBsb2FkIGFzeW5jIGFzc2V0c1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIGNvbnN0IHJlc3VsdHMgPSBzdXNwZW5kKGxvYWRpbmdGbihleHRlbnNpb25zLCBvblByb2dyZXNzKSwgW1Byb3RvLCAuLi5rZXlzXSwge1xuICAgIGVxdWFsOiBpcy5lcXVcbiAgfSk7XG4gIC8vIFJldHVybiB0aGUgb2JqZWN0L3NcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5wdXQpID8gcmVzdWx0cyA6IHJlc3VsdHNbMF07XG59XG5cbi8qKlxyXG4gKiBQcmVsb2FkcyBhbiBhc3NldCBpbnRvIGNhY2hlIGFzIGEgc2lkZS1lZmZlY3QuXHJcbiAqL1xudXNlTG9hZGVyLnByZWxvYWQgPSBmdW5jdGlvbiAoUHJvdG8sIGlucHV0LCBleHRlbnNpb25zKSB7XG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgcmV0dXJuIHByZWxvYWQobG9hZGluZ0ZuKGV4dGVuc2lvbnMpLCBbUHJvdG8sIC4uLmtleXNdKTtcbn07XG5cbi8qKlxyXG4gKiBSZW1vdmVzIGEgbG9hZGVkIGFzc2V0IGZyb20gY2FjaGUuXHJcbiAqL1xudXNlTG9hZGVyLmNsZWFyID0gZnVuY3Rpb24gKFByb3RvLCBpbnB1dCkge1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIHJldHVybiBjbGVhcihbUHJvdG8sIC4uLmtleXNdKTtcbn07XG5cbmNvbnN0IHJvb3RzID0gbmV3IE1hcCgpO1xuY29uc3Qge1xuICBpbnZhbGlkYXRlLFxuICBhZHZhbmNlXG59ID0gY3JlYXRlTG9vcChyb290cyk7XG5jb25zdCB7XG4gIHJlY29uY2lsZXIsXG4gIGFwcGx5UHJvcHNcbn0gPSBjcmVhdGVSZW5kZXJlcihyb290cywgZ2V0RXZlbnRQcmlvcml0eSk7XG5jb25zdCBzaGFsbG93TG9vc2UgPSB7XG4gIG9iamVjdHM6ICdzaGFsbG93JyxcbiAgc3RyaWN0OiBmYWxzZVxufTtcbmNvbnN0IGNyZWF0ZVJlbmRlcmVySW5zdGFuY2UgPSAoZ2wsIGNhbnZhcykgPT4ge1xuICBjb25zdCBjdXN0b21SZW5kZXJlciA9IHR5cGVvZiBnbCA9PT0gJ2Z1bmN0aW9uJyA/IGdsKGNhbnZhcykgOiBnbDtcbiAgaWYgKGlzUmVuZGVyZXIoY3VzdG9tUmVuZGVyZXIpKSByZXR1cm4gY3VzdG9tUmVuZGVyZXI7ZWxzZSByZXR1cm4gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgIHBvd2VyUHJlZmVyZW5jZTogJ2hpZ2gtcGVyZm9ybWFuY2UnLFxuICAgIGNhbnZhczogY2FudmFzLFxuICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICBhbHBoYTogdHJ1ZSxcbiAgICAuLi5nbFxuICB9KTtcbn07XG5mdW5jdGlvbiBjb21wdXRlSW5pdGlhbFNpemUoY2FudmFzLCBkZWZhdWx0U2l6ZSkge1xuICBjb25zdCBkZWZhdWx0U3R5bGUgPSB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50O1xuICBpZiAoZGVmYXVsdFNpemUpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICB1cGRhdGVTdHlsZSA9IGRlZmF1bHRTdHlsZVxuICAgIH0gPSBkZWZhdWx0U2l6ZTtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgdXBkYXRlU3R5bGVcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgJiYgY2FudmFzLnBhcmVudEVsZW1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnRcbiAgICB9ID0gY2FudmFzLnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHVwZGF0ZVN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHVwZGF0ZVN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSb290KGNhbnZhcykge1xuICAvLyBDaGVjayBhZ2FpbnN0IG1pc3Rha2VuIHVzZSBvZiBjcmVhdGVSb290XG4gIGNvbnN0IHByZXZSb290ID0gcm9vdHMuZ2V0KGNhbnZhcyk7XG4gIGNvbnN0IHByZXZGaWJlciA9IHByZXZSb290ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2Um9vdC5maWJlcjtcbiAgY29uc3QgcHJldlN0b3JlID0gcHJldlJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZSb290LnN0b3JlO1xuICBpZiAocHJldlJvb3QpIGNvbnNvbGUud2FybignUjNGLmNyZWF0ZVJvb3Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uY2UhJyk7XG5cbiAgLy8gUmVwb3J0IHdoZW4gYW4gZXJyb3Igd2FzIGRldGVjdGVkIGluIGEgcHJldmlvdXMgcmVuZGVyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yMjYxXG4gIGNvbnN0IGxvZ1JlY292ZXJhYmxlRXJyb3IgPSB0eXBlb2YgcmVwb3J0RXJyb3IgPT09ICdmdW5jdGlvbicgP1xuICAvLyBJbiBtb2Rlcm4gYnJvd3NlcnMsIHJlcG9ydEVycm9yIHdpbGwgZGlzcGF0Y2ggYW4gZXJyb3IgZXZlbnQsXG4gIC8vIGVtdWxhdGluZyBhbiB1bmNhdWdodCBKYXZhU2NyaXB0IGVycm9yLlxuICByZXBvcnRFcnJvciA6XG4gIC8vIEluIG9sZGVyIGJyb3dzZXJzIGFuZCB0ZXN0IGVudmlyb25tZW50cywgZmFsbGJhY2sgdG8gY29uc29sZS5lcnJvci5cbiAgY29uc29sZS5lcnJvcjtcblxuICAvLyBDcmVhdGUgc3RvcmVcbiAgY29uc3Qgc3RvcmUgPSBwcmV2U3RvcmUgfHwgY3JlYXRlU3RvcmUoaW52YWxpZGF0ZSwgYWR2YW5jZSk7XG4gIC8vIENyZWF0ZSByZW5kZXJlclxuICBjb25zdCBmaWJlciA9IHByZXZGaWJlciB8fCByZWNvbmNpbGVyLmNyZWF0ZUNvbnRhaW5lcihzdG9yZSwgQ29uY3VycmVudFJvb3QsIG51bGwsIGZhbHNlLCBudWxsLCAnJywgbG9nUmVjb3ZlcmFibGVFcnJvciwgbnVsbCk7XG4gIC8vIE1hcCBpdFxuICBpZiAoIXByZXZSb290KSByb290cy5zZXQoY2FudmFzLCB7XG4gICAgZmliZXIsXG4gICAgc3RvcmVcbiAgfSk7XG5cbiAgLy8gTG9jYWxzXG4gIGxldCBvbkNyZWF0ZWQ7XG4gIGxldCBjb25maWd1cmVkID0gZmFsc2U7XG4gIGxldCBsYXN0Q2FtZXJhO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyZShwcm9wcyA9IHt9KSB7XG4gICAgICBsZXQge1xuICAgICAgICBnbDogZ2xDb25maWcsXG4gICAgICAgIHNpemU6IHByb3BzU2l6ZSxcbiAgICAgICAgc2NlbmU6IHNjZW5lT3B0aW9ucyxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBvbkNyZWF0ZWQ6IG9uQ3JlYXRlZENhbGxiYWNrLFxuICAgICAgICBzaGFkb3dzID0gZmFsc2UsXG4gICAgICAgIGxpbmVhciA9IGZhbHNlLFxuICAgICAgICBmbGF0ID0gZmFsc2UsXG4gICAgICAgIGxlZ2FjeSA9IGZhbHNlLFxuICAgICAgICBvcnRob2dyYXBoaWMgPSBmYWxzZSxcbiAgICAgICAgZnJhbWVsb29wID0gJ2Fsd2F5cycsXG4gICAgICAgIGRwciA9IFsxLCAyXSxcbiAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgIHJheWNhc3RlcjogcmF5Y2FzdE9wdGlvbnMsXG4gICAgICAgIGNhbWVyYTogY2FtZXJhT3B0aW9ucyxcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkXG4gICAgICB9ID0gcHJvcHM7XG4gICAgICBsZXQgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBTZXQgdXAgcmVuZGVyZXIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgbGV0IGdsID0gc3RhdGUuZ2w7XG4gICAgICBpZiAoIXN0YXRlLmdsKSBzdGF0ZS5zZXQoe1xuICAgICAgICBnbDogZ2wgPSBjcmVhdGVSZW5kZXJlckluc3RhbmNlKGdsQ29uZmlnLCBjYW52YXMpXG4gICAgICB9KTtcblxuICAgICAgLy8gU2V0IHVwIHJheWNhc3RlciAob25lIHRpbWUgb25seSEpXG4gICAgICBsZXQgcmF5Y2FzdGVyID0gc3RhdGUucmF5Y2FzdGVyO1xuICAgICAgaWYgKCFyYXljYXN0ZXIpIHN0YXRlLnNldCh7XG4gICAgICAgIHJheWNhc3RlcjogcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpXG4gICAgICB9KTtcblxuICAgICAgLy8gU2V0IHJheWNhc3RlciBvcHRpb25zXG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSA9IHJheWNhc3RPcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKCFpcy5lcXUob3B0aW9ucywgcmF5Y2FzdGVyLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKHJheWNhc3Rlciwge1xuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KTtcbiAgICAgIGlmICghaXMuZXF1KHBhcmFtcywgcmF5Y2FzdGVyLnBhcmFtcywgc2hhbGxvd0xvb3NlKSkgYXBwbHlQcm9wcyhyYXljYXN0ZXIsIHtcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgLi4ucmF5Y2FzdGVyLnBhcmFtcyxcbiAgICAgICAgICAuLi5wYXJhbXNcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGNhbWVyYSwgZG9uJ3Qgb3ZlcndyaXRlIGFueSB1c2VyLXNldCBzdGF0ZVxuICAgICAgaWYgKCFzdGF0ZS5jYW1lcmEgfHwgc3RhdGUuY2FtZXJhID09PSBsYXN0Q2FtZXJhICYmICFpcy5lcXUobGFzdENhbWVyYSwgY2FtZXJhT3B0aW9ucywgc2hhbGxvd0xvb3NlKSkge1xuICAgICAgICBsYXN0Q2FtZXJhID0gY2FtZXJhT3B0aW9ucztcbiAgICAgICAgY29uc3QgaXNDYW1lcmEgPSBjYW1lcmFPcHRpb25zIGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhO1xuICAgICAgICBjb25zdCBjYW1lcmEgPSBpc0NhbWVyYSA/IGNhbWVyYU9wdGlvbnMgOiBvcnRob2dyYXBoaWMgPyBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKDAsIDAsIDAsIDAsIDAuMSwgMTAwMCkgOiBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNzUsIDAsIDAuMSwgMTAwMCk7XG4gICAgICAgIGlmICghaXNDYW1lcmEpIHtcbiAgICAgICAgICBjYW1lcmEucG9zaXRpb24ueiA9IDU7XG4gICAgICAgICAgaWYgKGNhbWVyYU9wdGlvbnMpIHtcbiAgICAgICAgICAgIGFwcGx5UHJvcHMoY2FtZXJhLCBjYW1lcmFPcHRpb25zKTtcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHVzZXItZGVmaW5lZCBmcnVzdHVtIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8zMTYwXG4gICAgICAgICAgICBpZiAoJ2FzcGVjdCcgaW4gY2FtZXJhT3B0aW9ucyB8fCAnbGVmdCcgaW4gY2FtZXJhT3B0aW9ucyB8fCAncmlnaHQnIGluIGNhbWVyYU9wdGlvbnMgfHwgJ2JvdHRvbScgaW4gY2FtZXJhT3B0aW9ucyB8fCAndG9wJyBpbiBjYW1lcmFPcHRpb25zKSB7XG4gICAgICAgICAgICAgIGNhbWVyYS5tYW51YWwgPSB0cnVlO1xuICAgICAgICAgICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBbHdheXMgbG9vayBhdCBjZW50ZXIgYnkgZGVmYXVsdFxuICAgICAgICAgIGlmICghc3RhdGUuY2FtZXJhICYmICEoY2FtZXJhT3B0aW9ucyAhPSBudWxsICYmIGNhbWVyYU9wdGlvbnMucm90YXRpb24pKSBjYW1lcmEubG9va0F0KDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgY2FtZXJhXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENvbmZpZ3VyZSByYXljYXN0ZXJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC14ci9pc3N1ZXMvMzAwXG4gICAgICAgIHJheWNhc3Rlci5jYW1lcmEgPSBjYW1lcmE7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBzY2VuZSAob25lIHRpbWUgb25seSEpXG4gICAgICBpZiAoIXN0YXRlLnNjZW5lKSB7XG4gICAgICAgIGxldCBzY2VuZTtcbiAgICAgICAgaWYgKHNjZW5lT3B0aW9ucyAhPSBudWxsICYmIHNjZW5lT3B0aW9ucy5pc1NjZW5lKSB7XG4gICAgICAgICAgc2NlbmUgPSBzY2VuZU9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICAgICAgICBpZiAoc2NlbmVPcHRpb25zKSBhcHBseVByb3BzKHNjZW5lLCBzY2VuZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgc2NlbmU6IHByZXBhcmUoc2NlbmUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdXAgWFIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgaWYgKCFzdGF0ZS54cikge1xuICAgICAgICB2YXIgX2dsJHhyO1xuICAgICAgICAvLyBIYW5kbGUgZnJhbWUgYmVoYXZpb3IgaW4gV2ViWFJcbiAgICAgICAgY29uc3QgaGFuZGxlWFJGcmFtZSA9ICh0aW1lc3RhbXAsIGZyYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicpIHJldHVybjtcbiAgICAgICAgICBhZHZhbmNlKHRpbWVzdGFtcCwgdHJ1ZSwgc3RhdGUsIGZyYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUb2dnbGUgcmVuZGVyIHN3aXRjaGluZyBvbiBzZXNzaW9uXG4gICAgICAgIGNvbnN0IGhhbmRsZVNlc3Npb25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIHN0YXRlLmdsLnhyLmVuYWJsZWQgPSBzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmc7XG4gICAgICAgICAgc3RhdGUuZ2wueHIuc2V0QW5pbWF0aW9uTG9vcChzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmcgPyBoYW5kbGVYUkZyYW1lIDogbnVsbCk7XG4gICAgICAgICAgaWYgKCFzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmcpIGludmFsaWRhdGUoc3RhdGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFdlYlhSIHNlc3Npb24gbWFuYWdlclxuICAgICAgICBjb25zdCB4ciA9IHtcbiAgICAgICAgICBjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSBzdG9yZS5nZXRTdGF0ZSgpLmdsO1xuICAgICAgICAgICAgZ2wueHIuYWRkRXZlbnRMaXN0ZW5lcignc2Vzc2lvbnN0YXJ0JywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICBnbC54ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSBzdG9yZS5nZXRTdGF0ZSgpLmdsO1xuICAgICAgICAgICAgZ2wueHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vzc2lvbnN0YXJ0JywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICBnbC54ci5yZW1vdmVFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBXZWJYUiBzZXNzaW9uIGV2ZW50c1xuICAgICAgICBpZiAodHlwZW9mICgoX2dsJHhyID0gZ2wueHIpID09IG51bGwgPyB2b2lkIDAgOiBfZ2wkeHIuYWRkRXZlbnRMaXN0ZW5lcikgPT09ICdmdW5jdGlvbicpIHhyLmNvbm5lY3QoKTtcbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICB4clxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHNoYWRvd21hcFxuICAgICAgaWYgKGdsLnNoYWRvd01hcCkge1xuICAgICAgICBjb25zdCBvbGRFbmFibGVkID0gZ2wuc2hhZG93TWFwLmVuYWJsZWQ7XG4gICAgICAgIGNvbnN0IG9sZFR5cGUgPSBnbC5zaGFkb3dNYXAudHlwZTtcbiAgICAgICAgZ2wuc2hhZG93TWFwLmVuYWJsZWQgPSAhIXNoYWRvd3M7XG4gICAgICAgIGlmIChpcy5ib28oc2hhZG93cykpIHtcbiAgICAgICAgICBnbC5zaGFkb3dNYXAudHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMuc3RyKHNoYWRvd3MpKSB7XG4gICAgICAgICAgdmFyIF90eXBlcyRzaGFkb3dzO1xuICAgICAgICAgIGNvbnN0IHR5cGVzID0ge1xuICAgICAgICAgICAgYmFzaWM6IFRIUkVFLkJhc2ljU2hhZG93TWFwLFxuICAgICAgICAgICAgcGVyY2VudGFnZTogVEhSRUUuUENGU2hhZG93TWFwLFxuICAgICAgICAgICAgc29mdDogVEhSRUUuUENGU29mdFNoYWRvd01hcCxcbiAgICAgICAgICAgIHZhcmlhbmNlOiBUSFJFRS5WU01TaGFkb3dNYXBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdsLnNoYWRvd01hcC50eXBlID0gKF90eXBlcyRzaGFkb3dzID0gdHlwZXNbc2hhZG93c10pICE9IG51bGwgPyBfdHlwZXMkc2hhZG93cyA6IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMub2JqKHNoYWRvd3MpKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihnbC5zaGFkb3dNYXAsIHNoYWRvd3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRFbmFibGVkICE9PSBnbC5zaGFkb3dNYXAuZW5hYmxlZCB8fCBvbGRUeXBlICE9PSBnbC5zaGFkb3dNYXAudHlwZSkgZ2wuc2hhZG93TWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2FmZWx5IHNldCBjb2xvciBtYW5hZ2VtZW50IGlmIGF2YWlsYWJsZS5cbiAgICAgIC8vIEF2b2lkIGFjY2Vzc2luZyBUSFJFRS5Db2xvck1hbmFnZW1lbnQgdG8gcGxheSBuaWNlIHdpdGggb2xkZXIgdmVyc2lvbnNcbiAgICAgIGNvbnN0IENvbG9yTWFuYWdlbWVudCA9IGdldENvbG9yTWFuYWdlbWVudCgpO1xuICAgICAgaWYgKENvbG9yTWFuYWdlbWVudCkge1xuICAgICAgICBpZiAoJ2VuYWJsZWQnIGluIENvbG9yTWFuYWdlbWVudCkgQ29sb3JNYW5hZ2VtZW50LmVuYWJsZWQgPSAhbGVnYWN5O2Vsc2UgaWYgKCdsZWdhY3lNb2RlJyBpbiBDb2xvck1hbmFnZW1lbnQpIENvbG9yTWFuYWdlbWVudC5sZWdhY3lNb2RlID0gbGVnYWN5O1xuICAgICAgfVxuICAgICAgaWYgKCFjb25maWd1cmVkKSB7XG4gICAgICAgIC8vIFNldCBjb2xvciBzcGFjZSBhbmQgdG9uZW1hcHBpbmcgcHJlZmVyZW5jZXMsIG9uY2VcbiAgICAgICAgY29uc3QgTGluZWFyRW5jb2RpbmcgPSAzMDAwO1xuICAgICAgICBjb25zdCBzUkdCRW5jb2RpbmcgPSAzMDAxO1xuICAgICAgICBhcHBseVByb3BzKGdsLCB7XG4gICAgICAgICAgb3V0cHV0RW5jb2Rpbmc6IGxpbmVhciA/IExpbmVhckVuY29kaW5nIDogc1JHQkVuY29kaW5nLFxuICAgICAgICAgIHRvbmVNYXBwaW5nOiBmbGF0ID8gVEhSRUUuTm9Ub25lTWFwcGluZyA6IFRIUkVFLkFDRVNGaWxtaWNUb25lTWFwcGluZ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGNvbG9yIG1hbmFnZW1lbnQgc3RhdGVcbiAgICAgIGlmIChzdGF0ZS5sZWdhY3kgIT09IGxlZ2FjeSkgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGxlZ2FjeVxuICAgICAgfSkpO1xuICAgICAgaWYgKHN0YXRlLmxpbmVhciAhPT0gbGluZWFyKSBzdGF0ZS5zZXQoKCkgPT4gKHtcbiAgICAgICAgbGluZWFyXG4gICAgICB9KSk7XG4gICAgICBpZiAoc3RhdGUuZmxhdCAhPT0gZmxhdCkgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGZsYXRcbiAgICAgIH0pKTtcblxuICAgICAgLy8gU2V0IGdsIHByb3BzXG4gICAgICBpZiAoZ2xDb25maWcgJiYgIWlzLmZ1bihnbENvbmZpZykgJiYgIWlzUmVuZGVyZXIoZ2xDb25maWcpICYmICFpcy5lcXUoZ2xDb25maWcsIGdsLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKGdsLCBnbENvbmZpZyk7XG4gICAgICAvLyBTdG9yZSBldmVudHMgaW50ZXJuYWxseVxuICAgICAgaWYgKGV2ZW50cyAmJiAhc3RhdGUuZXZlbnRzLmhhbmRsZXJzKSBzdGF0ZS5zZXQoe1xuICAgICAgICBldmVudHM6IGV2ZW50cyhzdG9yZSlcbiAgICAgIH0pO1xuICAgICAgLy8gQ2hlY2sgc2l6ZSwgYWxsb3cgaXQgdG8gdGFrZSBvbiBjb250YWluZXIgYm91bmRzIGluaXRpYWxseVxuICAgICAgY29uc3Qgc2l6ZSA9IGNvbXB1dGVJbml0aWFsU2l6ZShjYW52YXMsIHByb3BzU2l6ZSk7XG4gICAgICBpZiAoIWlzLmVxdShzaXplLCBzdGF0ZS5zaXplLCBzaGFsbG93TG9vc2UpKSB7XG4gICAgICAgIHN0YXRlLnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHNpemUudXBkYXRlU3R5bGUsIHNpemUudG9wLCBzaXplLmxlZnQpO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgcGl4ZWxyYXRpb1xuICAgICAgaWYgKGRwciAmJiBzdGF0ZS52aWV3cG9ydC5kcHIgIT09IGNhbGN1bGF0ZURwcihkcHIpKSBzdGF0ZS5zZXREcHIoZHByKTtcbiAgICAgIC8vIENoZWNrIGZyYW1lbG9vcFxuICAgICAgaWYgKHN0YXRlLmZyYW1lbG9vcCAhPT0gZnJhbWVsb29wKSBzdGF0ZS5zZXRGcmFtZWxvb3AoZnJhbWVsb29wKTtcbiAgICAgIC8vIENoZWNrIHBvaW50ZXIgbWlzc2VkXG4gICAgICBpZiAoIXN0YXRlLm9uUG9pbnRlck1pc3NlZCkgc3RhdGUuc2V0KHtcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkXG4gICAgICB9KTtcbiAgICAgIC8vIENoZWNrIHBlcmZvcm1hbmNlXG4gICAgICBpZiAocGVyZm9ybWFuY2UgJiYgIWlzLmVxdShwZXJmb3JtYW5jZSwgc3RhdGUucGVyZm9ybWFuY2UsIHNoYWxsb3dMb29zZSkpIHN0YXRlLnNldChzdGF0ZSA9PiAoe1xuICAgICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAgIC4uLnN0YXRlLnBlcmZvcm1hbmNlLFxuICAgICAgICAgIC4uLnBlcmZvcm1hbmNlXG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgLy8gU2V0IGxvY2Fsc1xuICAgICAgb25DcmVhdGVkID0gb25DcmVhdGVkQ2FsbGJhY2s7XG4gICAgICBjb25maWd1cmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVuZGVyKGNoaWxkcmVuKSB7XG4gICAgICAvLyBUaGUgcm9vdCBoYXMgdG8gYmUgY29uZmlndXJlZCBiZWZvcmUgaXQgY2FuIGJlIHJlbmRlcmVkXG4gICAgICBpZiAoIWNvbmZpZ3VyZWQpIHRoaXMuY29uZmlndXJlKCk7XG4gICAgICByZWNvbmNpbGVyLnVwZGF0ZUNvbnRhaW5lciggLyojX19QVVJFX18qL2pzeChQcm92aWRlciwge1xuICAgICAgICBzdG9yZTogc3RvcmUsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgb25DcmVhdGVkOiBvbkNyZWF0ZWQsXG4gICAgICAgIHJvb3RFbGVtZW50OiBjYW52YXNcbiAgICAgIH0pLCBmaWJlciwgbnVsbCwgKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9LFxuICAgIHVubW91bnQoKSB7XG4gICAgICB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNhbnZhcyk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcmVuZGVyKGNoaWxkcmVuLCBjYW52YXMsIGNvbmZpZykge1xuICBjb25zb2xlLndhcm4oJ1IzRi5yZW5kZXIgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBpbiBSZWFjdCAxOC4gVXNlIGNyZWF0ZVJvb3QgaW5zdGVhZCEnKTtcbiAgY29uc3Qgcm9vdCA9IGNyZWF0ZVJvb3QoY2FudmFzKTtcbiAgcm9vdC5jb25maWd1cmUoY29uZmlnKTtcbiAgcmV0dXJuIHJvb3QucmVuZGVyKGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIFByb3ZpZGVyKHtcbiAgc3RvcmUsXG4gIGNoaWxkcmVuLFxuICBvbkNyZWF0ZWQsXG4gIHJvb3RFbGVtZW50XG59KSB7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAvLyBGbGFnIHRoZSBjYW52YXMgYWN0aXZlLCByZW5kZXJpbmcgd2lsbCBub3cgYmVnaW5cbiAgICBzdGF0ZS5zZXQoc3RhdGUgPT4gKHtcbiAgICAgIGludGVybmFsOiB7XG4gICAgICAgIC4uLnN0YXRlLmludGVybmFsLFxuICAgICAgICBhY3RpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgLy8gTm90aWZpeSB0aGF0IGluaXQgaXMgY29tcGxldGVkLCB0aGUgc2NlbmUgZ3JhcGggZXhpc3RzLCBidXQgbm90aGluZyBoYXMgeWV0IHJlbmRlcmVkXG4gICAgaWYgKG9uQ3JlYXRlZCkgb25DcmVhdGVkKHN0YXRlKTtcbiAgICAvLyBDb25uZWN0IGV2ZW50cyB0byB0aGUgdGFyZ2V0cyBwYXJlbnQsIHRoaXMgaXMgZG9uZSB0byBlbnN1cmUgZXZlbnRzIGFyZSByZWdpc3RlcmVkIG9uXG4gICAgLy8gYSBzaGFyZWQgdGFyZ2V0LCBhbmQgbm90IG9uIHRoZSBjYW52YXMgaXRzZWxmXG4gICAgaWYgKCFzdG9yZS5nZXRTdGF0ZSgpLmV2ZW50cy5jb25uZWN0ZWQpIHN0YXRlLmV2ZW50cy5jb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29ubmVjdChyb290RWxlbWVudCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3RvcmUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJvb3QgPSByb290cy5nZXQoY2FudmFzKTtcbiAgY29uc3QgZmliZXIgPSByb290ID09IG51bGwgPyB2b2lkIDAgOiByb290LmZpYmVyO1xuICBpZiAoZmliZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3Quc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUpIHN0YXRlLmludGVybmFsLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHJlY29uY2lsZXIudXBkYXRlQ29udGFpbmVyKG51bGwsIGZpYmVyLCBudWxsLCAoKSA9PiB7XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfc3RhdGUkZ2wsIF9zdGF0ZSRnbCRyZW5kZXJMaXN0cywgX3N0YXRlJGdsMiwgX3N0YXRlJGdsMztcbiAgICAgICAgICAgIHN0YXRlLmV2ZW50cy5kaXNjb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgKF9zdGF0ZSRnbCA9IHN0YXRlLmdsKSA9PSBudWxsID8gdm9pZCAwIDogKF9zdGF0ZSRnbCRyZW5kZXJMaXN0cyA9IF9zdGF0ZSRnbC5yZW5kZXJMaXN0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbCRyZW5kZXJMaXN0cy5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wkcmVuZGVyTGlzdHMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgKF9zdGF0ZSRnbDIgPSBzdGF0ZS5nbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbDIuZm9yY2VDb250ZXh0TG9zcyA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsMi5mb3JjZUNvbnRleHRMb3NzKCk7XG4gICAgICAgICAgICBpZiAoKF9zdGF0ZSRnbDMgPSBzdGF0ZS5nbCkgIT0gbnVsbCAmJiBfc3RhdGUkZ2wzLnhyKSBzdGF0ZS54ci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBkaXNwb3NlKHN0YXRlKTtcbiAgICAgICAgICAgIHJvb3RzLmRlbGV0ZShjYW52YXMpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhjYW52YXMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIC4uLiAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIsIHN0YXRlKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFBvcnRhbCwge1xuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBzdGF0ZTogc3RhdGVcbiAgfSwgY29udGFpbmVyLnV1aWQpO1xufVxuZnVuY3Rpb24gUG9ydGFsKHtcbiAgc3RhdGUgPSB7fSxcbiAgY2hpbGRyZW4sXG4gIGNvbnRhaW5lclxufSkge1xuICAvKiogVGhpcyBoYXMgdG8gYmUgYSBjb21wb25lbnQgYmVjYXVzZSBpdCB3b3VsZCBub3QgYmUgYWJsZSB0byBjYWxsIHVzZVRocmVlL3VzZVN0b3JlIG90aGVyd2lzZSBzaW5jZVxyXG4gICAqICBpZiB0aGlzIGlzIG91ciBlbnZpcm9ubWVudCwgdGhlbiB3ZSBhcmUgbm90IGluIHIzZidzIHJlbmRlcmVyIGJ1dCBpbiByZWFjdC1kb20sIGl0IHdvdWxkIHRyaWdnZXJcclxuICAgKiAgdGhlIFwiUjNGIGhvb2tzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIHRoZSBDYW52YXMgY29tcG9uZW50IVwiIHdhcm5pbmc6XHJcbiAgICogIDxDYW52YXM+XHJcbiAgICogICAge2NyZWF0ZVBvcnRhbCguLi4pfSAqL1xuICBjb25zdCB7XG4gICAgZXZlbnRzLFxuICAgIHNpemUsXG4gICAgLi4ucmVzdFxuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHByZXZpb3VzUm9vdCA9IHVzZVN0b3JlKCk7XG4gIGNvbnN0IFtyYXljYXN0ZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFRIUkVFLlJheWNhc3RlcigpKTtcbiAgY29uc3QgW3BvaW50ZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFRIUkVFLlZlY3RvcjIoKSk7XG4gIGNvbnN0IGluamVjdCA9IFJlYWN0LnVzZUNhbGxiYWNrKChyb290U3RhdGUsIGluamVjdFN0YXRlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJzZWN0ID0ge1xuICAgICAgLi4ucm9vdFN0YXRlXG4gICAgfTsgLy8gYWxsIHByZXYgc3RhdGUgcHJvcHNcblxuICAgIC8vIE9ubHkgdGhlIGZpZWxkcyBvZiBcInJvb3RTdGF0ZVwiIHRoYXQgZG8gbm90IGRpZmZlciBmcm9tIGluamVjdFN0YXRlXG4gICAgLy8gU29tZSBwcm9wcyBzaG91bGQgYmUgb2ZmLWxpbWl0c1xuICAgIC8vIE90aGVyd2lzZSBmaWx0ZXIgb3V0IHRoZSBwcm9wcyB0aGF0IGFyZSBkaWZmZXJlbnQgYW5kIGxldCB0aGUgaW5qZWN0IGxheWVyIHRha2UgcHJlY2VkZW5jZVxuICAgIE9iamVjdC5rZXlzKHJvb3RTdGF0ZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgLy8gU29tZSBwcm9wcyBzaG91bGQgYmUgb2ZmLWxpbWl0c1xuICAgICAgcHJpdmF0ZUtleXMuaW5jbHVkZXMoa2V5KSB8fFxuICAgICAgLy8gT3RoZXJ3aXNlIGZpbHRlciBvdXQgdGhlIHByb3BzIHRoYXQgYXJlIGRpZmZlcmVudCBhbmQgbGV0IHRoZSBpbmplY3QgbGF5ZXIgdGFrZSBwcmVjZWRlbmNlXG4gICAgICAvLyBVbmxlc3MgdGhlIGluamVjdCBsYXllciBwcm9wcyBpcyB1bmRlZmluZWQsIHRoZW4gd2Uga2VlcCB0aGUgcm9vdCBsYXllclxuICAgICAgcm9vdFN0YXRlW2tleV0gIT09IGluamVjdFN0YXRlW2tleV0gJiYgaW5qZWN0U3RhdGVba2V5XSkge1xuICAgICAgICBkZWxldGUgaW50ZXJzZWN0W2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHZpZXdwb3J0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChpbmplY3RTdGF0ZSAmJiBzaXplKSB7XG4gICAgICBjb25zdCBjYW1lcmEgPSBpbmplY3RTdGF0ZS5jYW1lcmE7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIG92ZXJyaWRlIHZpZXdwb3J0LCBpZiBwcmVzZW50XG4gICAgICB2aWV3cG9ydCA9IHJvb3RTdGF0ZS52aWV3cG9ydC5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhLCBuZXcgVEhSRUUuVmVjdG9yMygpLCBzaXplKTtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcG9ydGFsIGNhbWVyYSwgaWYgaXQgZGlmZmVycyBmcm9tIHRoZSBwcmV2aW91cyBsYXllclxuICAgICAgaWYgKGNhbWVyYSAhPT0gcm9vdFN0YXRlLmNhbWVyYSkgdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAvLyBUaGUgaW50ZXJzZWN0IGNvbnNpc3RzIG9mIHRoZSBwcmV2aW91cyByb290IHN0YXRlXG4gICAgICAuLi5pbnRlcnNlY3QsXG4gICAgICAvLyBQb3J0YWxzIGhhdmUgdGhlaXIgb3duIHNjZW5lLCB3aGljaCBmb3JtcyB0aGUgcm9vdCwgYSByYXljYXN0ZXIgYW5kIGEgcG9pbnRlclxuICAgICAgc2NlbmU6IGNvbnRhaW5lcixcbiAgICAgIHJheWNhc3RlcixcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIC8vIFRoZWlyIHByZXZpb3VzIHJvb3QgaXMgdGhlIGxheWVyIGJlZm9yZSBpdFxuICAgICAgcHJldmlvdXNSb290LFxuICAgICAgLy8gRXZlbnRzLCBzaXplIGFuZCB2aWV3cG9ydCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgaW5qZWN0IGxheWVyXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLmV2ZW50cyxcbiAgICAgICAgLi4uKGluamVjdFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBpbmplY3RTdGF0ZS5ldmVudHMpLFxuICAgICAgICAuLi5ldmVudHNcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIC4uLnJvb3RTdGF0ZS5zaXplLFxuICAgICAgICAuLi5zaXplXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAuLi52aWV3cG9ydFxuICAgICAgfSxcbiAgICAgIC4uLnJlc3RcbiAgICB9O1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtzdGF0ZV0pO1xuICBjb25zdCBbdXNlUG9ydGFsU3RvcmVdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgIC8vIENyZWF0ZSBhIG1pcnJvcmVkIHN0b3JlLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgcm9vdCB3aXRoIGEgZmV3IG92ZXJyaWRlcyAuLi5cbiAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gcHJldmlvdXNSb290LmdldFN0YXRlKCk7XG4gICAgY29uc3Qgc3RvcmUgPSBjcmVhdGUoKHNldCwgZ2V0KSA9PiAoe1xuICAgICAgLi4ucHJldmlvdXNTdGF0ZSxcbiAgICAgIHNjZW5lOiBjb250YWluZXIsXG4gICAgICByYXljYXN0ZXIsXG4gICAgICBwb2ludGVyLFxuICAgICAgbW91c2U6IHBvaW50ZXIsXG4gICAgICBwcmV2aW91c1Jvb3QsXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgLi4ucHJldmlvdXNTdGF0ZS5ldmVudHMsXG4gICAgICAgIC4uLmV2ZW50c1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgLi4ucHJldmlvdXNTdGF0ZS5zaXplLFxuICAgICAgICAuLi5zaXplXG4gICAgICB9LFxuICAgICAgLi4ucmVzdCxcbiAgICAgIC8vIFNldCBhbmQgZ2V0IHJlZmVyIHRvIHRoaXMgcm9vdC1zdGF0ZVxuICAgICAgc2V0LFxuICAgICAgZ2V0LFxuICAgICAgLy8gTGF5ZXJzIGFyZSBhbGxvd2VkIHRvIG92ZXJyaWRlIGV2ZW50c1xuICAgICAgc2V0RXZlbnRzOiBldmVudHMgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgLi4uZXZlbnRzXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgIH0pKTtcbiAgICByZXR1cm4gc3RvcmU7XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFN1YnNjcmliZSB0byBwcmV2aW91cyByb290LXN0YXRlIGFuZCBjb3B5IGNoYW5nZXMgb3ZlciB0byB0aGUgbWlycm9yZWQgcG9ydGFsLXN0YXRlXG4gICAgY29uc3QgdW5zdWIgPSBwcmV2aW91c1Jvb3Quc3Vic2NyaWJlKHByZXYgPT4gdXNlUG9ydGFsU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4gaW5qZWN0KHByZXYsIHN0YXRlKSkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnN1YigpO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbaW5qZWN0XSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdXNlUG9ydGFsU3RvcmUuc2V0U3RhdGUoaW5qZWN0U3RhdGUgPT4gaW5qZWN0KHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpLCBpbmplY3RTdGF0ZSkpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2luamVjdF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1c2VQb3J0YWxTdG9yZS5kZXN0cm95KCk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogcmVjb25jaWxlci5jcmVhdGVQb3J0YWwoIC8qI19fUFVSRV9fKi9qc3goY29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHVzZVBvcnRhbFN0b3JlLFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfSksIHVzZVBvcnRhbFN0b3JlLCBudWxsKVxuICB9KTtcbn1cblxuLyoqXHJcbiAqIEZvcmNlIFJlYWN0IHRvIGZsdXNoIGFueSB1cGRhdGVzIGluc2lkZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgc3luY2hyb25vdXNseSBhbmQgaW1tZWRpYXRlbHkuXHJcbiAqIEFsbCB0aGUgc2FtZSBjYXZlYXRzIGRvY3VtZW50ZWQgZm9yIHJlYWN0LWRvbSdzIGBmbHVzaFN5bmNgIGFwcGx5IGhlcmUgKHNlZSBodHRwczovL3JlYWN0LmRldi9yZWZlcmVuY2UvcmVhY3QtZG9tL2ZsdXNoU3luYykuXHJcbiAqIE5ldmVydGhlbGVzcywgc29tZXRpbWVzIG9uZSBuZWVkcyB0byByZW5kZXIgc3luY2hyb25vdXNseSwgZm9yIGV4YW1wbGUgdG8ga2VlcCBET00gYW5kIDNEIGNoYW5nZXMgaW4gbG9jay1zdGVwIHdpdGhvdXRcclxuICogaGF2aW5nIHRvIHJldmVydCB0byBhIG5vbi1SZWFjdCBzb2x1dGlvbi5cclxuICovXG5mdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcbiAgLy8gYGZsdXNoU3luY2AgaW1wbGVtZW50YXRpb24gb25seSB0YWtlcyBvbmUgYXJndW1lbnQuIEkgZG9uJ3Qga25vdyB3aGF0J3MgdXAgd2l0aCB0aGUgdHlwZSBkZWNsYXJhdGlvbiBmb3IgaXQuXG4gIHJldHVybiByZWNvbmNpbGVyLmZsdXNoU3luYyhmbiwgdW5kZWZpbmVkKTtcbn1cbnJlY29uY2lsZXIuaW5qZWN0SW50b0RldlRvb2xzKHtcbiAgYnVuZGxlVHlwZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyA/IDAgOiAxLFxuICByZW5kZXJlclBhY2thZ2VOYW1lOiAnQHJlYWN0LXRocmVlL2ZpYmVyJyxcbiAgdmVyc2lvbjogUmVhY3QudmVyc2lvblxufSk7XG5jb25zdCBhY3QgPSBSZWFjdC51bnN0YWJsZV9hY3Q7XG5cbmNvbnN0IERPTV9FVkVOVFMgPSB7XG4gIG9uQ2xpY2s6IFsnY2xpY2snLCBmYWxzZV0sXG4gIG9uQ29udGV4dE1lbnU6IFsnY29udGV4dG1lbnUnLCBmYWxzZV0sXG4gIG9uRG91YmxlQ2xpY2s6IFsnZGJsY2xpY2snLCBmYWxzZV0sXG4gIG9uV2hlZWw6IFsnd2hlZWwnLCB0cnVlXSxcbiAgb25Qb2ludGVyRG93bjogWydwb2ludGVyZG93bicsIHRydWVdLFxuICBvblBvaW50ZXJVcDogWydwb2ludGVydXAnLCB0cnVlXSxcbiAgb25Qb2ludGVyTGVhdmU6IFsncG9pbnRlcmxlYXZlJywgdHJ1ZV0sXG4gIG9uUG9pbnRlck1vdmU6IFsncG9pbnRlcm1vdmUnLCB0cnVlXSxcbiAgb25Qb2ludGVyQ2FuY2VsOiBbJ3BvaW50ZXJjYW5jZWwnLCB0cnVlXSxcbiAgb25Mb3N0UG9pbnRlckNhcHR1cmU6IFsnbG9zdHBvaW50ZXJjYXB0dXJlJywgdHJ1ZV1cbn07XG5cbi8qKiBEZWZhdWx0IFIzRiBldmVudCBtYW5hZ2VyIGZvciB3ZWIgKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50ZXJFdmVudHMoc3RvcmUpIHtcbiAgY29uc3Qge1xuICAgIGhhbmRsZVBvaW50ZXJcbiAgfSA9IGNyZWF0ZUV2ZW50cyhzdG9yZSk7XG4gIHJldHVybiB7XG4gICAgcHJpb3JpdHk6IDEsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBjb21wdXRlKGV2ZW50LCBzdGF0ZSwgcHJldmlvdXMpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC83ODJcbiAgICAgIC8vIEV2ZW50cyB0cmlnZ2VyIG91dHNpZGUgb2YgY2FudmFzIHdoZW4gbW92ZWQsIHVzZSBvZmZzZXRYL1kgYnkgZGVmYXVsdCBhbmQgYWxsb3cgb3ZlcnJpZGVzXG4gICAgICBzdGF0ZS5wb2ludGVyLnNldChldmVudC5vZmZzZXRYIC8gc3RhdGUuc2l6ZS53aWR0aCAqIDIgLSAxLCAtKGV2ZW50Lm9mZnNldFkgLyBzdGF0ZS5zaXplLmhlaWdodCkgKiAyICsgMSk7XG4gICAgICBzdGF0ZS5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShzdGF0ZS5wb2ludGVyLCBzdGF0ZS5jYW1lcmEpO1xuICAgIH0sXG4gICAgY29ubmVjdGVkOiB1bmRlZmluZWQsXG4gICAgaGFuZGxlcnM6IE9iamVjdC5rZXlzKERPTV9FVkVOVFMpLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7XG4gICAgICAuLi5hY2MsXG4gICAgICBba2V5XTogaGFuZGxlUG9pbnRlcihrZXkpXG4gICAgfSksIHt9KSxcbiAgICB1cGRhdGU6ICgpID0+IHtcbiAgICAgIHZhciBfaW50ZXJuYWwkbGFzdEV2ZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBldmVudHMsXG4gICAgICAgIGludGVybmFsXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmICgoX2ludGVybmFsJGxhc3RFdmVudCA9IGludGVybmFsLmxhc3RFdmVudCkgIT0gbnVsbCAmJiBfaW50ZXJuYWwkbGFzdEV2ZW50LmN1cnJlbnQgJiYgZXZlbnRzLmhhbmRsZXJzKSBldmVudHMuaGFuZGxlcnMub25Qb2ludGVyTW92ZShpbnRlcm5hbC5sYXN0RXZlbnQuY3VycmVudCk7XG4gICAgfSxcbiAgICBjb25uZWN0OiB0YXJnZXQgPT4ge1xuICAgICAgdmFyIF9ldmVudHMkaGFuZGxlcnM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZXZlbnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGV2ZW50cy5kaXNjb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBldmVudHMuZGlzY29ubmVjdCgpO1xuICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICBjb25uZWN0ZWQ6IHRhcmdldFxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICBPYmplY3QuZW50cmllcygoX2V2ZW50cyRoYW5kbGVycyA9IGV2ZW50cy5oYW5kbGVycykgIT0gbnVsbCA/IF9ldmVudHMkaGFuZGxlcnMgOiBbXSkuZm9yRWFjaCgoW25hbWUsIGV2ZW50XSkgPT4ge1xuICAgICAgICBjb25zdCBbZXZlbnROYW1lLCBwYXNzaXZlXSA9IERPTV9FVkVOVFNbbmFtZV07XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnQsIHtcbiAgICAgICAgICBwYXNzaXZlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZXZlbnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChldmVudHMuY29ubmVjdGVkKSB7XG4gICAgICAgIHZhciBfZXZlbnRzJGhhbmRsZXJzMjtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoKF9ldmVudHMkaGFuZGxlcnMyID0gZXZlbnRzLmhhbmRsZXJzKSAhPSBudWxsID8gX2V2ZW50cyRoYW5kbGVyczIgOiBbXSkuZm9yRWFjaCgoW25hbWUsIGV2ZW50XSkgPT4ge1xuICAgICAgICAgIGlmIChldmVudHMgJiYgZXZlbnRzLmNvbm5lY3RlZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBbZXZlbnROYW1lXSA9IERPTV9FVkVOVFNbbmFtZV07XG4gICAgICAgICAgICBldmVudHMuY29ubmVjdGVkLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgICBjb25uZWN0ZWQ6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IHsgdXNlSW5zdGFuY2VIYW5kbGUgYXMgQSwgQmxvY2sgYXMgQiwgdXNlU3RvcmUgYXMgQywgdXNlVGhyZWUgYXMgRCwgRXJyb3JCb3VuZGFyeSBhcyBFLCB1c2VGcmFtZSBhcyBGLCB1c2VHcmFwaCBhcyBHLCB1c2VMb2FkZXIgYXMgSCwgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCBhcyBhLCBjcmVhdGVSb290IGFzIGIsIGNyZWF0ZVBvaW50ZXJFdmVudHMgYXMgYywgdW5tb3VudENvbXBvbmVudEF0Tm9kZSBhcyBkLCBleHRlbmQgYXMgZSwgY3JlYXRlRXZlbnRzIGFzIGYsIGNvbnRleHQgYXMgZywgY3JlYXRlUG9ydGFsIGFzIGgsIGlzUmVmIGFzIGksIHJlY29uY2lsZXIgYXMgaiwgYXBwbHlQcm9wcyBhcyBrLCBkaXNwb3NlIGFzIGwsIGludmFsaWRhdGUgYXMgbSwgYWR2YW5jZSBhcyBuLCBhZGRFZmZlY3QgYXMgbywgYWRkQWZ0ZXJFZmZlY3QgYXMgcCwgYWRkVGFpbCBhcyBxLCByZW5kZXIgYXMgciwgZmx1c2hHbG9iYWxFZmZlY3RzIGFzIHMsIHRocmVlVHlwZXMgYXMgdCwgdXNlTXV0YWJsZUNhbGxiYWNrIGFzIHUsIGZsdXNoU3luYyBhcyB2LCBnZXRSb290U3RhdGUgYXMgdywgYWN0IGFzIHgsIGJ1aWxkR3JhcGggYXMgeSwgcm9vdHMgYXMgeiB9O1xuIl0sIm5hbWVzIjpbIlRIUkVFIiwiUmVhY3QiLCJEZWZhdWx0RXZlbnRQcmlvcml0eSIsIkNvbnRpbnVvdXNFdmVudFByaW9yaXR5IiwiRGlzY3JldGVFdmVudFByaW9yaXR5IiwiQ29uY3VycmVudFJvb3QiLCJjcmVhdGUiLCJzdXNwZW5kIiwicHJlbG9hZCIsImNsZWFyIiwianN4IiwiRnJhZ21lbnQiLCJSZWNvbmNpbGVyIiwidW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsInRocmVlVHlwZXMiLCJPYmplY3QiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJjYXRhbG9ndWUiLCJleHRlbmQiLCJvYmplY3RzIiwiYXNzaWduIiwiY3JlYXRlUmVuZGVyZXIiLCJfcm9vdHMiLCJfZ2V0RXZlbnRQcmlvcml0eSIsImNyZWF0ZUluc3RhbmNlIiwidHlwZSIsImFyZ3MiLCJhdHRhY2giLCJwcm9wcyIsInJvb3QiLCJuYW1lIiwidG9VcHBlckNhc2UiLCJzbGljZSIsImluc3RhbmNlIiwib2JqZWN0IiwidW5kZWZpbmVkIiwiRXJyb3IiLCJwcmVwYXJlIiwicHJpbWl0aXZlIiwidGFyZ2V0IiwiQXJyYXkiLCJpc0FycmF5IiwibWVtb2l6ZWRQcm9wcyIsIl9fcjNmIiwiaXNCdWZmZXJHZW9tZXRyeSIsImlzTWF0ZXJpYWwiLCJhcHBseVByb3BzJDEiLCJhcHBlbmRDaGlsZCIsInBhcmVudEluc3RhbmNlIiwiY2hpbGQiLCJhZGRlZCIsIl9jaGlsZCRfX3IzZiIsIl9wYXJlbnRJbnN0YW5jZSRfX3IzZiIsImlzT2JqZWN0M0QiLCJhZGQiLCJwdXNoIiwicGFyZW50IiwidXBkYXRlSW5zdGFuY2UiLCJpbnZhbGlkYXRlSW5zdGFuY2UiLCJpbnNlcnRCZWZvcmUiLCJiZWZvcmVDaGlsZCIsIl9jaGlsZCRfX3IzZjIiLCJfcGFyZW50SW5zdGFuY2UkX19yM2YyIiwiZGlzcGF0Y2hFdmVudCIsInJlc3RTaWJsaW5ncyIsImNoaWxkcmVuIiwiZmlsdGVyIiwic2libGluZyIsImluZGV4IiwiaW5kZXhPZiIsInJlbW92ZVJlY3Vyc2l2ZSIsImFycmF5IiwiZGlzcG9zZSIsImZvckVhY2giLCJyZW1vdmVDaGlsZCIsIl9wYXJlbnRJbnN0YW5jZSRfX3IzZjMiLCJfY2hpbGQkX19yM2YzIiwiX2NoaWxkJF9fcjNmNSIsIngiLCJkZXRhY2giLCJfY2hpbGQkX19yM2Y0IiwicmVtb3ZlIiwicmVtb3ZlSW50ZXJhY3Rpdml0eSIsImZpbmRJbml0aWFsUm9vdCIsImlzUHJpbWl0aXZlIiwic2hvdWxkRGlzcG9zZSIsIl9jaGlsZCRfX3IzZjYiLCJjYWxsYmFjayIsImUiLCJJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQiLCJzd2l0Y2hJbnN0YW5jZSIsIm5ld1Byb3BzIiwiZmliZXIiLCJfaW5zdGFuY2UkX19yM2YiLCJuZXdJbnN0YW5jZSIsImF1dG9SZW1vdmVkQmVmb3JlQXBwZW5kIiwicmF5Y2FzdCIsImV2ZW50Q291bnQiLCJyb290U3RhdGUiLCJnZXRTdGF0ZSIsImludGVybmFsIiwiaW50ZXJhY3Rpb24iLCJhbHRlcm5hdGUiLCJzdGF0ZU5vZGUiLCJyZWYiLCJjdXJyZW50IiwiaGFuZGxlVGV4dEluc3RhbmNlIiwicmVjb25jaWxlciIsImFwcGVuZEluaXRpYWxDaGlsZCIsInN1cHBvcnRzTXV0YXRpb24iLCJpc1ByaW1hcnlSZW5kZXJlciIsInN1cHBvcnRzUGVyc2lzdGVuY2UiLCJzdXBwb3J0c0h5ZHJhdGlvbiIsIm5vVGltZW91dCIsImFwcGVuZENoaWxkVG9Db250YWluZXIiLCJjb250YWluZXIiLCJzY2VuZSIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsInBhcmVudEhvc3RDb250ZXh0IiwiZmluYWxpemVJbml0aWFsQ2hpbGRyZW4iLCJfaW5zdGFuY2UkX19yM2YyIiwibG9jYWxTdGF0ZSIsIkJvb2xlYW4iLCJoYW5kbGVycyIsInByZXBhcmVVcGRhdGUiLCJfdHlwZSIsIm9sZFByb3BzIiwiX2luc3RhbmNlJF9fcjNmMyIsImFyZ3NOZXciLCJjTiIsInJlc3ROZXciLCJhcmdzT2xkIiwiY08iLCJyZXN0T2xkIiwic29tZSIsInZhbHVlIiwiZGlmZiIsImRpZmZQcm9wcyIsImNoYW5nZXMiLCJsZW5ndGgiLCJjb21taXRVcGRhdGUiLCJyZWNvbnN0cnVjdCIsIl9vbGRQcm9wcyIsImNvbW1pdE1vdW50IiwiX3Byb3BzIiwiX2ludCIsIl9pbnN0YW5jZSRfX3IzZjQiLCJnZXRQdWJsaWNJbnN0YW5jZSIsInByZXBhcmVGb3JDb21taXQiLCJwcmVwYXJlUG9ydGFsTW91bnQiLCJyZXNldEFmdGVyQ29tbWl0Iiwic2hvdWxkU2V0VGV4dENvbnRlbnQiLCJjbGVhckNvbnRhaW5lciIsImhpZGVJbnN0YW5jZSIsIl9pbnN0YW5jZSRfX3IzZjUiLCJ2aXNpYmxlIiwidW5oaWRlSW5zdGFuY2UiLCJfaW5zdGFuY2UkX19yM2Y2IiwiY3JlYXRlVGV4dEluc3RhbmNlIiwiaGlkZVRleHRJbnN0YW5jZSIsInVuaGlkZVRleHRJbnN0YW5jZSIsImdldEN1cnJlbnRFdmVudFByaW9yaXR5IiwiYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyIiwiYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIiLCJkZXRhY2hEZWxldGVkSW5zdGFuY2UiLCJub3ciLCJwZXJmb3JtYW5jZSIsImlzIiwiZnVuIiwiRGF0ZSIsInNjaGVkdWxlVGltZW91dCIsInNldFRpbWVvdXQiLCJjYW5jZWxUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiYXBwbHlQcm9wcyIsIl93aW5kb3ckZG9jdW1lbnQiLCJfd2luZG93JG5hdmlnYXRvciIsImhhc0NvbG9yU3BhY2UiLCJnZXRDb2xvck1hbmFnZW1lbnQiLCJfQ29sb3JNYW5hZ2VtZW50IiwiQ29sb3JNYW5hZ2VtZW50IiwiaXNPcnRob2dyYXBoaWNDYW1lcmEiLCJkZWYiLCJpc1JlZiIsIm9iaiIsImhhc093blByb3BlcnR5IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VNdXRhYmxlQ2FsbGJhY2siLCJmbiIsInVzZVJlZiIsIkJsb2NrIiwic2V0IiwiUHJvbWlzZSIsIkVycm9yQm91bmRhcnkiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInN0YXRlIiwiZXJyb3IiLCJjb21wb25lbnREaWRDYXRjaCIsImVyciIsInJlbmRlciIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsIkRFRkFVTFQiLCJERUZBVUxUUyIsIk1hcCIsImlzRGlmZlNldCIsIm1lbW9pemVkIiwiY2FsY3VsYXRlRHByIiwiZHByIiwiX3dpbmRvdyRkZXZpY2VQaXhlbFJhIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIk1hdGgiLCJtaW4iLCJtYXgiLCJnZXRSb290U3RhdGUiLCJfcjNmIiwicHJldmlvdXNSb290IiwiYSIsImFyciIsInN0ciIsIm51bSIsImJvbyIsInVuZCIsImVxdSIsImIiLCJhcnJheXMiLCJzdHJpY3QiLCJpc09iaiIsImlzQXJyIiwiaSIsImtleXMiLCJidWlsZEdyYXBoIiwiZGF0YSIsIm5vZGVzIiwibWF0ZXJpYWxzIiwidHJhdmVyc2UiLCJtYXRlcmlhbCIsInAiLCJwcmV2aW91c0F0dGFjaCIsInJlc29sdmUiLCJrZXkiLCJpbmNsdWRlcyIsImVudHJpZXMiLCJzcGxpdCIsImxhc3QiLCJwb3AiLCJyZWR1Y2UiLCJhY2MiLCJJTkRFWF9SRUdFWCIsInRlc3QiLCJyZXBsYWNlIiwicHJldmlvdXMiLCJrTiIsInJOIiwiY1AiLCJrUCIsInJQIiwicHJldmlvdXNLZXlzIiwidW5zaGlmdCIsInByb3AiLCJzdGFydHNXaXRoIiwiX19ERVZfXyIsInByb2Nlc3MiLCJwcmV2SGFuZGxlcnMiLCJpc0V2ZW50Iiwic1JHQkVuY29kaW5nIiwiU1JHQkNvbG9yU3BhY2UiLCJMaW5lYXJTUkdCQ29sb3JTcGFjZSIsImN1cnJlbnRJbnN0YW5jZSIsInRhcmdldFByb3AiLCJyZXZlcnNlRW50cmllcyIsInJldmVyc2UiLCJjdG9yIiwiZ2V0IiwiY29weSIsIkxheWVycyIsImZyb21BcnJheSIsIl90YXJnZXRQcm9wIiwiaXNDb2xvciIsInNldFNjYWxhciIsIm1hc2siLCJsaW5lYXIiLCJjb252ZXJ0U1JHQlRvTGluZWFyIiwiX2N1cnJlbnRJbnN0YW5jZSRrZXkiLCJpc1RleHR1cmUiLCJmb3JtYXQiLCJSR0JBRm9ybWF0IiwiVW5zaWduZWRCeXRlVHlwZSIsInRleHR1cmUiLCJnbCIsImNvbG9yU3BhY2UiLCJvdXRwdXRDb2xvclNwYWNlIiwiZW5jb2RpbmciLCJvdXRwdXRFbmNvZGluZyIsInNwbGljZSIsImlzQ2lyY3VsYXIiLCJfaW5zdGFuY2UkX19yM2YzJHJvb3QiLCJmcmFtZXMiLCJpbnZhbGlkYXRlIiwib25VcGRhdGUiLCJ1cGRhdGVDYW1lcmEiLCJjYW1lcmEiLCJzaXplIiwibWFudWFsIiwibGVmdCIsIndpZHRoIiwicmlnaHQiLCJ0b3AiLCJoZWlnaHQiLCJib3R0b20iLCJhc3BlY3QiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwidXBkYXRlTWF0cml4V29ybGQiLCJtYWtlSWQiLCJldmVudCIsImV2ZW50T2JqZWN0IiwidXVpZCIsImluc3RhbmNlSWQiLCJnZXRFdmVudFByaW9yaXR5IiwiX2dsb2JhbFNjb3BlJGV2ZW50IiwiZ2xvYmFsU2NvcGUiLCJzZWxmIiwicmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUiLCJjYXB0dXJlZE1hcCIsImNhcHR1cmVzIiwicG9pbnRlcklkIiwiY2FwdHVyZURhdGEiLCJkZWxldGUiLCJyZWxlYXNlUG9pbnRlckNhcHR1cmUiLCJzdG9yZSIsIm8iLCJpbml0aWFsSGl0cyIsImhvdmVyZWQiLCJjcmVhdGVFdmVudHMiLCJjYWxjdWxhdGVEaXN0YW5jZSIsImR4Iiwib2Zmc2V0WCIsImluaXRpYWxDbGljayIsImR5Iiwib2Zmc2V0WSIsInJvdW5kIiwic3FydCIsImZpbHRlclBvaW50ZXJFdmVudHMiLCJpbnRlcnNlY3QiLCJkdXBsaWNhdGVzIiwiU2V0IiwiaW50ZXJzZWN0aW9ucyIsImV2ZW50c09iamVjdHMiLCJyYXljYXN0ZXIiLCJldmVudHMiLCJjb21wdXRlIiwiaGFuZGxlUmF5Y2FzdCIsImVuYWJsZWQiLCJfc3RhdGUkcHJldmlvdXNSb290IiwiaW50ZXJzZWN0T2JqZWN0IiwiaGl0cyIsImZsYXRNYXAiLCJzb3J0IiwiYVN0YXRlIiwiYlN0YXRlIiwiZGlzdGFuY2UiLCJwcmlvcml0eSIsIml0ZW0iLCJpZCIsImhhcyIsImhpdCIsIl9yM2YyIiwidmFsdWVzIiwiaW50ZXJzZWN0aW9uIiwiaGFuZGxlSW50ZXJzZWN0cyIsImRlbHRhIiwic3RvcHBlZCIsInBvaW50ZXIiLCJ1bnByb2plY3RlZFBvaW50IiwiVmVjdG9yMyIsInkiLCJ1bnByb2plY3QiLCJoYXNQb2ludGVyQ2FwdHVyZSIsIl9pbnRlcm5hbCRjYXB0dXJlZE1hcCIsIl9pbnRlcm5hbCRjYXB0dXJlZE1hcDIiLCJzZXRQb2ludGVyQ2FwdHVyZSIsImV4dHJhY3RFdmVudFByb3BzIiwicHJvcGVydHkiLCJyYXljYXN0RXZlbnQiLCJyYXkiLCJzdG9wUHJvcGFnYXRpb24iLCJjYXB0dXJlc0ZvclBvaW50ZXIiLCJmcm9tIiwiZmluZCIsImhpZ2hlciIsImNhbmNlbFBvaW50ZXIiLCJjdXJyZW50VGFyZ2V0IiwibmF0aXZlRXZlbnQiLCJob3ZlcmVkT2JqIiwib25Qb2ludGVyT3V0Iiwib25Qb2ludGVyTGVhdmUiLCJwb2ludGVyTWlzc2VkIiwib25Qb2ludGVyTWlzc2VkIiwiaGFuZGxlUG9pbnRlciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImhhbmRsZUV2ZW50IiwibGFzdEV2ZW50IiwiaXNQb2ludGVyTW92ZSIsImlzQ2xpY2tFdmVudCIsIm1hcCIsIm9uSW50ZXJzZWN0Iiwib25Qb2ludGVyT3ZlciIsIm9uUG9pbnRlckVudGVyIiwiaG92ZXJlZEl0ZW0iLCJvblBvaW50ZXJNb3ZlIiwiaGFuZGxlciIsInByaXZhdGVLZXlzIiwiaXNSZW5kZXJlciIsImNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiY3JlYXRlU3RvcmUiLCJhZHZhbmNlIiwicG9zaXRpb24iLCJkZWZhdWx0VGFyZ2V0IiwidGVtcFRhcmdldCIsImdldEN1cnJlbnRWaWV3cG9ydCIsImlzVmVjdG9yMyIsImdldFdvcmxkUG9zaXRpb24iLCJkaXN0YW5jZVRvIiwiem9vbSIsImZhY3RvciIsImZvdiIsIlBJIiwiaCIsInRhbiIsInciLCJwZXJmb3JtYW5jZVRpbWVvdXQiLCJzZXRQZXJmb3JtYW5jZUN1cnJlbnQiLCJWZWN0b3IyIiwiY29ubmVjdGVkIiwieHIiLCJ0aW1lc3RhbXAiLCJydW5HbG9iYWxFZmZlY3RzIiwibGVnYWN5IiwiZmxhdCIsImNvbnRyb2xzIiwiY2xvY2siLCJDbG9jayIsIm1vdXNlIiwiZnJhbWVsb29wIiwiZGVib3VuY2UiLCJyZWdyZXNzIiwidXBkYXRlU3R5bGUiLCJ2aWV3cG9ydCIsImluaXRpYWxEcHIiLCJzZXRFdmVudHMiLCJzZXRTaXplIiwic2V0RHByIiwicmVzb2x2ZWQiLCJzZXRGcmFtZWxvb3AiLCJzdG9wIiwiZWxhcHNlZFRpbWUiLCJzdGFydCIsImFjdGl2ZSIsImNyZWF0ZVJlZiIsInN1YnNjcmliZXJzIiwic3Vic2NyaWJlIiwicyIsIm9sZFNpemUiLCJvbGREcHIiLCJvbGRDYW1lcmEiLCJfc2l6ZSR1cGRhdGVTdHlsZSIsInNldFBpeGVsUmF0aW8iLCJIVE1MQ2FudmFzRWxlbWVudCIsImRvbUVsZW1lbnQiLCJjcmVhdGVTdWJzIiwic3VicyIsInN1YiIsImdsb2JhbEVmZmVjdHMiLCJnbG9iYWxBZnRlckVmZmVjdHMiLCJnbG9iYWxUYWlsRWZmZWN0cyIsImFkZEVmZmVjdCIsImFkZEFmdGVyRWZmZWN0IiwiYWRkVGFpbCIsInJ1biIsImVmZmVjdHMiLCJmbHVzaEdsb2JhbEVmZmVjdHMiLCJzdWJzY3JpcHRpb24iLCJyZW5kZXIkMSIsImZyYW1lIiwiZ2V0RGVsdGEiLCJvbGRUaW1lIiwiY3JlYXRlTG9vcCIsInJvb3RzIiwicnVubmluZyIsInVzZUZyYW1lSW5Qcm9ncmVzcyIsInJlcGVhdCIsImxvb3AiLCJfc3RhdGUkZ2wkeHIiLCJpc1ByZXNlbnRpbmciLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIl9zdGF0ZSRnbCR4cjIiLCJ1c2VJbnN0YW5jZUhhbmRsZSIsInVzZVN0b3JlIiwidXNlQ29udGV4dCIsInVzZVRocmVlIiwic2VsZWN0b3IiLCJlcXVhbGl0eUZuIiwidXNlRnJhbWUiLCJyZW5kZXJQcmlvcml0eSIsInVzZUdyYXBoIiwidXNlTWVtbyIsIm1lbW9pemVkTG9hZGVycyIsIldlYWtNYXAiLCJsb2FkaW5nRm4iLCJleHRlbnNpb25zIiwib25Qcm9ncmVzcyIsIlByb3RvIiwiaW5wdXQiLCJsb2FkZXIiLCJhbGwiLCJyZXMiLCJyZWplY3QiLCJsb2FkIiwibWVzc2FnZSIsInVzZUxvYWRlciIsInJlc3VsdHMiLCJlcXVhbCIsInNoYWxsb3dMb29zZSIsImNyZWF0ZVJlbmRlcmVySW5zdGFuY2UiLCJjYW52YXMiLCJjdXN0b21SZW5kZXJlciIsIldlYkdMUmVuZGVyZXIiLCJwb3dlclByZWZlcmVuY2UiLCJhbnRpYWxpYXMiLCJhbHBoYSIsImNvbXB1dGVJbml0aWFsU2l6ZSIsImRlZmF1bHRTaXplIiwiZGVmYXVsdFN0eWxlIiwicGFyZW50RWxlbWVudCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIk9mZnNjcmVlbkNhbnZhcyIsImNyZWF0ZVJvb3QiLCJwcmV2Um9vdCIsInByZXZGaWJlciIsInByZXZTdG9yZSIsImNvbnNvbGUiLCJ3YXJuIiwibG9nUmVjb3ZlcmFibGVFcnJvciIsInJlcG9ydEVycm9yIiwiY3JlYXRlQ29udGFpbmVyIiwib25DcmVhdGVkIiwiY29uZmlndXJlZCIsImxhc3RDYW1lcmEiLCJjb25maWd1cmUiLCJnbENvbmZpZyIsInByb3BzU2l6ZSIsInNjZW5lT3B0aW9ucyIsIm9uQ3JlYXRlZENhbGxiYWNrIiwic2hhZG93cyIsIm9ydGhvZ3JhcGhpYyIsInJheWNhc3RPcHRpb25zIiwiY2FtZXJhT3B0aW9ucyIsIlJheWNhc3RlciIsInBhcmFtcyIsIm9wdGlvbnMiLCJpc0NhbWVyYSIsIkNhbWVyYSIsIk9ydGhvZ3JhcGhpY0NhbWVyYSIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwieiIsInJvdGF0aW9uIiwibG9va0F0IiwiaXNTY2VuZSIsIlNjZW5lIiwiX2dsJHhyIiwiaGFuZGxlWFJGcmFtZSIsImhhbmRsZVNlc3Npb25DaGFuZ2UiLCJzZXRBbmltYXRpb25Mb29wIiwiY29ubmVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkaXNjb25uZWN0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNoYWRvd01hcCIsIm9sZEVuYWJsZWQiLCJvbGRUeXBlIiwiUENGU29mdFNoYWRvd01hcCIsIl90eXBlcyRzaGFkb3dzIiwidHlwZXMiLCJiYXNpYyIsIkJhc2ljU2hhZG93TWFwIiwicGVyY2VudGFnZSIsIlBDRlNoYWRvd01hcCIsInNvZnQiLCJ2YXJpYW5jZSIsIlZTTVNoYWRvd01hcCIsIm5lZWRzVXBkYXRlIiwibGVnYWN5TW9kZSIsIkxpbmVhckVuY29kaW5nIiwidG9uZU1hcHBpbmciLCJOb1RvbmVNYXBwaW5nIiwiQUNFU0ZpbG1pY1RvbmVNYXBwaW5nIiwidXBkYXRlQ29udGFpbmVyIiwiUHJvdmlkZXIiLCJyb290RWxlbWVudCIsInVubW91bnQiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwiY29uZmlnIiwiX3N0YXRlJGdsIiwiX3N0YXRlJGdsJHJlbmRlckxpc3RzIiwiX3N0YXRlJGdsMiIsIl9zdGF0ZSRnbDMiLCJyZW5kZXJMaXN0cyIsImZvcmNlQ29udGV4dExvc3MiLCJjcmVhdGVQb3J0YWwiLCJQb3J0YWwiLCJyZXN0IiwidXNlU3RhdGUiLCJpbmplY3QiLCJ1c2VDYWxsYmFjayIsImluamVjdFN0YXRlIiwidXNlUG9ydGFsU3RvcmUiLCJwcmV2aW91c1N0YXRlIiwidW5zdWIiLCJwcmV2Iiwic2V0U3RhdGUiLCJkZXN0cm95IiwiZmx1c2hTeW5jIiwiaW5qZWN0SW50b0RldlRvb2xzIiwiYnVuZGxlVHlwZSIsInJlbmRlcmVyUGFja2FnZU5hbWUiLCJ2ZXJzaW9uIiwiYWN0IiwidW5zdGFibGVfYWN0IiwiRE9NX0VWRU5UUyIsIm9uQ2xpY2siLCJvbkNvbnRleHRNZW51Iiwib25Eb3VibGVDbGljayIsIm9uV2hlZWwiLCJvblBvaW50ZXJEb3duIiwib25Qb2ludGVyVXAiLCJvblBvaW50ZXJDYW5jZWwiLCJvbkxvc3RQb2ludGVyQ2FwdHVyZSIsImNyZWF0ZVBvaW50ZXJFdmVudHMiLCJzZXRGcm9tQ2FtZXJhIiwidXBkYXRlIiwiX2ludGVybmFsJGxhc3RFdmVudCIsIl9ldmVudHMkaGFuZGxlcnMiLCJldmVudE5hbWUiLCJwYXNzaXZlIiwiX2V2ZW50cyRoYW5kbGVyczIiLCJIVE1MRWxlbWVudCIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiYyIsImQiLCJmIiwiZyIsImoiLCJrIiwibCIsIm0iLCJuIiwicSIsInIiLCJ0IiwidSIsInYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/events-776716bd.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactThreeFiber: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   _roots: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   act: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   addAfterEffect: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   addEffect: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   addTail: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   advance: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   applyProps: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   buildGraph: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   context: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   createEvents: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   createPointerEvents: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   createPortal: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   createRoot: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   dispose: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   events: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   extend: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   flushGlobalEffects: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   flushSync: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   getRootState: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   invalidate: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   reconciler: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   render: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   unmountComponentAtNode: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   useFrame: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   useGraph: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   useInstanceHandle: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   useLoader: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.H),\n/* harmony export */   useStore: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   useThree: () => (/* reexport safe */ _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.D)\n/* harmony export */ });\n/* harmony import */ var _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events-776716bd.esm.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-776716bd.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react_use_measure__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-use-measure */ \"(ssr)/./node_modules/react-use-measure/dist/index.js\");\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst CanvasImpl = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(function Canvas({ children, fallback, resize, style, gl, events = _events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.c, eventSource, eventPrefix, shadows, linear, flat, legacy, orthographic, frameloop, dpr, performance, raycaster, camera, scene, onPointerMissed, onCreated, ...props }, forwardedRef) {\n    // Create a known catalogue of Threejs-native elements\n    // This will include the entire THREE namespace by default, users can extend\n    // their own elements by using the createRoot API instead\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>(0,_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(three__WEBPACK_IMPORTED_MODULE_6__), []);\n    const Bridge = (0,its_fine__WEBPACK_IMPORTED_MODULE_7__.useContextBridge)();\n    const [containerRef, containerRect] = (0,react_use_measure__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({\n        scroll: true,\n        debounce: {\n            scroll: 50,\n            resize: 0\n        },\n        ...resize\n    });\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const divRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(forwardedRef, ()=>canvasRef.current);\n    const handlePointerMissed = (0,_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(onPointerMissed);\n    const [block, setBlock] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const [error, setError] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    // Suspend this component if block is a promise (2nd run)\n    if (block) throw block;\n    // Throw exception outwards if anything within canvas throws\n    if (error) throw error;\n    const root = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    (0,_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(()=>{\n        const canvas = canvasRef.current;\n        if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n            if (!root.current) root.current = (0,_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(canvas);\n            root.current.configure({\n                gl,\n                events,\n                shadows,\n                linear,\n                flat,\n                legacy,\n                orthographic,\n                frameloop,\n                dpr,\n                performance,\n                raycaster,\n                camera,\n                scene,\n                size: containerRect,\n                // Pass mutable reference to onPointerMissed so it's free to update\n                onPointerMissed: (...args)=>handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),\n                onCreated: (state)=>{\n                    // Connect to event source\n                    state.events.connect == null ? void 0 : state.events.connect(eventSource ? (0,_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(eventSource) ? eventSource.current : eventSource : divRef.current);\n                    // Set up compute function\n                    if (eventPrefix) {\n                        state.setEvents({\n                            compute: (event, state)=>{\n                                const x = event[eventPrefix + \"X\"];\n                                const y = event[eventPrefix + \"Y\"];\n                                state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                                state.raycaster.setFromCamera(state.pointer, state.camera);\n                            }\n                        });\n                    }\n                    // Call onCreated callback\n                    onCreated == null ? void 0 : onCreated(state);\n                }\n            });\n            root.current.render(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Bridge, {\n                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.E, {\n                    set: setError,\n                    children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, {\n                        fallback: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.B, {\n                            set: setBlock\n                        }),\n                        children: children != null ? children : null\n                    })\n                })\n            }));\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const canvas = canvasRef.current;\n        if (canvas) return ()=>(0,_events_776716bd_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(canvas);\n    }, []);\n    // When the event source is not this div, we need to set pointer-events to none\n    // Or else the canvas will block events from reaching the event source\n    const pointerEvents = eventSource ? \"none\" : \"auto\";\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n        ref: divRef,\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\",\n            overflow: \"hidden\",\n            pointerEvents,\n            ...style\n        },\n        ...props,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n            ref: containerRef,\n            style: {\n                width: \"100%\",\n                height: \"100%\"\n            },\n            children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"canvas\", {\n                ref: canvasRef,\n                style: {\n                    display: \"block\"\n                },\n                children: fallback\n            })\n        })\n    });\n});\n/**\r\n * A DOM canvas which accepts threejs elements as children.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\r\n */ const Canvas = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(function CanvasWrapper(props, ref) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(its_fine__WEBPACK_IMPORTED_MODULE_7__.FiberProvider, {\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CanvasImpl, {\n            ...props,\n            ref: ref\n        })\n    });\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb087QUFDeVU7QUFDOWdCO0FBQ0E7QUFDWTtBQUNnQjtBQUNuQjtBQUNKO0FBQ25CO0FBQ007QUFDRztBQUNQO0FBRW5CLE1BQU0yRSxhQUFhLFdBQVcsR0FBRU4sNkNBQWdCLENBQUMsU0FBU1EsT0FBTyxFQUMvREMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLE1BQU0sRUFDTkMsS0FBSyxFQUNMQyxFQUFFLEVBQ0Z0QyxTQUFTM0Msc0RBQW1CLEVBQzVCa0YsV0FBVyxFQUNYQyxXQUFXLEVBQ1hDLE9BQU8sRUFDUEMsTUFBTSxFQUNOQyxJQUFJLEVBQ0pDLE1BQU0sRUFDTkMsWUFBWSxFQUNaQyxTQUFTLEVBQ1RDLEdBQUcsRUFDSEMsV0FBVyxFQUNYQyxTQUFTLEVBQ1RDLE1BQU0sRUFDTkMsS0FBSyxFQUNMQyxlQUFlLEVBQ2ZDLFNBQVMsRUFDVCxHQUFHQyxPQUNKLEVBQUVDLFlBQVk7SUFDYixzREFBc0Q7SUFDdEQsNEVBQTRFO0lBQzVFLHlEQUF5RDtJQUN6RDlCLDBDQUFhLENBQUMsSUFBTWxFLDBEQUFNQSxDQUFDbUUsa0NBQUtBLEdBQUcsRUFBRTtJQUNyQyxNQUFNK0IsU0FBUzVCLDBEQUFnQkE7SUFDL0IsTUFBTSxDQUFDNkIsY0FBY0MsY0FBYyxHQUFHaEMsNkRBQVVBLENBQUM7UUFDL0NpQyxRQUFRO1FBQ1JDLFVBQVU7WUFDUkQsUUFBUTtZQUNSeEIsUUFBUTtRQUNWO1FBQ0EsR0FBR0EsTUFBTTtJQUNYO0lBQ0EsTUFBTTBCLFlBQVlyQyx5Q0FBWSxDQUFDO0lBQy9CLE1BQU11QyxTQUFTdkMseUNBQVksQ0FBQztJQUM1QkEsc0RBQXlCLENBQUM4QixjQUFjLElBQU1PLFVBQVVJLE9BQU87SUFDL0QsTUFBTUMs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O1FBQ0wzQixPQUFPO1lBQ0x1RCxVQUFVO1lBQ1ZqQixPQUFPO1lBQ1BDLFFBQVE7WUFDUmlCLFVBQVU7WUFDVkg7WUFDQSxHQUFHckQsS0FBSztRQUNWO1FBQ0EsR0FBR2lCLEtBQUs7UUFDUnBCLFVBQVUsV0FBVyxHQUFFSixzREFBR0EsQ0FBQyxPQUFPO1lBQ2hDNkQsS0FBS2pDO1lBQ0xyQixPQUFPO2dCQUNMc0MsT0FBTztnQkFDUEMsUUFBUTtZQUNWO1lBQ0ExQyxVQUFVLFdBQVcsR0FBRUosc0RBQUdBLENBQUMsVUFBVTtnQkFDbkM2RCxLQUFLN0I7Z0JBQ0x6QixPQUFPO29CQUNMeUQsU0FBUztnQkFDWDtnQkFDQTVELFVBQVVDO1lBQ1o7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxNQUFNRixTQUFTLFdBQVcsR0FBRVIsNkNBQWdCLENBQUMsU0FBU3NFLGNBQWN6QyxLQUFLLEVBQUVxQyxHQUFHO0lBQzVFLE9BQU8sV0FBVyxHQUFFN0Qsc0RBQUdBLENBQUNGLG1EQUFhQSxFQUFFO1FBQ3JDTSxVQUFVLFdBQVcsR0FBRUosc0RBQUdBLENBQUNDLFlBQVk7WUFDckMsR0FBR3VCLEtBQUs7WUFDUnFDLEtBQUtBO1FBQ1A7SUFDRjtBQUNGO0FBRWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9kaXN0L3JlYWN0LXRocmVlLWZpYmVyLmVzbS5qcz83OWNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGMgYXMgY3JlYXRlUG9pbnRlckV2ZW50cywgZSBhcyBleHRlbmQsIHUgYXMgdXNlTXV0YWJsZUNhbGxiYWNrLCBhIGFzIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QsIGIgYXMgY3JlYXRlUm9vdCwgaSBhcyBpc1JlZiwgRSBhcyBFcnJvckJvdW5kYXJ5LCBCIGFzIEJsb2NrLCBkIGFzIHVubW91bnRDb21wb25lbnRBdE5vZGUgfSBmcm9tICcuL2V2ZW50cy03NzY3MTZiZC5lc20uanMnO1xuZXhwb3J0IHsgdCBhcyBSZWFjdFRocmVlRmliZXIsIHogYXMgX3Jvb3RzLCB4IGFzIGFjdCwgcCBhcyBhZGRBZnRlckVmZmVjdCwgbyBhcyBhZGRFZmZlY3QsIHEgYXMgYWRkVGFpbCwgbiBhcyBhZHZhbmNlLCBrIGFzIGFwcGx5UHJvcHMsIHkgYXMgYnVpbGRHcmFwaCwgZyBhcyBjb250ZXh0LCBmIGFzIGNyZWF0ZUV2ZW50cywgYyBhcyBjcmVhdGVQb2ludGVyRXZlbnRzLCBoIGFzIGNyZWF0ZVBvcnRhbCwgYiBhcyBjcmVhdGVSb290LCBsIGFzIGRpc3Bvc2UsIGMgYXMgZXZlbnRzLCBlIGFzIGV4dGVuZCwgcyBhcyBmbHVzaEdsb2JhbEVmZmVjdHMsIHYgYXMgZmx1c2hTeW5jLCB3IGFzIGdldFJvb3RTdGF0ZSwgbSBhcyBpbnZhbGlkYXRlLCBqIGFzIHJlY29uY2lsZXIsIHIgYXMgcmVuZGVyLCBkIGFzIHVubW91bnRDb21wb25lbnRBdE5vZGUsIEYgYXMgdXNlRnJhbWUsIEcgYXMgdXNlR3JhcGgsIEEgYXMgdXNlSW5zdGFuY2VIYW5kbGUsIEggYXMgdXNlTG9hZGVyLCBDIGFzIHVzZVN0b3JlLCBEIGFzIHVzZVRocmVlIH0gZnJvbSAnLi9ldmVudHMtNzc2NzE2YmQuZXNtLmpzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB1c2VNZWFzdXJlIGZyb20gJ3JlYWN0LXVzZS1tZWFzdXJlJztcbmltcG9ydCB7IEZpYmVyUHJvdmlkZXIsIHVzZUNvbnRleHRCcmlkZ2UgfSBmcm9tICdpdHMtZmluZSc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgJ3JlYWN0LXJlY29uY2lsZXIvY29uc3RhbnRzJztcbmltcG9ydCAnenVzdGFuZCc7XG5pbXBvcnQgJ3N1c3BlbmQtcmVhY3QnO1xuaW1wb3J0ICdyZWFjdC1yZWNvbmNpbGVyJztcbmltcG9ydCAnc2NoZWR1bGVyJztcblxuY29uc3QgQ2FudmFzSW1wbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENhbnZhcyh7XG4gIGNoaWxkcmVuLFxuICBmYWxsYmFjayxcbiAgcmVzaXplLFxuICBzdHlsZSxcbiAgZ2wsXG4gIGV2ZW50cyA9IGNyZWF0ZVBvaW50ZXJFdmVudHMsXG4gIGV2ZW50U291cmNlLFxuICBldmVudFByZWZpeCxcbiAgc2hhZG93cyxcbiAgbGluZWFyLFxuICBmbGF0LFxuICBsZWdhY3ksXG4gIG9ydGhvZ3JhcGhpYyxcbiAgZnJhbWVsb29wLFxuICBkcHIsXG4gIHBlcmZvcm1hbmNlLFxuICByYXljYXN0ZXIsXG4gIGNhbWVyYSxcbiAgc2NlbmUsXG4gIG9uUG9pbnRlck1pc3NlZCxcbiAgb25DcmVhdGVkLFxuICAuLi5wcm9wc1xufSwgZm9yd2FyZGVkUmVmKSB7XG4gIC8vIENyZWF0ZSBhIGtub3duIGNhdGFsb2d1ZSBvZiBUaHJlZWpzLW5hdGl2ZSBlbGVtZW50c1xuICAvLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgZW50aXJlIFRIUkVFIG5hbWVzcGFjZSBieSBkZWZhdWx0LCB1c2VycyBjYW4gZXh0ZW5kXG4gIC8vIHRoZWlyIG93biBlbGVtZW50cyBieSB1c2luZyB0aGUgY3JlYXRlUm9vdCBBUEkgaW5zdGVhZFxuICBSZWFjdC51c2VNZW1vKCgpID0+IGV4dGVuZChUSFJFRSksIFtdKTtcbiAgY29uc3QgQnJpZGdlID0gdXNlQ29udGV4dEJyaWRnZSgpO1xuICBjb25zdCBbY29udGFpbmVyUmVmLCBjb250YWluZXJSZWN0XSA9IHVzZU1lYXN1cmUoe1xuICAgIHNjcm9sbDogdHJ1ZSxcbiAgICBkZWJvdW5jZToge1xuICAgICAgc2Nyb2xsOiA1MCxcbiAgICAgIHJlc2l6ZTogMFxuICAgIH0sXG4gICAgLi4ucmVzaXplXG4gIH0pO1xuICBjb25zdCBjYW52YXNSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRpdlJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpID0+IGNhbnZhc1JlZi5jdXJyZW50KTtcbiAgY29uc3QgaGFuZGxlUG9pbnRlck1pc3NlZCA9IHVzZU11dGFibGVDYWxsYmFjayhvblBvaW50ZXJNaXNzZWQpO1xuICBjb25zdCBbYmxvY2ssIHNldEJsb2NrXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gU3VzcGVuZCB0aGlzIGNvbXBvbmVudCBpZiBibG9jayBpcyBhIHByb21pc2UgKDJuZCBydW4pXG4gIGlmIChibG9jaykgdGhyb3cgYmxvY2s7XG4gIC8vIFRocm93IGV4Y2VwdGlvbiBvdXR3YXJkcyBpZiBhbnl0aGluZyB3aXRoaW4gY2FudmFzIHRocm93c1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICBjb25zdCByb290ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY29udGFpbmVyUmVjdC53aWR0aCA+IDAgJiYgY29udGFpbmVyUmVjdC5oZWlnaHQgPiAwICYmIGNhbnZhcykge1xuICAgICAgaWYgKCFyb290LmN1cnJlbnQpIHJvb3QuY3VycmVudCA9IGNyZWF0ZVJvb3QoY2FudmFzKTtcbiAgICAgIHJvb3QuY3VycmVudC5jb25maWd1cmUoe1xuICAgICAgICBnbCxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBzaGFkb3dzLFxuICAgICAgICBsaW5lYXIsXG4gICAgICAgIGZsYXQsXG4gICAgICAgIGxlZ2FjeSxcbiAgICAgICAgb3J0aG9ncmFwaGljLFxuICAgICAgICBmcmFtZWxvb3AsXG4gICAgICAgIGRwcixcbiAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgIHJheWNhc3RlcixcbiAgICAgICAgY2FtZXJhLFxuICAgICAgICBzY2VuZSxcbiAgICAgICAgc2l6ZTogY29udGFpbmVyUmVjdCxcbiAgICAgICAgLy8gUGFzcyBtdXRhYmxlIHJlZmVyZW5jZSB0byBvblBvaW50ZXJNaXNzZWQgc28gaXQncyBmcmVlIHRvIHVwZGF0ZVxuICAgICAgICBvblBvaW50ZXJNaXNzZWQ6ICguLi5hcmdzKSA9PiBoYW5kbGVQb2ludGVyTWlzc2VkLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVBvaW50ZXJNaXNzZWQuY3VycmVudCguLi5hcmdzKSxcbiAgICAgICAgb25DcmVhdGVkOiBzdGF0ZSA9PiB7XG4gICAgICAgICAgLy8gQ29ubmVjdCB0byBldmVudCBzb3VyY2VcbiAgICAgICAgICBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3QoZXZlbnRTb3VyY2UgPyBpc1JlZihldmVudFNvdXJjZSkgPyBldmVudFNvdXJjZS5jdXJyZW50IDogZXZlbnRTb3VyY2UgOiBkaXZSZWYuY3VycmVudCk7XG4gICAgICAgICAgLy8gU2V0IHVwIGNvbXB1dGUgZnVuY3Rpb25cbiAgICAgICAgICBpZiAoZXZlbnRQcmVmaXgpIHtcbiAgICAgICAgICAgIHN0YXRlLnNldEV2ZW50cyh7XG4gICAgICAgICAgICAgIGNvbXB1dGU6IChldmVudCwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gZXZlbnRbZXZlbnRQcmVmaXggKyAnWCddO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBldmVudFtldmVudFByZWZpeCArICdZJ107XG4gICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlci5zZXQoeCAvIHN0YXRlLnNpemUud2lkdGggKiAyIC0gMSwgLSh5IC8gc3RhdGUuc2l6ZS5oZWlnaHQpICogMiArIDEpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHN0YXRlLnBvaW50ZXIsIHN0YXRlLmNhbWVyYSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIG9uQ3JlYXRlZCBjYWxsYmFja1xuICAgICAgICAgIG9uQ3JlYXRlZCA9PSBudWxsID8gdm9pZCAwIDogb25DcmVhdGVkKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByb290LmN1cnJlbnQucmVuZGVyKCAvKiNfX1BVUkVfXyovanN4KEJyaWRnZSwge1xuICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgICAgc2V0OiBzZXRFcnJvcixcbiAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChSZWFjdC5TdXNwZW5zZSwge1xuICAgICAgICAgICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi9qc3goQmxvY2ssIHtcbiAgICAgICAgICAgICAgc2V0OiBzZXRCbG9ja1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4gIT0gbnVsbCA/IGNoaWxkcmVuIDogbnVsbFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY2FudmFzKSByZXR1cm4gKCkgPT4gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMpO1xuICB9LCBbXSk7XG5cbiAgLy8gV2hlbiB0aGUgZXZlbnQgc291cmNlIGlzIG5vdCB0aGlzIGRpdiwgd2UgbmVlZCB0byBzZXQgcG9pbnRlci1ldmVudHMgdG8gbm9uZVxuICAvLyBPciBlbHNlIHRoZSBjYW52YXMgd2lsbCBibG9jayBldmVudHMgZnJvbSByZWFjaGluZyB0aGUgZXZlbnQgc291cmNlXG4gIGNvbnN0IHBvaW50ZXJFdmVudHMgPSBldmVudFNvdXJjZSA/ICdub25lJyA6ICdhdXRvJztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgIHJlZjogZGl2UmVmLFxuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIHBvaW50ZXJFdmVudHMsXG4gICAgICAuLi5zdHlsZVxuICAgIH0sXG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgICBzdHlsZToge1xuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KFwiY2FudmFzXCIsIHtcbiAgICAgICAgcmVmOiBjYW52YXNSZWYsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogZmFsbGJhY2tcbiAgICAgIH0pXG4gICAgfSlcbiAgfSk7XG59KTtcblxuLyoqXHJcbiAqIEEgRE9NIGNhbnZhcyB3aGljaCBhY2NlcHRzIHRocmVlanMgZWxlbWVudHMgYXMgY2hpbGRyZW4uXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2NhbnZhc1xyXG4gKi9cbmNvbnN0IENhbnZhcyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENhbnZhc1dyYXBwZXIocHJvcHMsIHJlZikge1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChGaWJlclByb3ZpZGVyLCB7XG4gICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9qc3goQ2FudmFzSW1wbCwge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICByZWY6IHJlZlxuICAgIH0pXG4gIH0pO1xufSk7XG5cbmV4cG9ydCB7IENhbnZhcyB9O1xuIl0sIm5hbWVzIjpbImMiLCJjcmVhdGVQb2ludGVyRXZlbnRzIiwiZSIsImV4dGVuZCIsInUiLCJ1c2VNdXRhYmxlQ2FsbGJhY2siLCJhIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsImIiLCJjcmVhdGVSb290IiwiaSIsImlzUmVmIiwiRSIsIkVycm9yQm91bmRhcnkiLCJCIiwiQmxvY2siLCJkIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInQiLCJSZWFjdFRocmVlRmliZXIiLCJ6IiwiX3Jvb3RzIiwieCIsImFjdCIsInAiLCJhZGRBZnRlckVmZmVjdCIsIm8iLCJhZGRFZmZlY3QiLCJxIiwiYWRkVGFpbCIsIm4iLCJhZHZhbmNlIiwiayIsImFwcGx5UHJvcHMiLCJ5IiwiYnVpbGRHcmFwaCIsImciLCJjb250ZXh0IiwiZiIsImNyZWF0ZUV2ZW50cyIsImgiLCJjcmVhdGVQb3J0YWwiLCJsIiwiZGlzcG9zZSIsImV2ZW50cyIsInMiLCJmbHVzaEdsb2JhbEVmZmVjdHMiLCJ2IiwiZmx1c2hTeW5jIiwidyIsImdldFJvb3RTdGF0ZSIsIm0iLCJpbnZhbGlkYXRlIiwiaiIsInJlY29uY2lsZXIiLCJyIiwicmVuZGVyIiwiRiIsInVzZUZyYW1lIiwiRyIsInVzZUdyYXBoIiwiQSIsInVzZUluc3RhbmNlSGFuZGxlIiwiSCIsInVzZUxvYWRlciIsIkMiLCJ1c2VTdG9yZSIsIkQiLCJ1c2VUaHJlZSIsIlJlYWN0IiwiVEhSRUUiLCJ1c2VNZWFzdXJlIiwiRmliZXJQcm92aWRlciIsInVzZUNvbnRleHRCcmlkZ2UiLCJqc3giLCJDYW52YXNJbXBsIiwiZm9yd2FyZFJlZiIsIkNhbnZhcyIsImNoaWxkcmVuIiwiZmFsbGJhY2siLCJyZXNpemUiLCJzdHlsZSIsImdsIiwiZXZlbnRTb3VyY2UiLCJldmVudFByZWZpeCIsInNoYWRvd3MiLCJsaW5lYXIiLCJmbGF0IiwibGVnYWN5Iiwib3J0aG9ncmFwaGljIiwiZnJhbWVsb29wIiwiZHByIiwicGVyZm9ybWFuY2UiLCJyYXljYXN0ZXIiLCJjYW1lcmEiLCJzY2VuZSIsIm9uUG9pbnRlck1pc3NlZCIsIm9uQ3JlYXRlZCIsInByb3BzIiwiZm9yd2FyZGVkUmVmIiwidXNlTWVtbyIsIkJyaWRnZSIsImNvbnRhaW5lclJlZiIsImNvbnRhaW5lclJlY3QiLCJzY3JvbGwiLCJkZWJvdW5jZSIsImNhbnZhc1JlZiIsInVzZVJlZiIsImRpdlJlZiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJjdXJyZW50IiwiaGFuZGxlUG9pbnRlck1pc3NlZCIsImJsb2NrIiwic2V0QmxvY2siLCJ1c2VTdGF0ZSIsImVycm9yIiwic2V0RXJyb3IiLCJyb290IiwiY2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJjb25maWd1cmUiLCJzaXplIiwiYXJncyIsInN0YXRlIiwiY29ubmVjdCIsInNldEV2ZW50cyIsImNvbXB1dGUiLCJldmVudCIsInBvaW50ZXIiLCJzZXQiLCJzZXRGcm9tQ2FtZXJhIiwiU3VzcGVuc2UiLCJ1c2VFZmZlY3QiLCJwb2ludGVyRXZlbnRzIiwicmVmIiwicG9zaXRpb24iLCJvdmVyZmxvdyIsImRpc3BsYXkiLCJDYW52YXNXcmFwcGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction createStore(createState) {\n    let state;\n    const listeners = /* @__PURE__ */ new Set();\n    const setState = (partial, replace)=>{\n        const nextState = typeof partial === \"function\" ? partial(state) : partial;\n        if (nextState !== state) {\n            const previousState = state;\n            state = replace ? nextState : Object.assign({}, state, nextState);\n            listeners.forEach((listener)=>listener(state, previousState));\n        }\n    };\n    const getState = ()=>state;\n    const subscribeWithSelector = (listener, selector = getState, equalityFn = Object.is)=>{\n        console.warn(\"[DEPRECATED] Please use `subscribeWithSelector` middleware\");\n        let currentSlice = selector(state);\n        function listenerToAdd() {\n            const nextSlice = selector(state);\n            if (!equalityFn(currentSlice, nextSlice)) {\n                const previousSlice = currentSlice;\n                listener(currentSlice = nextSlice, previousSlice);\n            }\n        }\n        listeners.add(listenerToAdd);\n        return ()=>listeners.delete(listenerToAdd);\n    };\n    const subscribe = (listener, selector, equalityFn)=>{\n        if (selector || equalityFn) {\n            return subscribeWithSelector(listener, selector, equalityFn);\n        }\n        listeners.add(listener);\n        return ()=>listeners.delete(listener);\n    };\n    const destroy = ()=>listeners.clear();\n    const api = {\n        setState,\n        getState,\n        subscribe,\n        destroy\n    };\n    state = createState(setState, getState, api);\n    return api;\n}\nconst isSSR =  true || 0;\nconst useIsomorphicLayoutEffect = isSSR ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\nfunction create(createState) {\n    const api = typeof createState === \"function\" ? createStore(createState) : createState;\n    const useStore = (selector = api.getState, equalityFn = Object.is)=>{\n        const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((c)=>c + 1, 0);\n        const state = api.getState();\n        const stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n        const selectorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(selector);\n        const equalityFnRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(equalityFn);\n        const erroredRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n        const currentSliceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n        if (currentSliceRef.current === void 0) {\n            currentSliceRef.current = selector(state);\n        }\n        let newStateSlice;\n        let hasNewStateSlice = false;\n        if (stateRef.current !== state || selectorRef.current !== selector || equalityFnRef.current !== equalityFn || erroredRef.current) {\n            newStateSlice = selector(state);\n            hasNewStateSlice = !equalityFn(currentSliceRef.current, newStateSlice);\n        }\n        useIsomorphicLayoutEffect(()=>{\n            if (hasNewStateSlice) {\n                currentSliceRef.current = newStateSlice;\n            }\n            stateRef.current = state;\n            selectorRef.current = selector;\n            equalityFnRef.current = equalityFn;\n            erroredRef.current = false;\n        });\n        const stateBeforeSubscriptionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n        useIsomorphicLayoutEffect(()=>{\n            const listener = ()=>{\n                try {\n                    const nextState = api.getState();\n                    const nextStateSlice = selectorRef.current(nextState);\n                    if (!equalityFnRef.current(currentSliceRef.current, nextStateSlice)) {\n                        stateRef.current = nextState;\n                        currentSliceRef.current = nextStateSlice;\n                        forceUpdate();\n                    }\n                } catch (error) {\n                    erroredRef.current = true;\n                    forceUpdate();\n                }\n            };\n            const unsubscribe = api.subscribe(listener);\n            if (api.getState() !== stateBeforeSubscriptionRef.current) {\n                listener();\n            }\n            return unsubscribe;\n        }, []);\n        const sliceToReturn = hasNewStateSlice ? newStateSlice : currentSliceRef.current;\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(sliceToReturn);\n        return sliceToReturn;\n    };\n    Object.assign(useStore, api);\n    useStore[Symbol.iterator] = function() {\n        console.warn(\"[useStore, api] = create() is deprecated and will be removed in v4\");\n        const items = [\n            useStore,\n            api\n        ];\n        return {\n            next () {\n                const done = items.length <= 0;\n                return {\n                    value: items.shift(),\n                    done\n                };\n            }\n        };\n    };\n    return useStore;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0Y7QUFFdEYsU0FBU0ssWUFBWUMsV0FBVztJQUM5QixJQUFJQztJQUNKLE1BQU1DLFlBQVksYUFBYSxHQUFHLElBQUlDO0lBQ3RDLE1BQU1DLFdBQVcsQ0FBQ0MsU0FBU0M7UUFDekIsTUFBTUMsWUFBWSxPQUFPRixZQUFZLGFBQWFBLFFBQVFKLFNBQVNJO1FBQ25FLElBQUlFLGNBQWNOLE9BQU87WUFDdkIsTUFBTU8sZ0JBQWdCUDtZQUN0QkEsUUFBUUssVUFBVUMsWUFBWUUsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR1QsT0FBT007WUFDdkRMLFVBQVVTLE9BQU8sQ0FBQyxDQUFDQyxXQUFhQSxTQUFTWCxPQUFPTztRQUNsRDtJQUNGO0lBQ0EsTUFBTUssV0FBVyxJQUFNWjtJQUN2QixNQUFNYSx3QkFBd0IsQ0FBQ0YsVUFBVUcsV0FBV0YsUUFBUSxFQUFFRyxhQUFhUCxPQUFPUSxFQUFFO1FBQ2xGQyxRQUFRQyxJQUFJLENBQUM7UUFDYixJQUFJQyxlQUFlTCxTQUFTZDtRQUM1QixTQUFTb0I7WUFDUCxNQUFNQyxZQUFZUCxTQUFTZDtZQUMzQixJQUFJLENBQUNlLFdBQVdJLGNBQWNFLFlBQVk7Z0JBQ3hDLE1BQU1DLGdCQUFnQkg7Z0JBQ3RCUixTQUFTUSxlQUFlRSxXQUFXQztZQUNyQztRQUNGO1FBQ0FyQixVQUFVc0IsR0FBRyxDQUFDSDtRQUNkLE9BQU8sSUFBTW5CLFVBQVV1QixNQUFNLENBQUNKO0lBQ2hDO0lBQ0EsTUFBTUssWUFBWSxDQUFDZCxVQUFVRyxVQUFVQztRQUNyQyxJQUFJRCxZQUFZQyxZQUFZO1lBQzFCLE9BQU9GLHNCQUFzQkYsVUFBVUcsVUFBVUM7UUFDbkQ7UUFDQWQsVUFBVXNCLEdBQUcsQ0FBQ1o7UUFDZCxPQUFPLElBQU1WLFVBQVV1QixNQUFNLENBQUNi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LE1BQU1HLE1BQU0sSUFBSTtnQkFDN0IsT0FBTztvQkFBRUMsT0FBT0osTUFBTUssS0FBSztvQkFBSUg7Z0JBQUs7WUFDdEM7UUFDRjtJQUNGO0lBQ0EsT0FBT3BCO0FBQ1Q7QUFFNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9pbmRleC5qcz8zMzAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZHVjZXIsIHVzZVJlZiwgdXNlRGVidWdWYWx1ZSwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKGNyZWF0ZVN0YXRlKSB7XG4gIGxldCBzdGF0ZTtcbiAgY29uc3QgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3Qgc2V0U3RhdGUgPSAocGFydGlhbCwgcmVwbGFjZSkgPT4ge1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHR5cGVvZiBwYXJ0aWFsID09PSBcImZ1bmN0aW9uXCIgPyBwYXJ0aWFsKHN0YXRlKSA6IHBhcnRpYWw7XG4gICAgaWYgKG5leHRTdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBzdGF0ZTtcbiAgICAgIHN0YXRlID0gcmVwbGFjZSA/IG5leHRTdGF0ZSA6IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCBuZXh0U3RhdGUpO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihzdGF0ZSwgcHJldmlvdXNTdGF0ZSkpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ2V0U3RhdGUgPSAoKSA9PiBzdGF0ZTtcbiAgY29uc3Qgc3Vic2NyaWJlV2l0aFNlbGVjdG9yID0gKGxpc3RlbmVyLCBzZWxlY3RvciA9IGdldFN0YXRlLCBlcXVhbGl0eUZuID0gT2JqZWN0LmlzKSA9PiB7XG4gICAgY29uc29sZS53YXJuKFwiW0RFUFJFQ0FURURdIFBsZWFzZSB1c2UgYHN1YnNjcmliZVdpdGhTZWxlY3RvcmAgbWlkZGxld2FyZVwiKTtcbiAgICBsZXQgY3VycmVudFNsaWNlID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgIGZ1bmN0aW9uIGxpc3RlbmVyVG9BZGQoKSB7XG4gICAgICBjb25zdCBuZXh0U2xpY2UgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICBpZiAoIWVxdWFsaXR5Rm4oY3VycmVudFNsaWNlLCBuZXh0U2xpY2UpKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzU2xpY2UgPSBjdXJyZW50U2xpY2U7XG4gICAgICAgIGxpc3RlbmVyKGN1cnJlbnRTbGljZSA9IG5leHRTbGljZSwgcHJldmlvdXNTbGljZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXJUb0FkZCk7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXJUb0FkZCk7XG4gIH07XG4gIGNvbnN0IHN1YnNjcmliZSA9IChsaXN0ZW5lciwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4pID0+IHtcbiAgICBpZiAoc2VsZWN0b3IgfHwgZXF1YWxpdHlGbikge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZVdpdGhTZWxlY3RvcihsaXN0ZW5lciwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH07XG4gIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiBsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgY29uc3QgYXBpID0geyBzZXRTdGF0ZSwgZ2V0U3RhdGUsIHN1YnNjcmliZSwgZGVzdHJveSB9O1xuICBzdGF0ZSA9IGNyZWF0ZVN0YXRlKHNldFN0YXRlLCBnZXRTdGF0ZSwgYXBpKTtcbiAgcmV0dXJuIGFwaTtcbn1cblxuY29uc3QgaXNTU1IgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICF3aW5kb3cubmF2aWdhdG9yIHx8IC9TZXJ2ZXJTaWRlUmVuZGVyaW5nfF5EZW5vXFwvLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBpc1NTUiA/IHVzZUVmZmVjdCA6IHVzZUxheW91dEVmZmVjdDtcbmZ1bmN0aW9uIGNyZWF0ZShjcmVhdGVTdGF0ZSkge1xuICBjb25zdCBhcGkgPSB0eXBlb2YgY3JlYXRlU3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNyZWF0ZVN0b3JlKGNyZWF0ZVN0YXRlKSA6IGNyZWF0ZVN0YXRlO1xuICBjb25zdCB1c2VTdG9yZSA9IChzZWxlY3RvciA9IGFwaS5nZXRTdGF0ZSwgZXF1YWxpdHlGbiA9IE9iamVjdC5pcykgPT4ge1xuICAgIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVJlZHVjZXIoKGMpID0+IGMgKyAxLCAwKTtcbiAgICBjb25zdCBzdGF0ZSA9IGFwaS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHN0YXRlUmVmID0gdXNlUmVmKHN0YXRlKTtcbiAgICBjb25zdCBzZWxlY3RvclJlZiA9IHVzZVJlZihzZWxlY3Rvcik7XG4gICAgY29uc3QgZXF1YWxpdHlGblJlZiA9IHVzZVJlZihlcXVhbGl0eUZuKTtcbiAgICBjb25zdCBlcnJvcmVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBjdXJyZW50U2xpY2VSZWYgPSB1c2VSZWYoKTtcbiAgICBpZiAoY3VycmVudFNsaWNlUmVmLmN1cnJlbnQgPT09IHZvaWQgMCkge1xuICAgICAgY3VycmVudFNsaWNlUmVmLmN1cnJlbnQgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgfVxuICAgIGxldCBuZXdTdGF0ZVNsaWNlO1xuICAgIGxldCBoYXNOZXdTdGF0ZVNsaWNlID0gZmFsc2U7XG4gICAgaWYgKHN0YXRlUmVmLmN1cnJlbnQgIT09IHN0YXRlIHx8IHNlbGVjdG9yUmVmLmN1cnJlbnQgIT09IHNlbGVjdG9yIHx8IGVxdWFsaXR5Rm5SZWYuY3VycmVudCAhPT0gZXF1YWxpdHlGbiB8fCBlcnJvcmVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIG5ld1N0YXRlU2xpY2UgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICBoYXNOZXdTdGF0ZVNsaWNlID0gIWVxdWFsaXR5Rm4oY3VycmVudFNsaWNlUmVmLmN1cnJlbnQsIG5ld1N0YXRlU2xpY2UpO1xuICAgIH1cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChoYXNOZXdTdGF0ZVNsaWNlKSB7XG4gICAgICAgIGN1cnJlbnRTbGljZVJlZi5jdXJyZW50ID0gbmV3U3RhdGVTbGljZTtcbiAgICAgIH1cbiAgICAgIHN0YXRlUmVmLmN1cnJlbnQgPSBzdGF0ZTtcbiAgICAgIHNlbGVjdG9yUmVmLmN1cnJlbnQgPSBzZWxlY3RvcjtcbiAgICAgIGVxdWFsaXR5Rm5SZWYuY3VycmVudCA9IGVxdWFsaXR5Rm47XG4gICAgICBlcnJvcmVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICBjb25zdCBzdGF0ZUJlZm9yZVN1YnNjcmlwdGlvblJlZiA9IHVzZVJlZihzdGF0ZSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBuZXh0U3RhdGUgPSBhcGkuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBjb25zdCBuZXh0U3RhdGVTbGljZSA9IHNlbGVjdG9yUmVmLmN1cnJlbnQobmV4dFN0YXRlKTtcbiAgICAgICAgICBpZiAoIWVxdWFsaXR5Rm5SZWYuY3VycmVudChjdXJyZW50U2xpY2VSZWYuY3VycmVudCwgbmV4dFN0YXRlU2xpY2UpKSB7XG4gICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50ID0gbmV4dFN0YXRlO1xuICAgICAgICAgICAgY3VycmVudFNsaWNlUmVmLmN1cnJlbnQgPSBuZXh0U3RhdGVTbGljZTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGVycm9yZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gYXBpLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgICBpZiAoYXBpLmdldFN0YXRlKCkgIT09IHN0YXRlQmVmb3JlU3Vic2NyaXB0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgc2xpY2VUb1JldHVybiA9IGhhc05ld1N0YXRlU2xpY2UgPyBuZXdTdGF0ZVNsaWNlIDogY3VycmVudFNsaWNlUmVmLmN1cnJlbnQ7XG4gICAgdXNlRGVidWdWYWx1ZShzbGljZVRvUmV0dXJuKTtcbiAgICByZXR1cm4gc2xpY2VUb1JldHVybjtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VTdG9yZSwgYXBpKTtcbiAgdXNlU3RvcmVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUud2FybihcIlt1c2VTdG9yZSwgYXBpXSA9IGNyZWF0ZSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2NFwiKTtcbiAgICBjb25zdCBpdGVtcyA9IFt1c2VTdG9yZSwgYXBpXTtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgZG9uZSA9IGl0ZW1zLmxlbmd0aCA8PSAwO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbXMuc2hpZnQoKSwgZG9uZSB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiB1c2VTdG9yZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJ1c2VSZWR1Y2VyIiwidXNlUmVmIiwidXNlRGVidWdWYWx1ZSIsInVzZUVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsImNyZWF0ZVN0b3JlIiwiY3JlYXRlU3RhdGUiLCJzdGF0ZSIsImxpc3RlbmVycyIsIlNldCIsInNldFN0YXRlIiwicGFydGlhbCIsInJlcGxhY2UiLCJuZXh0U3RhdGUiLCJwcmV2aW91c1N0YXRlIiwiT2JqZWN0IiwiYXNzaWduIiwiZm9yRWFjaCIsImxpc3RlbmVyIiwiZ2V0U3RhdGUiLCJzdWJzY3JpYmVXaXRoU2VsZWN0b3IiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm4iLCJpcyIsImNvbnNvbGUiLCJ3YXJuIiwiY3VycmVudFNsaWNlIiwibGlzdGVuZXJUb0FkZCIsIm5leHRTbGljZSIsInByZXZpb3VzU2xpY2UiLCJhZGQiLCJkZWxldGUiLCJzdWJzY3JpYmUiLCJkZXN0cm95IiwiY2xlYXIiLCJhcGkiLCJpc1NTUiIsIndpbmRvdyIsIm5hdmlnYXRvciIsInRlc3QiLCJ1c2VyQWdlbnQiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiY3JlYXRlIiwidXNlU3RvcmUiLCJmb3JjZVVwZGF0ZSIsImMiLCJzdGF0ZVJlZiIsInNlbGVjdG9yUmVmIiwiZXF1YWxpdHlGblJlZiIsImVycm9yZWRSZWYiLCJjdXJyZW50U2xpY2VSZWYiLCJjdXJyZW50IiwibmV3U3RhdGVTbGljZSIsImhhc05ld1N0YXRlU2xpY2UiLCJzdGF0ZUJlZm9yZVN1YnNjcmlwdGlvblJlZiIsIm5leHRTdGF0ZVNsaWNlIiwiZXJyb3IiLCJ1bnN1YnNjcmliZSIsInNsaWNlVG9SZXR1cm4iLCJTeW1ib2wiLCJpdGVyYXRvciIsIml0ZW1zIiwibmV4dCIsImRvbmUiLCJsZW5ndGgiLCJ2YWx1ZSIsInNoaWZ0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js\n");

/***/ })

};
;